'use strict';

const path = require('path');
const fs = require('fs-extra');
const url = require('url');
const httpunch = require('@ebay/httpunch');
const tar = require('tar-fs');
const COMPONENT_STATUS_NAME = 'Global Config Status';
const _cache = {};
const logger = require('@ebay/logging-inc').logger('raptorconfig:globalConfig');
const YAML = require('yamljs');
const { ono } = require("@jsdevtools/ono");

const UNKNOWN_MANIFEST = 'Unknown';

let Provider;
let currentManifest;
let isDev = !process.env.NODE_ENV || /dev|test/.test(process.env.NODE_ENV);

function getModuleConfig() {
    const moduleConfig = require('@ebay/module-config-inc');
    return moduleConfig(module);
}

function getConfigRoot() {
    const root = getModuleConfig().get('raptor-config-ebay:globalconfig-root');
    if (process.env['CONFIG_HOME']) {
        return process.env['CONFIG_HOME'];
    } else if (process.env['CRONUSAPP_HOME']) {
        return path.join(process.env['CRONUSAPP_HOME'], root);
    } else {
        logger.info('the global config is not running on pool, read from local cache instead');
        const localRoot = path.resolve(process.cwd(), root);
        if (!fs.existsSync(localRoot)) {
            fs.mkdirsSync(localRoot);
        }
        return localRoot;
    }
}

/**
 * function for transfer global config to config node module can recognize
 * @param config
 */
function transfer(config) {
    // we need manipulate the config read from local file
    let result = {};
    result.validContexts = config.validContextList || [];
    result.properties = config.propertyList.map(property => {
        let contexts = result.validContexts.map(k => {
            let contextProp = property._contexts || {};
            return {
                key: k,
                value: contextProp[k]
            };
        });

        function resolveValueByType() {
            let type = property.type ? property.type.toLowerCase() : 'properties';
            if ((type === 'properties' || type === 'map') && property.value.length) {
                let mapValue = {};
                property.value.forEach(v => {
                    mapValue[v.key] = v.value;
                });
                return mapValue;
            }

            return property.value;
        }

        return {
            'key': property.key && property.key.trim(),
            'context': contexts,
            'value': resolveValueByType()
        };
    });
    return result;
}

/**
 * load the config from specified path
 * @param configPath
 * @param cb
 */
function loadConfigFile(configPath, cb) {
    fs.readFile(configPath, 'utf8', (error, data) => {
        if (error) {
            cb(error);
            return;
        }
        try {
            let config = transfer(JSON.parse(data));
            cb(null, config);
        } catch (e) {
            cb(ono(e, `Error while loadConfigFile config file to ${configPath}`));
        }
    });
}

/**
 * download the config from global config publisher and swift
 * @param configSepc
 * @param configRoot
 * @param callback
 */
function download(configSepc, configRoot, callback) {
    if (!Provider) {
        Provider = require('@ebay/service-client-ebay');
    }

    Provider.context({}).getClient('configpublisher').request({
            path: configSepc.project + '/' + configSepc.version
        }).end(function (error, response) {
            if (error) {
                callback(error);
                return;
            }

            let body = (Buffer.isBuffer(response.body) ?
                    response.body.toString() : response.body);

            if (response.statusCode >= 300) {
                error = ono({
                    logType: 'warn'
                }, `${
                    response.statusCode === 404 ? 'Not found' : 'Bad'} response from config publisher, statusCode: ${
                        response.statusCode}, body: ${(Buffer.isBuffer(response.body) ?
                    response.body.toString() : response.body)}`);
                callback(error);
                return;
            }

            let extract = tar.extract(configRoot);
            extract.on('finish', () => {
                callback(null);
            }).on('error', (e) => {
                callback(ono(e, `Error extracting config file to ${configRoot}`));
            });

            const parts = url.parse(body);
            const moduleConfig = getModuleConfig();
            const connectTimeout = moduleConfig.get('raptor-config-ebay:swift-connect-timeout');
            const socketTimeout = moduleConfig.get('raptor-config-ebay:swift-socket-timeout');
            const options = {
                    protocol: parts.protocol,
                    hostname: parts.hostname,
                    port: parts.port,
                    path: parts.path,
                    connectTimeout: connectTimeout || 1000,
                    socketTimeout: socketTimeout || 5000,
                    method: 'GET'
            };
            var req = httpunch.request(options, (err, res) =>{});
            req.on('response', function(res){
                if (res.statusCode >= 300) {
                    error = ono({
                        logType: 'warn'
                    }, `${
                        response.statusCode === 404 ? 'Not found' : 'Bad'} response from cronus repo, statusCode: ${
                            response.statusCode}, url: ${body}`);
                    callback(error);
                    return;
                }
                res.pipe(extract);
            }).on('error', (e) => {
                callback(ono(e, { logType: 'warn' }, `Error downloading config file from cronus repo: ${body}`));
            });
        });
}

/**
 * @param metaYamlPath
 */
function readManifestIdFromYaml(metaYamlPath) {
    const meta = YAML.load(metaYamlPath);
    return meta.configManifestId || UNKNOWN_MANIFEST;
}



/**
 * resolve the current config manifest id
 * @param refresh reload if true
 * @returns {*}
 */
function resolveManifestId(refresh) {
    if (currentManifest && !refresh) {
        return currentManifest;
    }
    try {
        const configRoot = getConfigRoot();
        if (!fs.existsSync(configRoot)) {
            currentManifest =    {
                value: configRoot + ' doesn\'t exist',
                status: 'Failed'
            };
        } else {
            let metaYamlPath = path.join(configRoot, '.manifest-meta.yaml');
            let metaJsonPath = path.join(configRoot, 'config-metadata.json');
            if (fs.existsSync(metaYamlPath)) {
                currentManifest = {value: readManifestIdFromYaml(metaYamlPath), status: 'OK'};
            } else if (fs.existsSync(metaJsonPath)) {
                let manifestJson = JSON.parse(fs.readFileSync(metaJsonPath, {encoding: 'utf8'}));
                currentManifest = {value: manifestJson.manifestId, status: 'OK'};
            } else {
                currentManifest = {value: UNKNOWN_MANIFEST, status: 'OK'};
            }
        }
    } catch (e) {
        currentManifest = {
            value: e,
            status: 'Failed'
        };
    }
    return currentManifest;
}

function registerGlobalConfigStatus() {
    function handler() {
        return {
            'name': COMPONENT_STATUS_NAME,
            'alias': COMPONENT_STATUS_NAME,
            'status': 'created',
            'properties': [Object.assign({'name': 'Config Manifest'}, resolveManifestId()), ...Object.values(_cache)]
        };
    }

    // eager query current manifest id
    // it's for the case below, and make sure running config manifest will be loaded as soon as possible
    // 1. app running on manifest-A, got restarted, since no one hit the VI
    // 2. config refresh to manifest-B in altus
    // 3. the config script check the running manifest id, since the manifestId was lazy loaded, it will return B
    // 4. the config skip the config refresh config bean as the status check says it's on target manifest already.
    resolveManifestId();
    logger.info('register the component status for global config');
    const vi = require('@ebay/validate-internals-ebay');
    vi.componentStatus.register(COMPONENT_STATUS_NAME, handler);
}

registerGlobalConfigStatus();

function loadGlobalConfig(configSpec, callback) {

    let configName = 'config.json';
    const defaultTarget = 'Global';
    if (configSpec.target && configSpec.target !== defaultTarget) {
        configName = 'config_' + configSpec.target + '.json';
    }

    const configRoot = getConfigRoot();
    const configPath = path.join(configRoot, configSpec.project, configSpec.config, configSpec.version, configName);
    const cbWrapper = function(error, data) {
        if (error && error && !(!process.env.NODE_ENV || /dev/.test(process.env.NODE_ENV))) {
            const logType = error.logType || 'error';
            logger[logType](error.message);
        }
        // register component status;
        const k = [configSpec.project, configSpec.config, configSpec.version, configSpec.target].join(':');
        _cache[k] = {
            'value': configPath,
            'name': configSpec.project,
            'version': configSpec.version,
            'target': configSpec.target || defaultTarget,
            'config': configSpec.config,
            'status': error || 'OK',
            'required': configSpec.required
        };
        callback(error, data);
    };
    if (fs.existsSync(configPath)) {
        // load if it exists
        loadConfigFile(configPath, cbWrapper);
    } else if (isDev) {
        // download and load it
        download(configSpec, path.join(configRoot, configSpec.project), function(err) {
            if (err) {
                cbWrapper(err);
                return;
            }
            loadConfigFile(configPath, cbWrapper);
        });
    } else {
        cbWrapper(Object.assign(new Error(`The config is not available ${configPath}, using local config`), {
            logType: 'warn'
        }));
    }
}

module.exports = {
    load: loadGlobalConfig,
    refreshManifest: resolveManifestId,
    getConfigRootPath: getConfigRoot,
    logger
};
