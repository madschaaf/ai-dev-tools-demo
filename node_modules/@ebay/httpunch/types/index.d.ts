/// <reference types="node" />
import {
    ClientRequestArgs,
    IncomingMessage,
    OutgoingMessage,
    Agent as HttpAgent
} from "http";
import { Agent as HttpsAgent } from "https";
import { Readable } from 'stream';

export type RequestBody = Readable | Buffer | string | {[key: string]: any};

export type RequestOptions = ClientRequestArgs & {
    body?: RequestBody;
    socketTimeout?: number;
    responseTimeout?: number;
    connectTimeout?: number;
    pathparams?: { [key: string]: string };
    qs?: string | { [key: string]: string };
    url?: string;
    scheme?: string;
    maxRedirects?: number;
};

export type Response = IncomingMessage & {
    body?: Buffer;
};

export type ContentType = {
    type: string;
    encoding: string;
};

export const enum HttpMethod {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    DELETE = 'DELETE',
    HEAD = 'HEAD',
    OPTIONS = 'OPTIONS',
    TRACE = 'TRACE',
    CONNECT = 'CONNECT',
    PATCH = 'PATCH'
}

export interface Utils {
    debug: (message: string, ...args: any[]) => void;
    endsWith: (haystack: string, needle: string) => boolean;
    prefix: (str: string, pre: string) => string;
    unprefix: (str: string, pre: string) => string;
    suffix: (str: string, suff: string) => string;
    unsuffix: (str: string, suff: string) => string;
    HttpMethod: typeof HttpMethod;
    supportsBody: (method: string) => boolean;
    supportsFollowRedirect: (method: string) => boolean;
    isHttpMethod: (method: string) => boolean;
    isRedirect: (statusCode: number) => boolean;
    normalizeHeaders: (headers: { [key: string]: string }) => { [key: string]: string };
    isJSON: (res: IncomingMessage) => boolean;
    isFormEncoded: (res: IncomingMessage) => boolean;
    normalizeContentType: (headers: { [key: string]: string }) => { [key: string]: string };
    parseContentType: (res: IncomingMessage) => ContentType;
    tryParse: (data: string) => any;
    parseOptions: (options: string | RequestOptions) => RequestOptions;
    sliceArgs: <T>(args: ArrayLike<T>) => Array<T>;
    checkInvalidHeaderChar: (val: string) => boolean;
    read: (res: IncomingMessage, callback: (error: Error | null, data: Buffer) => void) => void;
    pipe: (incoming: Readable, outgoing: NodeJS.WritableStream, options?: { end?: boolean }) => void;
    copyHeaders: (incoming: IncomingMessage, outgoing: OutgoingMessage) => void;
    cleanAgentConfig: (options?: RequestOptions) => Partial<RequestOptions>;
    userAgentString: (override?: { name?: string; version?: string }) => string;
}

export interface AgentOptions {
    maxSockets?: number;
    maxFreeSockets?: number;
    keepAlive?: boolean;
    keepAliveMsecs?: number;
    protocol?: string;
    ciphers?: string;
    key?: string | Buffer;
    cert?: string | Buffer;
    passphrase?: string;
    ca?: string | Buffer | Array<string | Buffer>;
    pfx?: string | Buffer;
    rejectUnauthorized?: boolean;
    secureProtocol?: string;
    checkServerIdentity?: (servername: string, cert: object) => Error | undefined;
}

export interface Agents {
    create: (options: AgentOptions) => HttpAgent | HttpsAgent;
}

export function request(options: RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;
export function get(optionsOrUrl: string | RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;
export function post(optionsOrUrl: string | RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;
export function put(optionsOrUrl: string | RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;
export function head(optionsOrUrl: string | RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;
export function options(optionsOrUrl: string | RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;
export function connect(optionsOrUrl: string | RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;
export function patch(optionsOrUrl: string | RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;
export function del(optionsOrUrl: string | RequestOptions, callback: (err: Error, response: Response) => void): OutgoingMessage;

export const utils: Utils;
export const agents: Agents;
