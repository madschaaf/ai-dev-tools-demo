'use strict';

var { Readable } = require('stream');
var Utils = require('./utils');
var Http = require('http');
var Https = require('https');
var Thing = require('core-util-is');
var Hoek = require('hoek');
var Metrics = require('./metrics');
var FormData = require('form-data');

var protocol = {
    'http:': Http,
    'https:': Https
};

/**
 * Create and potentially begin a request.
 * @param options request options.
 * @param callback optional callback. If a callback is provided, the request is executed and the callback invoked with the response.
 * @returns {ClientRequest}
 * @private
 */
function _request(options, callback) {
    var req;

    options = options || {};

    if (process.env.DEBUG_REQUEST_HOSTNAME === options.hostname) {
        console.log('[DEBUG_REQUEST_HOSTNAME]:', JSON.stringify(options, null, 2));
    }

    Utils.debug('%s %s//%s:%s%s', options.method.toUpperCase(), options.protocol, options.hostname, options.port || (options.protocol === 'https:' ? 443 : 80), options.path);

    let formData;
    options.headers = Utils.normalizeContentType(options.headers);
    if (options.headers && options.headers['content-type'] === 'multipart/form-data') {
        formData = Object.keys(options.body).reduce((memo, name) => {
            const data = options.body[name];
            if (data && typeof data === 'object' && data.value) {
              memo.append(name, data.value, data.options);
            }
            else {
              memo.append(name, options.body[name]);
            }
            return memo;
        }, new FormData());
        
        options.headers = Object.assign({}, options.headers, formData.getHeaders());
    }

    if (options.body instanceof Readable) {
        options.stream = options.body;
        options.body = undefined;
    }

    req = protocol[options.protocol].request(options);
    Metrics.hook(req); 

    req.once('socket', function (socket) {
        socket.setNoDelay(true);
    });

    //Write body
    if (formData) {
        // to sinchronize calling end() to the moment when all the data is flushed into the stream
        // we need to override end to delay its execution.
        const _end = req.end;
        let args = [];
        req.end = function () {
            args = arguments;
        };
        formData.on('end', function () {
            // complete the request stream
            _end.apply(req, args);
            // restore original function
            req.end = _end;
        });
        // initiating the streaming of data
        formData.pipe(req); 
    }
    else if (options.stream) {
        const _end = req.end;
        let args = [];
        req.end = function () {
            args = arguments;
        };

        const readable = options.stream;
        readable.on('readable', () => {
            // Use a loop to make sure we read all currently available data
            while (true) {
                const chunk = readable.read();
                if (chunk === null) {
                    break;
                }
                if (!req.write(chunk)) {
                    readable.pause();
                    req.once('drain', () => {
                        readable.resume();
                    });
                }
            }
        });

        readable.once('end', () => {
            // complete the request stream
            _end.apply(req, args);
            // restore original function
            req.end = _end;
        });
    }
    else if (options.body) {
        Utils.debug('request body (length=%d)', options.headers['content-length']);
        req.write(options.body);
    }

    return wrap(req, options, callback);
}

function wrap(req, options, callback) {
    var connectTimeout;

    var connectTimeoutValue = options.connectTimeout || options.socketTimeout;
    if (Hoek.isInteger(connectTimeoutValue) && connectTimeoutValue > 0) {
        Utils.debug('connect timeout=%d', connectTimeoutValue);
        connectTimeout = setTimeout(onConnectTimeout, connectTimeoutValue);
        req.once('socket', onSocket);
    }

    if (Hoek.isInteger(options.socketTimeout) && options.socketTimeout > 0) {
        setSocketTimeout();
    }

    //Start request if a callback was provided.
    if (callback && Thing.isFunction(callback)) {
        callback = Hoek.once(callback);
        req.once('response', onResponse);
        req.once('error', finish);
        req.on('error', Hoek.ignore);
        if (!options.stream) {
            req.end();
        }
        return req;
    }

    //Add an optional callback parameter to end().
    req.end = wrapEnd();

    //Add pipe function
    req.pipe = handlePipe();

    function finish(error, res) {
        clearOnTimeout();

        if (error) {
            Utils.debug('request error: %s', error.message);
            req.destroy();
        }

        req.removeListener('error', finish);
        req.removeListener('response', onResponse);
        req.removeListener('socket', onSocket);
        req.socket && req.socket.removeListener('connect', clearOnTimeout);

        callback && callback(error, res);
    }

    function onResponse(res) {
        handleRedirect(res, options, function (error, redirect) {
            if (error) {
                finish(error, res);
                return;
            }
            if (redirect) {
                _request(redirect, callback);
                return;
            }

            Utils.read(res, function (error, body) {
                if (error) {
                    finish(error, res);
                    return;
                }

                res.body = body;

                finish(null, res);
            });
        });
    }

    function onConnectTimeout() {
        var error = new Error('connect ETIMEDOUT');
        error.code = 'ETIMEDOUT';

        Utils.debug('connect timeout after %dms.', options.connectTimeout);

        if (!req.socket) {
            req.emit('error', error);
        }
        else {
            req.socket.emit('error', error);
        }
    }

    function onSocket(socket) {
        if (socket._connecting) {
            socket.once('connect', clearOnTimeout);
        }
        else {
            clearOnTimeout();
        }
    }

    function setSocketTimeout() {
        Utils.debug('response timeout=%d', options.socketTimeout);

        req.setTimeout(options.socketTimeout, function timedout() {
            Utils.debug('response timeout after %dms.', options.socketTimeout);
            req.abort();
        });
    }

    function clearOnTimeout() {
        clearTimeout(connectTimeout);
    }

    function handleRedirect(res, options, callback) {
        var redirect, redirectUrl;

        if (Utils.isRedirect(res.statusCode) && Utils.supportsFollowRedirect(options.method)) {
            redirectUrl = res.headers.location;
            options.redirects = options.redirects ? options.redirects + 1 : 0;

            if (redirectUrl && options.redirects++ < options.maxRedirects) {

                redirect = Utils.parseOptions(redirectUrl);
                redirect.method = 'GET';
                redirect.headers = options.headers;

                Object.keys(options).forEach(function (key) {
                    if (!redirect[key]) {
                        redirect[key] = options[key];
                    }
                });

                redirect.headers.host = redirect.hostname + redirect.port ? ':' + redirect.port : '';

                res.destroy();

                callback(null, redirect);

                return;
            }

            Utils.debug('followed maxRedirects (%d)', options.maxRedirects);
        }

        callback();
    }

    function handlePipe() {

        return function pipe(socket, opts) {

            function finishPipe(error, res) {
                clearOnTimeout();

                req.removeListener('error', finishPipe);
                req.removeListener('response', onPipeResponse);
                req.removeListener('socket', onSocket);
                req.socket.removeListener('connect', clearOnTimeout);
                socket.removeListener('error', onSocketError);

                if (error) {
                    Utils.debug('request error: %s', error.message);
                    req.destroy();
                }
            }

            function onPipeResponse(res) {
                handleRedirect(res, options, function (error, redirect) {
                    if (error) {
                        finishPipe(error);
                        return;
                    }
                    if (redirect) {
                        _request(redirect).pipe(socket, opts);
                        return;
                    }

                    res.headers && socket.writeHead && Utils.copyHeaders(res, socket);

                    Utils.pipe(res, socket, opts);
                });
            }

            function onSocketError(error) {
                req.emit('error', error);
                finish(error);
            }

            Utils.debug('request pipe');

            req.once('response', onPipeResponse);
            req.once('error', finishPipe);
            req.on('error', Hoek.ignore);
            socket.once('error', onSocketError);

            if (opts && opts.end === false) {
                return req;
            }

            req.end();
        };
    }

    function wrapEnd() {
        var _end = req.end;

        return function end(cb) {
            if (cb && Thing.isFunction(cb)) {
                callback = Hoek.once(cb);
                req.once('response', onResponse);
                req.once('error', finish);
                req.on('error', Hoek.ignore);
            }
            _end.apply(req);
            req.end = _end;
        };
    }

    return req;
}

module.exports = _request;
