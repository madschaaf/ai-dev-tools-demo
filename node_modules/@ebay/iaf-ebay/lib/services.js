'use strict';

var async = require('async');
var objPath = require('object-path');

var Provider = require('@ebay/service-client-ebay');
var RuntimeError = require('@ebay/errors-ebay/errors').RuntimeError;

var utils = require('./utils');

var tokenCache = {};

function ServiceClient(ctx) {
    this.token = ctx.token;
    this.consumerId = ctx.consumerId;
    this.headers = {};
    this.headers['X-EBAY-SOA-SECURITY-IAFTOKEN'] = ctx.token;
}

ServiceClient.prototype.authenticateToken = function authenticateToken(options, callback) {
    if (typeof options === 'string') {
        options = {
            token: options
        };
    }

    var request = {
        securityToken: {
            $type: '?',
            $issuingAuthority: '?',
            token: options.token
        }
    };

    if (options.targetService) {
        request.serviceProvider = options.targetService;
    }

    invoke({
        operation: 'authenticateToken',
        request: request,
        headers: this.headers
    }, callback);
};

ServiceClient.prototype.getSecurityTokenByRef = function getSecurityTokenByRef(tokenRef, callback) {
    invoke({
        operation: 'getSecurityTokenByRef',
        request: {
            securityTokenRef: {
                reference: tokenRef
            }
        },
        headers: this.headers
    }, callback);
};

ServiceClient.prototype.requestSecurityToken = function requestSecurityToken(options, callback) {
    if (arguments.length === 1) {
        callback = options;
        options = {
            consumerId: this.consumerId
        };
    }

    options.consumerId = options.consumerId || this.consumerId;

    invoke({
        operation: 'requestSecurityToken',
        request: utils.formatTokenRequest(options),
        headers: this.headers,
        clientId: options.clientId
    }, callback);
};

ServiceClient.prototype.logout = function logout(options, callback) {
    if (arguments.length === 1) {
        callback = options;
        options = {
            consumerId: this.consumerId
        };
    }

    options.consumerId = options.consumerId || this.consumerId;

    invoke({
        operation: 'logout',
        request: utils.formatTokenRequest(options),
        headers: this.headers
    }, callback);
};

function getTokenFromCache(consumerId, secret) {
    var key = consumerId + '|' + secret;
    var tokenMeta = tokenCache[key];
    if (tokenMeta && tokenMeta.isExpired()) {
        delete tokenCache[key];
        tokenMeta = null;
    }
    return tokenMeta && tokenMeta.token;
}

module.exports.reset = function reset() {
    tokenCache = {};
};

// Every action starts with login
module.exports.login = function login(consumerId, secret, callback) {

    async.waterfall([

        function getCachedToken(next) {
            var ctx = {
                consumerId: consumerId
            };
            ctx.token = getTokenFromCache(consumerId, secret);
            next(null, ctx);
        },

        function loginIfNeeded(ctx, next) {
            if (ctx.token) {
                return next(null, ctx);
            }

            invoke({
                operation: 'login',
                request: {
                    subject: utils.formatSubject(consumerId),
                    secret: utils.formatSecret(secret)
                }
            }, function (err, token) {
                ctx.token = token;
                next(err, !err ? ctx : undefined);
            });
        },

        function parseTokenIfNeeded(ctx, next) {
            if (ctx.token.isExpired) {
                return next(null, ctx);
            }

            try {
                var tokenMeta = utils.parse(ctx.token);
                // cache it
                tokenCache[consumerId + '|' + secret] = tokenMeta;
                ctx.token = tokenMeta.token;
                next(null, ctx);
            }
            catch (err) {
                next(err);
            }
        },

        function createServiceClient(ctx, next) {
            next(null, new ServiceClient(ctx));
        }

    ], callback);
};

ServiceClient.prototype.authenticateUser = function authenticateUser(options, callback) {
    invoke({
        operation: 'authenticate',
        request: utils.formatAuthenticateRequest(options),
        headers: this.headers,
        clientId: options.clientId
    }, callback);
};

function normalizeAttributes(attributes) {
    var result = {};
    for (var i = 0, len = attributes && attributes.length || 0; i < len; i++) {
        var attr = attributes[i];
        result[attr.attributes.Name] = attr.AttributeValue.$value;
    }
    return result;
}

function invoke(options, callback) {
    const clientId = options.clientId || 'iafservice';

    Provider.context({}).getClient(clientId).request(options).end(function (err, response) {
        if (err) {
            return callback(utils.boom(err));
        }

        response = response.body;

        if (!response) {
            return callback(new RuntimeError({
                message: 'IAF request: Empty response, possible response timeout',
                code: 'ETIMEDOUT'
            }));
        }

        if (response.ack === 'Success') {
            if (response.expirationDate || response.attributes || response.subject) {
                return callback(null, response.securityToken.token, {
                    expirationDate: response.expirationDate ? new Date(response.expirationDate).getTime() : null,
                    domain: objPath.get(response.subject, 'attributes.identityDomain'),
                    accountId: objPath.get(response.subject, 'identifier.attributes.immutableId'),
                    userId: objPath.get(response.subject, 'identifier.value'),
                    attributes: normalizeAttributes(response.attributes)
                });
            }
            else {
                return callback(null, response.securityToken && response.securityToken.token);
            }
        }

        err = new RuntimeError({
            message: 'IAF request: '+ options.operation +' failed',
            type: 'iaf:service',
            code: 'bad-token'
        });
        err.response = response;
        callback(err);
    });

}
