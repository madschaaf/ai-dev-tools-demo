'use strict';

var assert = require('assert');

var objutil = require('objutil');
var Promises = require('bluebird');

var RuntimeError = require('@ebay/service-instruments-ebay/lib/errors').RuntimeError;
var appMeta = Promises.promisifyAll(require('@ebay/appmeta-ebay'));

var iaf = Promises.promisifyAll(require('./iaf'));

var Iaf = module.exports.Iaf = function Iaf(request, options) {
    this.request = request;
    this.options = options || {};
    this.appName = getAppName(request);
};

var proto = Iaf.prototype;

/**
 * @param options can be string token or options:
 * {
 *    token: <token>,
 *    consumerId: <consumer id>,   //optional
 *    secret: <secret>   //optional
 * }
*/
proto.authenticateToken = function authenticateToken(options, callback) {
    var args = [].slice.call(arguments);
    callback = args.pop();
    assert.ok(typeof callback === 'function', 'callback must be provided');
    options = args.shift() || {};

    options = typeof options === 'string' ? {
        token: options
    } : options;

    appMeta.get(this.appName, (err, meta) => {
        if (err) {
            return callback(err);
        }
        options.secret = options.appSecret || options.secret;
        options = objutil.mixin(this.options, normalizeOptions(options), {
            consumerId: meta.getConsumerId(),
            secret: meta.getAppSecret()
        });

        iaf.authenticateToken(options, callback);
    });
};

proto.authenticateRequest = function authenticateRequest(options, callback) {
    var args = [].slice.call(arguments);
    callback = args.pop();
    assert.ok(typeof callback === 'function', 'callback must be provided');
    options = args.shift() || {};

    var authorization = this.request.headers &&
        (this.request.headers.authorization || this.request.headers.Authorization);

    if (/^bearer /i.test(authorization)) {
        this.authenticateToken(objutil.mixin(options, {
            token: authorization.substring('bearer '.length)
        }), callback);
    }
    else {
        callback(new RuntimeError({
            message: 'Missing authorization token',
            statusCode: 403
        }));
    }
};

/**
 * @param options
 * {
 *    consumerId: <consumer id>,   //optional
 *    secret: <secret>   //optional
 * }
*/
proto.getAsacToken = function (options, callback) {
    const args = [].slice.call(arguments);
    callback = args.pop();
    assert.ok(typeof callback === 'function', 'callback must be provided');
    options = args.shift() || {};

    appMeta.getAsync(this.appName).then(meta => {
        return iaf.getAsacTokenAsync(Object.assign({
            consumerId: meta.getConsumerId(),
            secret: meta.getAppSecret()
        }, options, this.options));
    }).nodeify(callback);
};

/**
 * @param options can be string reference or options:
 * {
 *    consumerId: <consumer id>,   //optional
 *    secret: <secret>   //optional
 * }
*/
proto.getAppToken = function getAppToken(options, callback) {
    var args = [].slice.call(arguments);
    callback = args.pop();
    assert.ok(typeof callback === 'function', 'callback must be provided');
    options = args.shift() || {};

    appMeta.getAsync(this.appName).then(function (meta) {

        return iaf.getAppTokenAsync(objutil.mixin(this.options, options, {
            consumerId: meta.getConsumerId(),
            secret: meta.getAppSecret()
        }));

    }.bind(this)).nodeify(callback);

};

/**
 * @param options:
 * {
 *    consumerId: <consumer id>,   // optional
 *    secret: <secret>,   // optional
 *    userId: <user id>,   // optional
 *    accountId: <account id>,   // optional
 *    scope: <scope>,   // optional
 *    type: <type>   // optional, ajax or Hosted
 * }
*/
proto.getUserToken = function getUserToken(options, callback) {
    var args = [].slice.call(arguments);
    callback = args.pop();
    assert.ok(typeof callback === 'function', 'callback must be provided');
    options = args.shift() || {};

    appMeta.getAsync(this.appName).then(function (meta) {

        var ctx = this.request && this.request.ebay;
        var userId = options.userId ||
            ctx && (ctx.getLevel1UserId() || ctx.getJSPersistentUserId());
        var accountId = options.accountId ||
            ctx && (ctx.getAccountId() || ctx.getPersistentAccountId());

        options.secret = options.appSecret || options.secret;

        options = objutil.mixin(this.options, normalizeOptions(options), {
            consumerId: meta.getConsumerId(),
            secret: meta.getAppSecret(),
            userId: userId,
            accountId: accountId
        });

        return iaf.getUserTokenAsync(options);

    }.bind(this)).nodeify(callback);

};

/**
 * @param options can be string reference or options:
 * {
 *    reference: <reference>,
 *    consumerId: <consumer id>,   //optional
 *    secret: <secret>   //optional
 * }
*/
proto.getSecurityTokenByRef = function getSecurityTokenByRef(options, callback) {
    var args = [].slice.call(arguments);
    callback = args.pop();
    assert.ok(typeof callback === 'function', 'callback must be provided');
    options = args.shift() || {};

    options = typeof options === 'string' ? {
        reference: options
    } : options;

    appMeta.getAsync(this.appName).then(function (meta) {

        return iaf.getSecurityTokenByRefAsync(objutil.mixin(this.options,
            normalizeOptions(options), {
            consumerId: meta.getConsumerId(),
            secret: meta.getAppSecret()
        }));

    }.bind(this)).nodeify(callback);

};

/**
 * @param options can be string reference or options:
 * {
 *    reference: <reference>,
 *    subject: <subject>,
 *    requester: <requester>,
 *    consumerId: <consumer id>,   //optional
 *    secret: <secret>   //optional
 * }
*/
proto.logout = function logout(options, callback) {
    var args = [].slice.call(arguments);
    callback = args.pop();
    assert.ok(typeof callback === 'function', 'callback must be provided');
    options = args.shift() || {};

    options = typeof options === 'string' ? {
        reference: options
    } : options;

    appMeta.getAsync(this.appName).then(function (meta) {

        return iaf.logoutAsync(objutil.mixin(this.options,
            normalizeOptions(options), {
            consumerId: meta.getConsumerId(),
            secret: meta.getAppSecret()
        }));

    }.bind(this)).nodeify(callback);
};
/**
 * @param options:
 * {
 *    consumerId: <consumer id>,   // optional
 *    secret: <secret>,   // optional
 *    userId: <user id>,
 *    userSecret: <user's secret>,
 *    domain: <domain>,  // optional
 *    scope: <scope>,   // optional
 *    type: <type>   // optional, ajax or Hosted
 * }
*/
proto.authenticateUser = function authenticateUser(options, callback) {
    var args = [].slice.call(arguments);
    callback = args.pop();
    assert.ok(typeof callback === 'function', 'callback must be provided');
    options = args.shift() || {};

    appMeta.getAsync(this.appName).then(function (meta) {

        options.secret = options.appSecret || options.secret;
        options = objutil.mixin(this.options, normalizeOptions(options), {
            consumerId: meta.getConsumerId(),
            secret: meta.getAppSecret()
        });

        return iaf.authenticateUserAsync(options);

    }.bind(this)).nodeify(callback);

};
function normalizeOptions(options) {
    return Object.keys(options).reduce(function reduce(memo, key) {
        var val = options[key];
        if (val !== null && val !== undefined) {
            memo[key] = val;
        }
        return memo;
    }, {});
}

function getAppName(req) {
    return req.ebay && req.ebay.appContext && req.ebay.appContext.appName;
}
