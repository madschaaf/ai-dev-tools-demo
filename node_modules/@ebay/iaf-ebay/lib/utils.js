'use strict';

var utils = require('./utils');
var RuntimeError = require('@ebay/service-instruments-ebay/lib/errors').RuntimeError;

var FORMATTER_MAPPINGS = {
    SERIALIZER_VERSION: 'v',
    SERIALIZER_ID: 'i',
    EXPIRATION_DATE: 'd',
    IS_REFERENCE: 'r',
    FORMAT_TYPE: 'f',
    ISSUER: 'I',
    IDENTIY_DOMAIN: 'p',
    TOKEN: 't'
};

var PARSERS = {

    d: function parseDateString(value) {
        return new Date(value).getTime();
    },

    r: function parseIsReference(value) {
        return value === '0' ? false : true;
    }
};

function Wrapper(token, meta) {
    this.meta = meta;
    this.token = token;
}

Wrapper.prototype = {
    isExpired: function isExpired() {
        return this.meta[FORMATTER_MAPPINGS.EXPIRATION_DATE] < Date.now();
    },
    isByReference: function isTokenByReference() {
        return this.meta[FORMATTER_MAPPINGS.IS_REFERENCE];
    },
    expiration: function expiration() {
        return this.meta[FORMATTER_MAPPINGS.EXPIRATION_DATE];
    }
};

function parse(tokenString) {
    var kvps = tokenString.split('#');

    var tokenInfo = kvps.reduce(function forEach(memo, kvp) {
        var kvpPair = kvp.split('^');
        var name = kvpPair[0];
        var value = kvpPair[1];

        var parse = PARSERS[name];
        memo[name] = parse ? parse(value) : value;
        return memo;
    }, {});

    return new Wrapper(tokenString, tokenInfo);
}

module.exports.parse = function tryParse(tokenString) {
    try {
        return parse(tokenString);
    }
    catch (err) {
        throw new RuntimeError({
            message: 'Failed to parse raw token data: ' + tokenString,
            error: err,
            type: 'parse'
        });
    }
};

module.exports.select = function select(obj, path) {
    return path.reduce(function reduce(memo, name) {
        return memo ? memo[name] : undefined;
    }, obj);
};

module.exports.boom = function boom(err) {
    var errorId = utils.select(err, ['errorMessage', 'error', '0', 'errorId']) || 1;
    err = new RuntimeError({
        message: 'IAF request',
        error: err,
        type: 'iaf:service'
    });
    if (errorId === '2001') {
        err.code = 'bad-credentials';
    }
    else if (errorId === '11003') {
        err.code = 'caller-unauthorized';
    }
    return err;
};

module.exports.formatSubject = function formatSubject(consumerId) {
    return {
        $identityDomain: 'EBAYAPP',
        identifier: {
            $format: 'USERNAME',
            value: consumerId
        }
    };
};

module.exports.formatSecret = function formatSecret(secret) {
    return {
        $type: 'PASSWORD',
        $encoding: 'DEFAULT',
        value: secret
    };
};

module.exports.formatTokenRequest = function formatTokenRequest(options) {
    options.domain = options.domain || 'EBAYAPP';
    var request = {
        $byReference: !!options.byReference,
        subject: {
            $identityDomain: options.domain,
            identifier: {
                $format: 'USERNAME',
                value: (options.domain === 'EBAYUSER' || options.domain === 'ASAC20') ? options.userId : options.consumerId
            }
        }
    };

    if (options.requester && options.requester.value) {
        request.requester = {
            $identityDomain : options.requester.domain,
            identifier: {
                $format: options.requester.format || 'USERNAME',
                value: options.requester.value
            }
        };
    }

    if (options.accountId) {
        request.subject.identifier.$immutableId = options.accountId;
    }

    if (options.reference) {
        request.securityTokenRef = {
            reference : options.reference
        };
    }

    const expiryInSec = options.expiryInSec && parseInt(options.expiryInSec);
    if (expiryInSec) {
        request.conditions = request.conditions || {};
        request.conditions.$NotOnOrAfter = new Date(Date.now() + (1000 *  expiryInSec)).toISOString();
    }

    if (options.targetService) {
        request.serviceProvider = options.targetService;
    }

    var appId = options.ebayAppId || options.consumerId;
    var certId = options.ebayCertId;
    var devId = options.ebayDevId;

    if ((options.domain === 'EBAYUSER' || options.domain === 'ASAC20') && (appId || certId || devId || options.scope || options.type)) {
        request.attributeAssertion = [];
        if (devId) {
            request.attributeAssertion.push({
                $Name: 'DevId',
                $NameFormat: 'String',
                $FriendlyName: 'DeveloperID',
                AttributeValue: {
                    '$xmlns:xs': 'http://www.w3.org/2001/XMLSchema',
                    '$xsi:type': 'xs:string',
                    $value: devId
                }
            });
        }

        if (appId) {
            request.attributeAssertion.push({
                $Name: 'AppId',
                $NameFormat: 'String',
                $FriendlyName: 'ApplicationID',
                AttributeValue: {
                    '$xmlns:xs': 'http://www.w3.org/2001/XMLSchema',
                    '$xsi:type': 'xs:string',
                    $value: appId
                }
            });
        }
        if (certId) {
            request.attributeAssertion.push({
                $Name: 'Cert',
                $NameFormat: 'String',
                $FriendlyName: 'Certificate',
                AttributeValue: {
                    '$xmlns:xs': 'http://www.w3.org/2001/XMLSchema',
                    '$xsi:type': 'xs:string',
                    $value: certId
                }
            });
        }

        if(options.type){
            request.attributeAssertion.push({
                $Name: 'type',
                $NameFormat: 'String',
                $FriendlyName: 'type',
                AttributeValue: {
                    '$xmlns:xs': 'http://www.w3.org/2001/XMLSchema',
                    '$xsi:type': 'xs:string',
                    $value: options.type
                }
            });
        }

        if(options.attributeRequest) {
            request.attributeRequest = options.attributeRequest.map(function (attributeRequest) {
                return {
                    $Name: attributeRequest.name,
                    $NameFormat: attributeRequest.nameFormat || 'String',
                    $FriendlyName: attributeRequest.friendlyName || '',
                    AttributeValue: {
                        '$xmlns:xs': attributeRequest.xmlnsXs || 'http://www.w3.org/2001/XMLSchema',
                        '$xsi:type': attributeRequest.xsiType || 'xs:string',
                        $value: attributeRequest.value
                    }
                };
            });
        }
    }

    if (options.scope){
        request.attributeAssertion = request.attributeAssertion || [];

        request.attributeAssertion.push({
            $Name: 'scope',
            $NameFormat: 'String',
            $FriendlyName: 'scope',
            AttributeValue: {
                '$xmlns:xs': 'http://www.w3.org/2001/XMLSchema',
                '$xsi:type': 'xs:string',
                $value: options.scope
            }
        });
        request.attributeAssertion.push({
            $Name: 'scopePolicy',
            $NameFormat: 'String',
            $FriendlyName: 'scopePolicy',
            AttributeValue: {
                '$xmlns:xs': 'http://www.w3.org/2001/XMLSchema',
                '$xsi:type': 'xs:string',
                $value: 'FirstParty'
            }
        });
    }

    return request;
};
/** To format request for authentication **/
module.exports.formatAuthenticateRequest = function formatAuthenticateRequest(options) {
    options.domain = options.domain || 'EBAYAPP';
    var request = {
        $byReference: !!options.byReference,
        subject: {
            $identityDomain: options.domain,
            identifier: {
                $format: 'USERNAME',
                value: options.userId
            }
        },
        secret : {
          $type: 'PASSWORD',
          $encoding: 'DEFAULT',
          value: options.userSecret
        }
    };
    if (options.requestSecurityToken){
        request.requestSecurityTokenRequest = {
          $byReference: !!options.byReference,
          subject: {
              $identityDomain: options.domain,
              identifier: {
                  $format: 'USERNAME',
                  value: options.userId
              }
          }
        };

    }
    return request;
};
