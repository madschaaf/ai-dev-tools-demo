'use strict';

const Httpunch = require('@ebay/httpunch');
const IafEbay = require('../..');
const Iaf = IafEbay.iaf;
const debug = require('debug')('security-ebay:token');
const parse = IafEbay.parse;

const consumerId = 'ebay-marketplace-consumerid:c722dc2c-5ea4-472d-b8c5-b1713f46d4e1';
const secret = '29109fe8-ac5a-48f8-af69-c93c47b8da0b';

module.exports.getAppToken = function getAppToken(callback) {
    Iaf.getAppToken({
            consumerId: consumerId,
            secret: secret
        }, callback);
};

module.exports.getPublicUserToken = function getPublicUserToken(options, callback) {
    const args = [].slice.call(arguments);
    callback = args.pop();
    options = args.pop() || {};

    Iaf.getUserToken({
        consumerId: consumerId,
        secret: secret,
        userId: 'us2014.q',
        accountId: 1264442622,
        scope: options.scope || 'https://api.ebay.com/oauth/scope/@public',
        type: options.type || 'ajax',
        targetService: 'ScopedToken'
    }, callback);
};

module.exports.getPublicUserTokenRef = function getPublicUserTokenRef(callback) {
    Iaf.getUserToken({
        byReference: true,
        consumerId: consumerId,
        secret: secret,
        userId: 'us2014.q',
        accountId: 1264442622,
        scope: 'https://api.ebay.com/oauth/scope/@public',
        type: 'ajax',
        targetService: 'ScopedToken'
    }, callback);
};

function loadToken(tokenValue) {
    const meta = parse(tokenValue);
    if (meta.isByReference()) {
        return loadTokenByRef(meta);
    }
    return Promise.resolve(meta.token);
}

function loadTokenByRef(meta) {
    debug('loading token by ref');
    return new Promise((resolve, reject) => {
        Iaf.getSecurityTokenByRef({
            consumerId,
            secret,
            reference: meta.token
        }, (err, token) => {
            if (err) {
                return reject(err);
            }
            resolve(token);
        });
    });
}

/**
 * @callback returns token
*/
function validateTokenAndGetAttributes(token) {
    return authenticateToken({
        consumerId,
        secret,
        targetService: 'ScopedToken',
        token: token
    })
    .catch(function (err) {
        if (err.code === 'bad-token') {
            return authenticateToken({
                consumerId,
                secret,
                targetService: '',
                token: token
            });
        }
        throw err;
    });
}

function authenticateToken(options) {
    return new Promise((resolve, reject) => {
        Iaf.authenticateToken(options, (err, token, attributes) => {
            if (err) {
                return reject(err);
            }
            resolve({
                token: token,
                attributes: attributes
            });
        });
    });
}

function openToken(tokenValue) {
    return loadToken(tokenValue)
    .then(validateTokenAndGetAttributes);
}

module.exports.openToken = openToken;
