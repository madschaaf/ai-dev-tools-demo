'use strict';

const Assert = require('assert');
const appContext = require('@ebay/app-context-ebay');
const mainLogger = require('@ebay/logging-inc').logger('spellcaster-ebay/config');
const client = require('./client');

const CATEGORY_GROUP = 'com.ebay.platform.security.nextgen';
const CATEGORY_ID = `${CATEGORY_GROUP}.SpellCaster`;
const DEFAULTS = {
    patronusEnabled: true,
    fideliusEnabled: true,
    protegoEnabled: true,
    patronusFallbackEnabled: true,
    fideliusFallbackEnabled: true,
    protegoFallbackEnabled: true
};

class ConfigHolder {
    constructor(resolve) {
        this.resolve = resolve;
    }

    isPatronusEnabled() {
        return this.resolve('patronusEnabled');
    }

    isFideliusEnabled() {
        return this.resolve('fideliusEnabled');
    }

    isProtegoEnabled() {
        return this.resolve('protegoEnabled');
    }

    isPatronusFallbackEnabled() {
        return this.resolve('patronusFallbackEnabled');
    }

    isFideliusFallbackEnabled() {
        return this.resolve('fideliusFallbackEnabled');
    }

    isProtegoFallbackEnabled() {
        return this.resolve('protegoFallbackEnabled');
    }
}

function defineConfigBean(attributes) {
    const beanDef = {
        'configbean': true,
        'id': CATEGORY_ID,
        'alias': CATEGORY_ID,
        'group': CATEGORY_GROUP,
        'desc': 'SpellCaster Config Bean',
        'attributes': Object.keys(DEFAULTS).map(name => ({
            'name': name,
            'value': (attributes && attributes[name] !== undefined) ? attributes[name] : DEFAULTS[name],
            'type': 'boolean',
            'readable': 'true',
            'writable': 'true'
        }))
    };
    return beanDef;
}

let configHolder;

async function fetchRemoteConfig(opt) {
    const appName = appContext.appName;
    // eslint-disable-next-line no-param-reassign
    const options = Object.assign({
        maxRetries: 5,
        refreshTimeout: 1000,
        pauseTimeout: 60000,
        fetch() {
            return client.getConfig(appName);
        },
        logger: mainLogger,
        context: {}
    }, opt);

    const fetch = options.fetch;
    const context = options.context;
    const publish = options.publish;
    context.remoteConfigFetchRetry = context.remoteConfigFetchRetry || 0;
    // eslint-disable-next-line no-shadow
    const logger = options.logger;
    Assert.ok(publish, `Publish must be provided`);
    const remoteConfig = await fetch().catch(err => err);

    if (remoteConfig instanceof Error) {
        let refreshTimeout = options.refreshTimeout;
        const err = remoteConfig;
        logger.error(`Failed to load spellcaster config for app: ${appName}`, err);
        if (context.remoteConfigFetchRetry++ > options.maxRetries) {
            logger.error(`Failed to re-fetch spellcaster config for app: ${
                appName}, max number of attempts (${options.maxRetries}) has been reached, going into pause for ${
                options.pauseTimeout} ms`, err);
            refreshTimeout = options.pauseTimeout;
            context.remoteConfigFetchRetry = 0;
        }

        // spellcaster should only load config once and refresh only after restart or new deployment
        Assert.ok(!context.timer, `Unexpected situation, timer has been already set`);
        context.timer = setTimeout(() => {
            // make sure if we do not pull context into refresh
            while (process.domain) {
                process.domain.exit();
            }
            context.timer = undefined;
            fetchRemoteConfig(options);
        }, refreshTimeout).unref();
    }
    else {
        publish(remoteConfig);
    }

    return options;
}

function createPublisher(bean) {
    return remoteConfig => {
        remoteConfig && Object.keys(DEFAULTS).forEach(name => {
            const value = remoteConfig[name];
            if (value !== undefined) {
                bean.setPersist(name, value);
            }
        });
    };
}

function createBeanManager() {
    return require('@ebay/config-bean-ebay');
}

const internals = {
    reset() {
        configHolder = undefined;
    },
    fetchRemoteConfig,
    createPublisher,
    defineConfigBean,
    createBeanManager,
    CATEGORY_ID
};

module.exports = {
    getConfig() {
        if (configHolder) {
            return configHolder;
        }

        const BeanManager = internals.createBeanManager();
        const bean = BeanManager.getBeanById(CATEGORY_ID) ||
            BeanManager.define(internals.defineConfigBean(DEFAULTS));

        configHolder = new ConfigHolder(name => bean.get(name));
        // trigger remote config fetch
        const publish = internals.createPublisher(bean);
        const session = internals.fetchRemoteConfig({ publish });
        configHolder.session = session;
        return configHolder;
    },

    [Symbol.for('internals')]: internals
};
