'use strict';

var secretKeyCache = {};
var secretKeyCacheSize = 0;

const TEN_MINUTES = 10 * 60 * 1000;
const CACHE_UPDATE_PERIOD = 24 * 6 * TEN_MINUTES;
const DEFAULT_SECRET_KEY_CACHE_CAPACITY = 1000;

function getIdentityCache(identity) {
    return (secretKeyCache[identity] = secretKeyCache[identity] || {});
}

function getChannelCache(identity, channelName) {
    var identityCache = getIdentityCache(identity);
    return (identityCache[channelName] = identityCache[channelName] || Object.defineProperties({}, {
        '__latestKey': {
            value: null,
            writable: true,
            enumerable: false
        },
        '__lastRefreshTime': {
            value: null,
            writable: true,
            enumerable: false
        },
        '__fetchInProgress': {
            value: {},
            writable: true,
            enumerable: false
        }
    }));
}

/**
 * Get the keyholder from the cache if exists
 * @param {string} identity
 * @param {string} channelName
 * @param {number} channelVersion
 * @param {boolean} staleIsOkay
 * @return {object} returns undefined if no key matches the args.
 */
function getKey(identity, channelName, channelVersion, staleIsOkay) {
    var channelCache = getChannelCache(identity, channelName);
    var latestKey = channelVersion === undefined || channelVersion === -1 || channelVersion === '-1';

    if (staleIsOkay || !isStale(identity, channelName, channelVersion)) {
        return latestKey ? channelCache.__latestKey : channelCache[channelVersion];
    }
}

function isStale(identity, channelName, channelVersion) {
    var channelCache = getChannelCache(identity, channelName);
    var latestKey = channelVersion === undefined || channelVersion === -1 || channelVersion === '-1';

    if (latestKey) {
        return channelCache.__lastRefreshTime && Date.now() - channelCache.__lastRefreshTime > CACHE_UPDATE_PERIOD;
    }

    return false;
}


/**
 * Puts the key into the cache
 * @param {string} identity
 * @param {string} channelName
 * @param {number} channelVersion
 * @param {object} keyHolder - new value
 */
function putKey(identity, channelName, channelVersion, keyHolder) {
    if (keyHolder.channelVersion === undefined) {
        return;
    }

    var channelCache = getChannelCache(identity, channelName);

    if (!channelCache[keyHolder.channelVersion]) {
        secretKeyCacheSize = secretKeyCacheSize + 1 > DEFAULT_SECRET_KEY_CACHE_CAPACITY ? secretKeyCacheSize : secretKeyCacheSize + 1;
    }

    if (secretKeyCacheSize === DEFAULT_SECRET_KEY_CACHE_CAPACITY) {
        removeRandomSecretKey();
    }

    var clone = channelCache[keyHolder.channelVersion] = Object.assign({}, keyHolder);

    if (channelVersion === -1 || channelVersion === '-1') {
        channelCache.__lastRefreshTime = Date.now();
        channelCache.__latestKey = clone;
    }
}

function removeRandomSecretKey() {
    var retry = 0;
    var identityKey, channelKey;
    var identities, channels, versions, identity, channel, version;

    do {
        // obtain a random identity
        identities = Object.keys(secretKeyCache);
        if (!identities || !identities.length) { return; }
        identityKey = module.exports.__getRandomElement(identities);
        identity = secretKeyCache[identityKey];

        // obtain a random channel
        channels = identity && Object.keys(identity);
        if (!channels || !channels.length) { return; }
        channelKey = module.exports.__getRandomElement(channels);
        channel = identity[channelKey];
        
        // obtain a random version
        versions = channel && Object.keys(channel);
        if (!versions || !versions.length) { return; }
        version = channel[module.exports.__getRandomElement(versions)];
        
    /* If choosen key is latest try to delete something other key */
    } while (version === channel.__latestKey && ++retry < 10); 

    removeVersion(channel, version.channelVersion);
    
    // If that was the last item cached in a given channel delete channel
    if (!Object.keys(channel).length) {
        delete identity[channelKey];
    }

    // If that was the last channel cached by a given identity delete identity
    if (!Object.keys(identity).length) {
        delete secretKeyCache[identityKey];
    }
}

function getRandomElement(keys) {
    var min = 0;
    var max = keys && keys.length - 1;
    if (max !== undefined) {
        return keys[Math.floor(Math.random() * (max - min + 1)) + min];
    }
}

/**
 * Removes key from cache
 *
 * @param {string} identity
 * @param {string} channelName
 * @param {number} channelVersion
 */
function removeKey(identity, channelName, channelVersion) {
    removeVersion(getChannelCache(identity, channelName), channelVersion);
}

function removeVersion(channelCache, channelVersion) {
    if (!channelCache) {
        return;
    }

    var version = channelCache[channelVersion];

    if (channelVersion === undefined || channelVersion === -1 || channelVersion === '-1' || version === channelCache.__latestKey) {
        if (channelCache.__latestKey) {
            version = version || channelCache[channelCache.__latestKey.channelVersion];
            channelCache.__lastRefreshTime = null;
            channelCache.__latestKey = null;
        }
    } 

    if (version) {
        secretKeyCacheSize--;
        delete channelCache[channelVersion];   
    }    
}

function expire(identity, channelName, channelVersion) {
    var channelCache = getChannelCache(identity, channelName);
    var latestKey = channelVersion === undefined || channelVersion === -1 || channelVersion === '-1';

    if (latestKey && channelCache.__lastRefreshTime) {
        channelVersion = channelCache.__latestKey.channelVersion;
        channelCache.__lastRefreshTime = Date.now() - (CACHE_UPDATE_PERIOD * 2);
    }

    if (channelCache[channelVersion].expiration) {
        channelCache[channelVersion].expiration = channelCache.__lastRefreshTime;
    }
}


function extendExpiry(identity, channelName, channelVersion) {
    var channelCache = getChannelCache(identity, channelName);
    var latestKey = channelVersion === undefined || channelVersion === -1 || channelVersion === '-1';

    if (latestKey && channelCache.__lastRefreshTime) {
        channelVersion = channelCache.__latestKey.channelVersion;
        channelCache.__lastRefreshTime = Date.now() - CACHE_UPDATE_PERIOD + TEN_MINUTES; //extend expiration by 10 minutes
    }

    if (channelCache[channelVersion].expiration && channelCache[channelVersion].expiration < Date.now()) {
        channelCache[channelVersion].expiration = Date.now() + TEN_MINUTES;
    }
}

function getAndsetFetchInProgress(identity, channelName, channelVersion, callback) {
    var channelCache = getChannelCache(identity, channelName);
    var callbacks = channelCache.__fetchInProgress[channelVersion] = channelCache.__fetchInProgress[channelVersion] || [];
    callbacks.push(callback);
    return callbacks.length > 1;
}

function clearFetchInProgress(identity, channelName, channelVersion) {
    var channelCache = getChannelCache(identity, channelName);

    if (!channelCache.__fetchInProgress) {
        return [];
    }

    var callbacks = channelCache.__fetchInProgress[channelVersion] || [];
    delete channelCache.__fetchInProgress[channelVersion];
    return callbacks;
}

function clean() {
    secretKeyCache = {};
    secretKeyCacheSize = 0;
}

module.exports = {
    clean: clean,
    expire: expire,
    getKey: getKey,
    putKey: putKey,
    isStale: isStale,
    removeKey: removeKey,
    extendExpiry: extendExpiry,
    getChannelCache: getChannelCache,
    getIdentityCache: getIdentityCache,
    clearFetchInProgress: clearFetchInProgress,
    removeRandomSecretKey: removeRandomSecretKey,
    getAndsetFetchInProgress: getAndsetFetchInProgress,

    __getRandomElement: getRandomElement // for testing
};