'use strict';

var stringify = require('json-stringify-safe');

var objutil = require('objutil'),
    serviceClient = require('@ebay/service-client-ebay');

const fidelius = require('@ebay/fidelius-client-ebay');
const patronus = require('@ebay/patronus-client-ebay');
const appContext = require('@ebay/app-context-ebay');
const logger = require('@ebay/logging-inc').logger('@ebay/esams-consumer-ebay');

var PKCS8_ENCODED_PRIVATE_KEY_HEADER = '-----BEGIN PRIVATE KEY-----\n';
var PKCS8_ENCODED_PRIVATE_KEY_FOOTER = '\n-----END PRIVATE KEY-----';

function getSecretKey(ctx, channelName, channelVersion, headers, options, callback) {
    options = options || {};

    options = objutil.deepMixin(options, {
        headers: headers,
        service: 'EsamsService',
        operation: 'getSecretKey'
    });

    const appName = appContext.appName;
    patronus.isAppWhiteListed(appName, 'patronusEnabled', (patronusErr, isWhitelisted) => {

        logger.info('Patronus whitelist %s',isWhitelisted);
        if(isWhitelisted) {
            patronus.getEsamsSymmetricKey(channelName, channelVersion, (err, response) => {
                //Incase of error, fallback to eSAMS
                if(err) {
                    invokeSecretKey(ctx, channelName, channelVersion, options, callback);
                } else {
                    let result = {};

                    if (!response.material) {
                        return callback(new Error(`secret key is missing in response: ${stringify(response)}`));
                    }

                    result.encodedSecretKey = response.material;
                    result.algorithm = response.algorithm;
                    result.expiration = response.expiry && new Date(response.expiry).getTime();
                    
                    response.attributes = response.metadata || {};
                    result.channelVersion = response.version;
                    callback(null, result);
                }
            });
        } else {
            //If App is not in whitelist, use eSAMS
            invokeSecretKey(ctx, channelName, channelVersion, options, callback);
        }
    });
}

function invokeSecretKey(ctx, channelName, channelVersion, options, callback) {

    ctx = ctx || {};
    var client = serviceClient.context(ctx).getClient('esamsConsumerSvc');
    
    client.post({
            body: {
                channelName: channelName,
                channelVersion: channelVersion + ''
            }
        })
        .options(options)
        .end(function handleResponse(err, response) {
            if (err || !response) {
                return callback(err, null);
            }

            var result = {};
            response = response.body;

            if (!response || !response.secretKey) {
                return callback(new Error(`secret key is missing in response: ${stringify(response)}`));
            }

            result.encodedSecretKey = response.secretKey.encodedSecretKey;
            result.algorithm = response.secretKey.algorithm;
            result.expiration = response.secretKey.keyExpiryDate && new Date(response.secretKey.keyExpiryDate).getTime();
            
            response.attributes = response.attributes || {};
            result.verifyPeriod = response.attributes.verifyPeriod;
            result.rotationPeriod = response.attributes.rotationPeriod;
            result.channelVersion = response.attributes.channelVersion;
            
            return callback(null, result);
        });
}

function getNonKey(ctx, channelName, channelVersion, headers, options, callback) {
    options = options || {};

    options = objutil.deepMixin(options, {
        headers: headers,
        service: 'EsamsService',
        operation: 'getNonKey'
    });

    const appName = appContext.appName;
    fidelius.isAppWhiteListed(appName, (err, isWhiteListed) => {        
        logger.info(`Fidelius whitelist=${isWhiteListed}`);
        if(isWhiteListed) {
            let fideliusHeaders = {'X-ESAMS-CHANNEL-NAME': channelName};
            let channelNamePath = channelName.replace(/\./gi, '/');
            fidelius.getSecret(`${appName}/${channelNamePath}`, fideliusHeaders, (err, secret) => {
                //Incase of error, fallback to eSAMS
                if(err) {
                    invokeNonKey(ctx, channelName, channelVersion, options, callback);
                } else {
                    let response = {};
                    response.value = secret;
                    response.channelVersion = -1; //Default to -1 as fidelius returns latest key
                    callback(null, response);
                }
            });
        } else {
            //If App is not in whitelist, use eSAMS
            invokeNonKey(ctx, channelName, channelVersion, options, callback);
        }
    });
    
}

function invokeNonKey(ctx, channelName, channelVersion, options, callback) {
    ctx = ctx || {};
    var client = serviceClient.context(ctx).getClient('esamsConsumerSvc');
    
    client.post({
	        body: {
                channelName: channelName,
                channelVersion: channelVersion + ''
            }
        })
        .options(options)
        .end(function handleResponse(err, response) {
            if (err || !response) {
                return callback(err, null);
            }

            var result = {};
            response = response.body;

            if (!response || !response.value) {
                return callback(new Error('non key is missing in response: ' + stringify(response)));
            }

            result.value = response.value;
            response.attributes = response.attributes || {};
            result.channelVersion = response.attributes.channelVersion;

            return callback(null, result);
        });
}

function getKeyPair(ctx, channelName, channelVersion, headers, options, callback) {
    options = options || {};

    options = objutil.deepMixin(options, {
        headers: headers,
        service: 'EsamsService',
        operation: 'getKeyPair'
    });
    
    ctx = ctx || {};
    var client = serviceClient.context(ctx).getClient('esamsConsumerSvc');
    
    client.post({
	        body: {
                channelName: channelName,
                channelVersion: channelVersion + ''
            }
        })
        .options(options)
        .end(function handleResponse(err, response) {
            if (err || !response) {
                return callback(err, null);
            }

            var result = {};
            response = response.body;

            if (!response || !response.privateKey) {
                return callback(new Error('private key is missing in response: ' + stringify(response)));
            }

            result.privateKey = PKCS8_ENCODED_PRIVATE_KEY_HEADER + response.privateKey.encodededPrivateKey + PKCS8_ENCODED_PRIVATE_KEY_FOOTER;
            result.privateKeyAlgorithm = response.privateKey.algorithm;

            if (!response || !response.certificateList || !response.certificateList.length) {
                return callback(new Error('certificate list is missing in response: ' + stringify(response)));
            }
            
            result.publicKey = response.certificateList[0].encodedCertifcate;
            result.publicKeyAlgorithm = response.certificateList[0].algorithm;

            response.attributes = response.attributes || {};
            result.verifyPeriod = response.attributes.verifyPeriod;
            result.rotationPeriod = response.attributes.rotationPeriod;
            result.channelVersion = response.attributes.channelVersion;

            return callback(null, result);
        });
}

function getCertificate(ctx, channelName, channelVersion, headers, options, callback) {
    options = options || {};

    options = objutil.deepMixin(options, {
        headers: headers,
        service: 'EsamsService',
        operation: 'getCertificate'
    });
    ctx = ctx || {};
    var client = serviceClient.context(ctx).getClient('esamsConsumerSvc');
    
    client.post({
	        body: {
                channelName: channelName,
                channelVersion: channelVersion + ''
            }
        })
        .options(options)
        .end(function handleResponse(err, response) {
            if (err || !response) {
                return callback(err, null);
            }

            var result = {};
            response = response.body;
            
            if (!response || !response.certificate || !response.certificate.encodedCertifcate) {
                return callback(new Error('certificate is missing in response: ' + stringify(response)));
            }

            result.encodedCertifcate =  response.certificate.encodedCertifcate;
            result.algorithm = response.certificate.algorithm;

            response.attributes = response.attributes || {};
            result.verifyPeriod = response.attributes.verifyPeriod;
            result.rotationPeriod = response.attributes.rotationPeriod;
            result.channelVersion = response.attributes.channelVersion;

            return callback(null, result);
        });
}

module.exports = {
    getNonKey: getNonKey,
    getKeyPair: getKeyPair,
    getSecretKey: getSecretKey,
    getCertificate: getCertificate
};