'use strict';

const esamsConsumer = require('./legacy-esams-consumer');
const { NameService } = require('./name-service');
const { NameServiceConfig } = require('./config');

module.exports = {
    NameService,
    getNameService() {
        this.nameService = this.nameService || new NameService();
        return this.nameService;
    },
    ...esamsConsumer // propagate legacy interface
};

function promiseToCallback(promise, callback) {
    return promise
        .then(data => callback(null, data))
        .catch(err => callback(err));
}

function keyPairToEsams(holder) {
    return {
        privateKey:holder.privateKey.encodedPrivateKey,
        privateKeyAlgorithm: holder.privateKey.algorithm,
        publicKeyAlgorithm: 'X509',
        publicKey: holder.certificates[0] && holder.certificates[0].toString()
            .replace(/-----BEGIN CERTIFICATE-----|-----END CERTIFICATE-----/g, '').replace(/\n/g, ''),
        verifyPeriod: holder.verifyPeriod,
        rotationPeriod: holder.rotationPeriod,
        channelVersion: holder.channelVersion || holder.version
    };
}

function secretKeyToEsams(holder) {
    return {
        encodedSecretKey: holder.encodedSecretKey,
        algorithm: holder.algorithm,
        expiration: holder.keyExpiryDate,
        verifyPeriod: String(holder.verifyPeriod),
        rotationPeriod: String(holder.rotationPeriod),
        channelVersion: holder.version
    };
}

function certificateToEsams(holder) {
    return {
        encodedCertifcate: holder.certificate.toString()
            .replace(/-----BEGIN CERTIFICATE-----|-----END CERTIFICATE-----/g, '').replace(/\n/g, ''),
        algorithm: 'X509',
        verifyPeriod: holder.verifyPeriod,
        rotationPeriod: holder.rotationPeriod,
        channelVersion: holder.channelVersion || holder.version
    };
}

/**
 * This class provides interface between new and legacy mode
 * with responses formatted per legacy mode for backwards compatibility.
 * 
 * All new customer must use new API: require('@ebay/esams-consumer-ebay').getNameService()
 */
class ProxyNameService {
    constructor(identityFile, options) {
        this.esams = esamsConsumer.getEsamsConsumer(identityFile, options);
        this._identityFile = this.esams._identityFile;
        this.options = options;
        this.ns = module.exports.getNameService();
    }

    context(ctx) {
        const wrapper = Object.create(this);
        wrapper.ctx = ctx;
        return wrapper;
    }

    callMethod(method, args) {
        const channelName = args.shift();
        const callback = args.pop();
        const channelVersion = args.shift();

        if (NameServiceConfig.isLegacyEsamsRequested()) {
            return this.esams[method](channelName, channelVersion, callback);
        }
        return promiseToCallback((async () => {
            const ret = await this.ns[method](channelName, channelVersion);
            if (method === 'getNonKey') {
                return {
                    value: ret.nonKey,
                    channelVersion: String(ret.version)
                };
            }
            else if (method === 'getKeyPair') {
                return keyPairToEsams(ret);
            }
            else if (method === 'getCertificate') {
                return certificateToEsams(ret);
            }
            else if (method === 'getSecretKey') {
                return secretKeyToEsams(ret);
            }
            return ret;
        })(), callback);
    }

    removeFromCache(key) {
        this.esams.removeFromCache(key);
        this.ns.removeFromCache(key);
    }
    
    getSecretKey(...args) {
        return this.callMethod('getSecretKey', args);
    }
    
    getKeyPair(...args) {
        return this.callMethod('getKeyPair', args);
    }
    
    getCertificate(...args) {
        return this.callMethod('getCertificate', args);
    }
    
    getNonKey(...args) {
        return this.callMethod('getNonKey', args);
    }
}

let proxy;
// provide a switch between new and legacy esams consumer based on config
// this should be check every time client is used
// to accomplish that the switch should happen at the time of the call
// plus callback needs to be mapped to promises when legacy is active
module.exports.getEsamsConsumer = (identityFile, options) => {
    proxy = proxy || {};
    const key = identityFile || 'default';
    proxy[key] = proxy[key] || new ProxyNameService(identityFile, options);
    return proxy[key];
};

module.exports.__reset = () => {
    esamsConsumer.__reset();
    proxy = {};
    module.exports.nameService = undefined;
};
