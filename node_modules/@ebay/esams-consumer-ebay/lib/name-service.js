'use strict';

const Assert = require('assert');
const { X509Certificate } = require('crypto');
const ono = require('@jsdevtools/ono');
const LRU = require('lru-cache');

const env = require('@ebay/environment-ebay');
const logger = require('@ebay/logging-inc').logger('esmas-consumer-ebay/name-service');
const { EsamsClient } = require('./esams-client');
const { ProtegoClient } = require('@ebay/protego-client-ebay');
const { PatronusClient } = require('@ebay/patronus-client-ebay');
const { getConfig } = require('@ebay/spellcaster-ebay');
const AppContext = require('@ebay/app-context-ebay');
const crypto = require('crypto');

const fidelius = require('@ebay/fidelius-client-ebay');
const protego = new ProtegoClient();
const esams = new EsamsClient();
const patronus = new PatronusClient();

const { NameServiceConfig } = require('./config');

const CONST = {
    VERSION_LAST_ENABLED: -1,
    VERSION_FIRST_ENABLED: 0,
    WEEK: (7 * 24 * 60 * 60 * 1000)
};

const Enum = require('@ebay/common-types-ebay/enum');
const { get } = require('http');
const EKRRotationEnum = Enum.define({
    HOURLY: 1,
    DAILY: 2,
    WEEKLY: 3,
    MONTHLY: 4,
    YEARLY: 5,
    FIVE_YEARS: 6
});

const EKRVerifyEnum = Enum.define({
    HOUR: 1,
    DAY: 2,
    WEEK: 3,
    MONTH: 4,
    YEAR: 5,
    FIVE_YEARS: 6
});

const qateLookup = {
    [EKRRotationEnum.HOURLY.value]: 59999,  // 1 MINUTE IN MS PRIME
    [EKRRotationEnum.DAILY.value]: 119993,  // 2 MINUTE IN MS PRIME
    [EKRRotationEnum.WEEKLY.value]: 179999,  // 3 MINUTE IN MS PRIME
    [EKRRotationEnum.MONTHLY.value]: 239999,  // 4 MINUTE IN MS PRIME
    [EKRRotationEnum.YEARLY.value]: 299993,  // 5 MINUTE IN MS PRIME
    [EKRRotationEnum.FIVE_YEARS.value]: 599999  // 10 MINUTE IN MS PRIME
};

const prodLookup = {
    [EKRRotationEnum.HOURLY.value]: 1000 * 60 * 60, // HOUR IN MS NOT PRIME!
    [EKRRotationEnum.DAILY.value]: 1000 * 60 * 60 * 24, // DAY IN MS NOT PRIME!
    [EKRRotationEnum.WEEKLY.value]: 1000 * 60 * 60 * 24 * 7, // WEEK IN MS NOT PRIME!
    [EKRRotationEnum.MONTHLY.value]: 1000 * 60 * 60 * 24 * 7 * 30, // MONTH IN MS NOT PRIME!
    [EKRRotationEnum.YEARLY.value]: 1000 * 60 * 60 * 24 * 365, // YEAR IN MS NOT PRIME!
    [EKRRotationEnum.FIVE_YEARS.value]: 1000 * 60 * 60 * 24 * 365 * 5 // 5 YEAR IN MS NOT PRIME!
};

const UUID_REGEX = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i;
function isUuid(channelName) {
    return UUID_REGEX.test(channelName);
}

class Holder {
    constructor(channelName, version, label) {
        Assert.ok(channelName);
        Assert.ok(version !== undefined);

        this.channelName = channelName;
        this.version = version;
        this.label = label;
    }

    getChannelName() {
        return this.channelName;
    }

    getVersion() {
        return this.version;
    }

    getLabel() {
        return this.label;
    }
}

class EKRHolder extends Holder {
    constructor(channelName, version, label) {
        super(channelName, version, label);

        this.rotationPeriod = 0;
        this.verifyPeriod = 0;
    }

    setKeyExpiryDate(date) {
        this.keyExpiryDate = date;
    }

    getKeyExpiryDate() {
        return this.keyExpiryDate;
    }

    /**
	 * Calculates "secret id" or lookup value/version used to resolve specific key.
	 * This method is used by envelopes in actual use cases.
	 * 
     * @param now, optional, default is Date.now
	 * @param rotationOrVerifyEnumValue
	 * @return Number
	 */
    static calculateChannelVersion(...args) {
        const rotationOrVerifyEnumValue = args.pop();
        const now = args.shift() || Date.now();

        const rotationPeriod = EKRHolder.getPrimeInMs(rotationOrVerifyEnumValue);
        const version = (parseInt((now / rotationPeriod)) * rotationPeriod);
        return version;
    }

    /**
	 * Whether channel specified (indirectly) by holder is used in automatic key rotation
	 * 
	 * @return
	 */
    isEKR() {
        const rPeriod = this.getRotationPeriod();
        return rPeriod !== undefined && rPeriod > 0;
    }

    /**
	 * Using enum from EKRRotationEnum/EKRVerifyEnum determines actual # in ms for period
     * 
	 * 
	 * @param enumValue: 0, 1, 2, 3, 4, 5
	 * @return
	 */
    static getPrimeInMs(enumValueIndex) {
        const ret = env.isProd() ? prodLookup[enumValueIndex] : qateLookup[enumValueIndex];
        if (ret === undefined) {
            throw new Error(`enumValueIndex '${enumValueIndex}' is out of bounds ${Object.keys(prodLookup)}`);
        }
        Assert.ok(ret, 'enumValueIndex is out of bounds');
        return ret;
    }

    /**
	 * Calculates whether "secret id" or lookup value/version used to resolve specific key
	 * is current or not. Possible states are current, valid, expired or fromFuture.
	 * 
	 * This method is for unit tests.
	 * 
	 * @param now is optional, Date.now()
	 * @return
	 */
    isCurrent(now = Date.now()) {
        const rotationPeriod = EKRHolder.getPrimeInMs(this.rotationPeriod);
        const version = (parseInt(now / rotationPeriod) * rotationPeriod);
        return (version === this.getVersion());
    }

    /**
	 * Calculates whether "secret id" or lookup value/version used to resolve specific key
	 * is current or not. Possible states are current, valid, expired or fromFuture.
	 * 
	 * This method is for unit tests.
	 * 
	 * @param now is optional, Date.now() is default
	 * @return boolean
	 */
    isExpired(now = Date.now()) {
		const clockDiscrepancy = NameServiceConfig.getClockDiscrepancy();
		const rotationPeriod = EKRHolder.getPrimeInMs(this.rotationPeriod);
		const verifyPeriod = EKRHolder.getPrimeInMs(this.verifyPeriod);
        const expirationTime = this.getVersion() + verifyPeriod + rotationPeriod;
        return (expirationTime < (now - clockDiscrepancy));
	}

    /**
	 * Calculates whether "secret id" or lookup value/version used to resolve specific key
	 * is 'from future' or not. Possible states are current, valid, expired or 'from future'.
	 * 
	 * It is possible a secret is 'from future' if clocks aren't sync'd correctly and somebody
	 * grabs a key later than current time. This is due to our pre-gen of EKR keys due to
	 * possible delays in replication between write and read hosts.
	 * 
	 * This method is used by unit tests.
	 * 
	 * @param now
	 * @return boolean
	 */
    isFromFuture(now = Date.now()) {
        const clockDiscrepancy = NameServiceConfig.getClockDiscrepancy();
        return this.getVersion() > (now + clockDiscrepancy);
    }

    /**
	 * Returns simple int for enum. It specifies how often 'current' key is rotated...thus becoming
	 * 'valid' key (not current but still good).
	 * 
	 * @return Number
	 */
    getRotationPeriod() {
        return this.rotationPeriod;
    }

    /**
	 * Sets simple int for enum. It specifies how often 'current' key is rotated...thus becoming
	 * 'valid' key (not current but still good).
	 * 
	 * @param rotationPeriod is Number
	 */
    setRotationPeriod(val) {
        Assert.ok(val > 0 && val <= 6, `rotation period '${val}' must be number in range of 1..6`);
        this.rotationPeriod = val;
    }

    /**
	 * Returns simple int for enum. It specifies how long a key no longer 'current' is still
	 * valid for use.
	 * 
	 * @return Number
	 */
    getVerifyPeriod() {
        return this.verifyPeriod;
    }

    /**
	 * Sets simple int for enum. It specifies how long a key no longer 'current' is still
	 * valid for use.
	 * 
	 * @param verifyPeriod is Number
	 */
    setVerifyPeriod(val) {
        Assert.ok(val > 0 && val <= 6, `verify period '${val}' must be number in range of 1..6`);
        this.verifyPeriod = val;
    }

    isArtifactStillValid() {
        if (!this.isEKR()) {
            return true;
        }

        if(this.isExpired()) {
            logger.error('ESAMS_KEY_HAS_EXPIRED:', this.getChannelName());
            return false;
        }

        // Key still good
        return true;
    }
}

/**
 * Different holder classes were created so that NameService can return ALL required information on channel...not juse JRE keypair/etc. object.
 * 
 * This was primarily required so users asking for latest/enabled channel will actually get returned version back. This is required for
 * cases of key rotation. CipherText needs to remember the version of key used to sign or encrypt data.
 * 
 * -link https://wiki2.arch.ebay.com/display/KERNELDOCS/eSAMSV2
 * 
 * @source https://github.corp.ebay.com/security-platform/EsamsClient/blob/4.5.X/EsamsAPI/src/main/java/com/ebay/security/holders/KeyPairHolder.java
 *
 */
class KeyPairHolder extends EKRHolder {
    constructor({
        privateKey,
        certificates,
        channelName, channelVersion, version, label,
        verifyPeriod, rotationPeriod
    }) {
        super(channelName, channelVersion || version, label);

        this.privateKey = privateKey;
		this.certificates = certificates;
        verifyPeriod !== undefined && verifyPeriod > 0 && this.setVerifyPeriod(parseInt(verifyPeriod));
        rotationPeriod !== undefined && rotationPeriod > 0 && this.setRotationPeriod(parseInt(rotationPeriod));
    }

    /**
	 * Returns private key for keypair associated with holder.
	 * 
	 * @return
	 */
    getPrivateKey() {
        return this.privateKey;
    }

    /**
	 * Returns certificate chain associated with holder.
	 * 
	 * @return an Array<X509Certificate>
	 */
    getCertificates() {
        return this.certificates;
    }

    isArtifactStillValid() {
        for (const cert of this.certificates) {
            if (!CertificateHolder.validate(cert, this)) {
                return false;
            }
        }
        return true;
    }
}

class SecretKeyHolder extends EKRHolder {
    constructor({
        channelName, channelVersion, version,
        encodedSecretKey, algorithm, expiration,
        mode, padding, digest, envelopeVersion, authTagLen
    }) {
        super(channelName, channelVersion, version);

        Assert.ok(encodedSecretKey);
        Assert.ok(algorithm);
        Assert.ok(version !== undefined);

        // set given or use default expiration period for secret
        this.setKeyExpiryDate(expiration ? expiration : Date.now() + 24 * 60 * 60 * 1000);

        this.encodedSecretKey = encodedSecretKey;
        this.algorithm = algorithm;

        this.envelopeVersion = envelopeVersion;
        this.mode = mode;
        this.padding = padding;
        this.digest = digest;
        this.authTagLen = authTagLen;
    }
    
    isArtifactStillValid() {
        if (this.validateExpiration) {
            const expiration = this.getKeyExpiryDate();
            return expiration > Date.now();    
        }
        return true;
    }

    enforceExpiration() {
        this.validateExpiration = true;
        return this;
    }
}

class PatronusKeyPairHolder extends KeyPairHolder {
    constructor({
        privateKey,
        certificates,
        channelName,
        version,
        label,
        envelopeVersion,
        keyId
    }) {
        super({
            privateKey,
            certificates,
            channelName, version, label
        });

        this.envelopeVersion = envelopeVersion;
        this.keyId = keyId;
    }
}

class NonKeyHolder extends Holder {
    constructor({
        nonKey,
        channelName, channelVersion, version
    }) {
        super(channelName, channelVersion, version);

        this.nonKey = nonKey;
    }

    isArtifactStillValid() {
        return !!this.nonKey;
    }
}

class CertificateHolder extends EKRHolder {
    /**
	 * Default constructor
	 * 
	 * @param certificate
	 * @param version
	 * @param label - default: VERSION_LAST_ENABLED
	 */
    constructor({
        certificate,
        channelName,
        version,
        label = CONST.VERSION_LAST_ENABLED,
        rotationPeriod,
        verifyPeriod,
        channelVersion
    }) {
        super(channelName, parseInt(channelVersion) || parseInt(version), label);

        this.certificate = certificate;
        verifyPeriod !== undefined && verifyPeriod > 0 && this.setVerifyPeriod(parseInt(verifyPeriod));
        rotationPeriod !== undefined && rotationPeriod > 0 && this.setRotationPeriod(parseInt(rotationPeriod));
    }

    isArtifactStillValid() {
        return CertificateHolder.validate(this.certificate, this);
    }

    static validate(cert, options = {}) {
        const validTo = new Date(cert.validTo).getTime();

        if (Date.now() > validTo) {
            logger.warn(new Error(`Certificate for channel: ${options.channelName} has expired, ` +
                'Try to fetch from newer version from ESAMS Server. Make sure you have already rotated it!'));
            return false;
        }

        const weekAhead = Date.now() + CONST.WEEK;
        if (validTo < weekAhead) {
            logger.warn(`Certificate for channel: ${options.channelName} will expire in less than 7 days, ` +
                'Try to fetch from newer version from ESAMS Server. Make sure you have already rotated it!');
            return false;
        }

        return true;
    }
}

function createAssetFetcherForClient({
    clientName,
    assetName,
    fetch,
    validate,
    createHolder
}) {
    return async function getAssetRemotelyByClient(channelName, version) {
        const assetContainer = await fetch(channelName, version).catch(err => err);

        if (assetContainer instanceof Error) {
            const errMsg = `Problem loading ${assetName} from ${clientName} channelName: ${
                channelName}, version: ${version}`;
            throw ono(assetContainer, errMsg);
        }

        validate && validate({
            assetContainer,
            clientName,
            channelName, version
        });

        return createHolder({
            assetContainer,
            channelName,
            version
        });
    };
}

function createSharedFetcher({
    getRemoteArtifact,
    cache,
    artifactName
}) {
    Assert.ok(getRemoteArtifact);
    Assert.ok(cache);
    Assert.ok(artifactName);
    return async (channelName, version) => {
        const key = generateHashKey(channelName, version);
        // this can return a promise or holder
        const holder = cache.get(key);

        // if holder is already resolved, then return the holder
        if (holder && holder.isArtifactStillValid && holder.isArtifactStillValid() ||
            holder instanceof Promise) {
            return holder;
        }

        // make sure only one request initiates the call while the rest inherit the promise
        // share existing holder promise or create a new one and store it in the cache to share with others
        const ret = getRemoteArtifact(channelName, version)
            .then(data => {
                cache.set(key, data);
                // create a cache entry based on exact version number, this may
                // override the entry set above
                if (version === CONST.VERSION_LAST_ENABLED) {
                    cache.set(generateHashKey(channelName, data.version), data);
                }

                return data;
            })
            .catch(err => {
                if (cache.get(key) instanceof Promise) {
                    if (holder) {
                        cache.set(key, holder);
                    }
                    else {
                        cache.delete(key);
                    }
                }
                // if old holder is there, then keep it
                // otherwise set one to cache to share with other calls
                if (holder) {
                    logger.warn(`Fail to get ${artifactName} from Esams Server, channelName: ${channelName}. Please ` +
                        'contact Platform Security team (DL-eBay-Security-Framework-SJC <DL-eBay-Security-Framework-SJC@ebay.com>) ' +
                        'immediately for further investigation, for now using expired one', err);
                    return holder;
                }
                
                throw err;
            });
        cache.set(key, ret);
        return ret;
    };
}

function getPKCS8PrivateKey(patronusKey) {
    const material = patronusKey.material;
    if (/-----BEGIN [^-]+ PRIVATE KEY-----/.test(material)) {
        try {
            // pkcs1 format
            const keyObject = crypto.createPrivateKey({
                key: material,
                format: 'pem',
                type: 'pkcs1'
            });
            const pkcs8 = keyObject.export({
                type: 'pkcs8',
                format: 'pem'
            });
            return pkcs8;
        }
        catch (err) {
            logger.error(`Failed to create private key from pkcs1, path: ${patronusKey.path}, falling back to old way`, err);
        }
    }
    // otherwise assume pkcs8 or fallback to non-pem
    const match = material.replace(/\n/g, '').match(/^-----BEGIN [^-]+ PRIVATE KEY-----(.+)-----END [^-]+ PRIVATE KEY-----$/);
    const pkey = match && match[1] || material;
    return pkey;
}

function generateHashKey(prefix, postfix) {
    return `${prefix}:${postfix}`;
}

function validateCertificateContainer({
    assetContainer,
    clientName,
    channelName, version
}) {
    if (!assetContainer.certificate) {
        throw new Error(`Certificate not found for ${clientName} channelName: ${
            channelName}, version: ${version}`);
    }
}

function createCertificateHolder({
    assetContainer,
    channelName
}) {
    return new CertificateHolder(Object.assign({
        channelName
    }, assetContainer));
}

function createPatronusKeyPairHolder({
    assetContainer,
    channelName,
    version,
    label
}) {
    const {
        keyId,
        privateKey,
        certificates,
        envelopeVersion,
        channelVersion
    } = assetContainer;
    return new PatronusKeyPairHolder({
        privateKey,
        certificates,
        channelName,
        version: channelVersion || version,
        label,
        envelopeVersion,
        keyId
    });
}

function createEsamsKeyPairHolder({
    assetContainer,
    channelName,
    version
}) {
    const {
        privateKey,
        privateKeyAlgorithm,
        publicKey,
        verifyPeriod,
        rotationPeriod,
        channelVersion
    } = assetContainer;

    Assert.ok(privateKey);
    const holder = new KeyPairHolder({
        privateKey: {
            algorithm: privateKeyAlgorithm,
            encodedPrivateKey: getPKCS8PrivateKey({
                material: privateKey
            })
        },
        certificates: publicKey && [new X509Certificate(Buffer.from(publicKey, 'base64'))],
        channelVersion: channelVersion && parseInt(channelVersion),
        channelName,
        version,
        verifyPeriod, rotationPeriod
    });
    return holder;
}

function createPatronusKeyContainer({
    keyId,
    privateKey,
    certificate,
    envelopeVersion,
    channelVersion
})
{
    Assert.ok(keyId);
    Assert.ok(privateKey);
    Assert.ok(certificate !== undefined);

    return {
        keyId,
        privateKey,
        certificates: [certificate],
        envelopeVersion,
        channelVersion
    };
}

function createPatronusSecretKeyHolder({
    assetContainer,
    channelName, version
}) {
    const {
        sysMeta,
        algorithm,
        expiry,
        mode, padding, id, digest,
        authTagLen
    } = assetContainer;

    const channelVersion = sysMeta.channelVersion > 0 ? sysMeta.channelVersion : assetContainer.version;

    const options = {
        encodedSecretKey: getPKCS8PrivateKey(assetContainer),
        algorithm: sysMeta && sysMeta.esamsAlgorithm || algorithm,
        expiration: new Date(expiry).getTime(),
        channelName, channelVersion, version,
        mode, padding, digest,
        keyId: id,
        authTagLen
    };

    const envelopeVersion = sysMeta && sysMeta.envelopeVersion;
    if (envelopeVersion) {
        options.envelopeVersion = envelopeVersion;
    }

    return new SecretKeyHolder(options);
}

function createEsamsSecretKeyHolder({
    assetContainer,
    channelName, version
}) {
    const {
        encodedSecretKey,
        algorithm,
        expiration,
        verifyPeriod, rotationPeriod,
        channelVersion
    } = assetContainer;
    
    const options = {
        encodedSecretKey,
        algorithm,
        expiration,
        channelName, channelVersion, version
    };

    const holder = new SecretKeyHolder(options);

    verifyPeriod !== undefined && verifyPeriod > 0 && holder.setVerifyPeriod(parseInt(verifyPeriod));
    rotationPeriod !== undefined && rotationPeriod > 0 && holder.setRotationPeriod(parseInt(rotationPeriod));

    return holder;
}

function createFetchAsymmetricKeyFromPatronus(nameService) {
    return async function fetchAsymmetricKeyFromPatronus(channelName, version) {
        const key = await patronus.getAsymmetricKey(channelName, version);
    
        const keyId = key.id;
        const sysMeta = key.sysMeta;
        const privateKey = {
            algorithm: (sysMeta && sysMeta.esamsAlgorithm || key.algorithm || '').toUpperCase(),
            encodedPrivateKey: getPKCS8PrivateKey(key)
        };
    
        if (sysMeta) {
            const sysChannelName = sysMeta.channelName;
            const sysVersion = sysMeta.channelVersion;
            const envelopeVersion = sysMeta.envelopeVersion;
    
            if (sysChannelName && sysVersion !== undefined) {
                const certHolder = await nameService.getCertificateRemotely(sysChannelName, sysVersion).catch(err => {
                    logger.warn(`Error fetching certificate from Protego with channel name: ${
                        sysChannelName}, version: ${sysVersion}`, err);
                    logger.warn('Trying to return X509 certificate generated from Patronus');
    
                    return {
                        certificate: new X509Certificate(key.publicKey)
                    };
                });

                return createPatronusKeyContainer({
                    keyId,
                    privateKey,
                    certificate: certHolder.certificate,
                    envelopeVersion,
                    channelVersion: sysMeta.channelVersion || key.version
                });
            }
    
            const {
                serialNumber,
                issuer
            } = sysMeta;
    
            if (serialNumber && issuer) {
                const certContainer = await protego.getCertificateBySerial(serialNumber, issuer).catch(err => {
                    logger.warn(`Error fetching certificate from Protego with serialNumber ${serialNumber}, issuer: ${issuer}`, err);
                    return {
                        certificate: new X509Certificate(key.publicKey)
                    };
                });
                return createPatronusKeyContainer({
                    keyId,
                    privateKey,
                    certificate: certContainer.certificate,
                    envelopeVersion,
                    channelVersion: sysMeta.channelVersion || key.version
                });
            }
        }
    
        logger.warn(`No cert related sysMeta found. Trying to return X509 certificate generated from Patronus`);
        return createPatronusKeyContainer({
            keyId,
            privateKey,
            certificate: new X509Certificate(key.publicKey),
            channelVersion: key.version
        });
    };
}

function createNonKeyHolder(options) {
    const {
        assetContainer,
        channelName, version
    } = options;

    const channelVersion = assetContainer.channelVersion || assetContainer.version;

    return new NonKeyHolder({
        nonKey: assetContainer.value,
        channelName,
        channelVersion: parseInt(channelVersion) || -1,
        version
    });
}

/**
 * Core eSAMS interface. Used by TDSAdapter, TwoFA, CIF for resolving remote security artifacts.
 * 
 * NOTE! 99.9% of PD should be using the cryptographic envelopes as they support key rotation.
 * 
 * This interface should only be used by those wanting NonKey assets (blobs)...and we may merely want a
 * facade for this functionality as we can then completely hide the NameService.
 * 
 * -link https://wiki2.arch.ebay.com/display/KERNELDOCS/eSAMSV2
 * 
 * @source https://github.corp.ebay.com/security-platform/EsamsClient/blob/4.5.X/EsamsAPI/src/main/java/com/ebay/security/nameservice/NameService.java
 * @implementation https://github.corp.ebay.com/security-platform/EsamsClient/blob/4.5.X/EsamsServiceConsumer/src/main/java/com/ebay/marketplace/services/esamsservice/NameServiceImpl.java
 *
 */
class NameService {
    constructor() {
        this.certificates = new LRU({
            max: 300
        });
        this.selectorCertificateCache = new LRU({
            max: 300
        });
        this.keyPairCache = new LRU({
            max: 300
        });
        this.sealSecretKeyCache = new LRU({
            max: 300
        });
        this.unsealSecretKeyCache = new LRU({
            max: 300
        });
        this.nonKeyCache = new LRU({
            max: 300
        });
        this.selectorPrivateKeyCache = new LRU({
            max: 300
        });

        /* ========  Certificate ======= */
        this.getCertificateRemotelyFromProtego = createAssetFetcherForClient({
            clientName: 'protego',
            assetName: 'Certificate',
            validate: validateCertificateContainer,
            createHolder: createCertificateHolder,
            fetch: (channelName, version) => protego.getCertificateByChannel(channelName, version)
        });

        this.getCertificateRemotelyFromEsams = createAssetFetcherForClient({
            clientName: 'esams',
            assetName: 'Certificate',
            validate: validateCertificateContainer,
            createHolder: createCertificateHolder,
            fetch: (channelName, version) => esams.getCertificate(channelName, version)
        });

        this.getCertificateInternal = createSharedFetcher({
            getRemoteArtifact: (channelName, version) => this.getCertificateRemotely(channelName, version),
            cache: this.certificates,
            artifactName: 'certificate'
        });

        /* ========  Key Pair ======= */
        const fetchAsymmetricKeyFromPatronus = createFetchAsymmetricKeyFromPatronus(this);
        this.getKeyPairRemotelyFromPatronus = createAssetFetcherForClient({
            clientName: 'patronus',
            assetName: 'KeyPair',
            createHolder: createPatronusKeyPairHolder,
            fetch: (channelName, version) => fetchAsymmetricKeyFromPatronus(channelName, version)
        });

        this.getKeyPairRemotelyFromEsams = createAssetFetcherForClient({
            clientName: 'esams',
            assetName: 'KeyPair',
            createHolder: createEsamsKeyPairHolder,
            fetch: (channelName, version) => esams.getKeyPair(channelName, version)
        });

        this.getKeyPairInternal = createSharedFetcher({
            getRemoteArtifact: (channelName, version) => this.getKeyPairRemotely(channelName, version),
            cache: this.keyPairCache,
            artifactName: 'keyPair'
        });

        /* ========  Secret Key ======= */
        this.getSecretKeyRemotelyFromPatronus = createAssetFetcherForClient({
            clientName: 'patronus',
            assetName: 'SecretKey',
            createHolder: createPatronusSecretKeyHolder,
            fetch: (channelName, version) => patronus.getPatronusKey(channelName, version)
        });

        this.getSecretKeyRemotelyFromEsams = createAssetFetcherForClient({
            clientName: 'esams',
            assetName: 'SecretKey',
            createHolder: createEsamsSecretKeyHolder,
            fetch: async (channelName, version) => esams.getSecretKey(channelName, version)
        });

        this.getSealSecretKeyInternal = createSharedFetcher({
            getRemoteArtifact: (channelName, version) => this.getSecretKeyRemotely(channelName, version),
            cache: this.sealSecretKeyCache,
            artifactName: 'secretKey'
        });

        this.getUnsealSecretKeyInternal = createSharedFetcher({
            getRemoteArtifact: (channelName, version) => this.getSecretKeyRemotely(channelName, version),
            cache: this.unsealSecretKeyCache,
            artifactName: 'secretKey'
        });

        /* ========  NonKey ======= */
        this.getNonKeyRemotelyFromFidelius = createAssetFetcherForClient({
            clientName: 'fidelius',
            assetName: 'NonKey',
            createHolder: createNonKeyHolder,
            fetch: (channelName) => new Promise((resolve, reject) => {
                fidelius.getSecret(`${AppContext.appName}/${channelName.replace(/\./gi, '/')}`,
                    {'X-ESAMS-CHANNEL-NAME': channelName}, (err, _, body) => {
                    if (err) {
                        return reject(err);
                    }
                    resolve(body);
                });
            })
        });

        this.getNonKeyRemotelyFromEsams = createAssetFetcherForClient({
            clientName: 'esams',
            assetName: 'NonKey',
            createHolder: createNonKeyHolder,
            fetch: (channelName, version) => esams.getNonKey(channelName, version)
        });

        this.getNonKeyInternal = createSharedFetcher({
            getRemoteArtifact: (channelName, version) => this.getNonKeyRemotely(channelName, version),
            cache: this.nonKeyCache,
            artifactName: 'nonKey'
        });
    }

    removeFromCache(channelName, version = -1) {
        const key = generateHashKey(channelName, version);
        this.certificates.delete(key);
        this.selectorCertificateCache.delete(key);
        this.keyPairCache.delete(key);
        this.sealSecretKeyCache.delete(key);
        this.unsealSecretKeyCache.delete(key);
        this.nonKeyCache.delete(key);
        this.selectorPrivateKeyCache.delete(key);
    }

    /**
	 * Obtains specific version of secretKey for unseal operation from eSAMS
	 * 
	 * @param channelName Name of secret/shared/symmetric key to retrieve from eSAMS.
	 * @param version Version of object desired (may be actual ver# of one of two 'tags'/labels from NameService intf).
	 * @return Holder subclass containing desired object and actual version # returned.
	 */
    getSecretKey(channelName, version = -1) {
        return this.getUnsealSecretKeyInternal(channelName, version);
    }

    /**
	 * Obtains specific version of secretKey for seal operation from eSAMS
	 * 
	 * @param channelName Name of secret/shared/symmetric key to retrieve from eSAMS.
	 * @param version Version of object desired (may be actual ver# of one of two 'tags'/labels from NameService intf).
	 * @return Holder subclass containing desired object and actual version # returned
	 */
    async getSealSecretKey(channelName, version = -1) {
        const key = await this.getSealSecretKeyInternal(channelName, version);
        key && key.enforceExpiration();
        if (key && !key.isArtifactStillValid()) {
            logger.error(new Error(`SecretKey has expired for seal operation, channel: ${channelName}, version: ${key.version}`));
        }
        return key;
    }

    /**
	 * Obtains specific version of keypair from eSAMS
	 * 
	 * @param channelName Name of keypair (priv + public key/cert) to retrieve from eSAMS.
	 * @param version Version of object desired (may be actual ver# of one of two 'tags'/labels from NameService intf).
	 * @return Holder subclass containing desired object and actual version # returned.
	 */
    getKeyPair(channelName, version = -1) {
        return this.getKeyPairInternal(channelName, version);
    }

    async getKeyPairRemotely(channelName, version) {
        if (patronus.isEnabled()) {
            const holder = await this.getKeyPairRemotelyFromPatronus(channelName, version).catch(err => err);
            if (holder instanceof Error) {
                const config = getConfig();
                if (!config.isPatronusFallbackEnabled()) {
                    throw holder;
                }
                logger.warn(`Fetch key and cert from Patronus failed, falling back to esams to get keyPair`, holder);
            }
            else {
                return holder;
            }
        }

        return this.getKeyPairRemotelyFromEsams(channelName, version);
    }

    async getSecretKeyRemotely(channelName, version) {
        if (patronus.isEnabled() || isUuid(channelName)) {
            const holder = await this.getSecretKeyRemotelyFromPatronus(channelName, version).catch(err => err);
            if (holder instanceof Error) {
                const config = getConfig();
                if (!config.isPatronusFallbackEnabled()) {
                    throw holder;
                }
                logger.warn(`Fetch secretKey from Patronus failed, channelName: ${
                    channelName}, version: ${version}, falling back to esams to get secretKey`, holder);
            }
            else {
                return holder;
            }
        }

        return this.getSecretKeyRemotelyFromEsams(channelName, version);
    }

    /**
	 * Obtains specific version of 3rd party certificate/publicKey from eSAMS
	 * 
	 * @param channelName Name of certificate to retrieve from eSAMS.
	 * @param version Version of object desired (may be actual ver# of one of two 'tags'/labels from NameService intf).
	 * @return Holder subclass containing desired object and actual version # returned.
	 */
    async getCertificate(channelName, version = -1) {
        return this.getCertificateInternal(channelName, version);
    }

    async getCertificateRemotely(channelName, version) {
        if (protego.isEnabled()) {
            const holder = await this.getCertificateRemotelyFromProtego(channelName, version).catch(err => err);
            if (holder instanceof Error) {
                if (!protego.isProtegoFallbackEnabled()) {
                    throw holder;
                }
                logger.warn(`Exception while getting certificate from Protego, falling back to esams to get certificate`, holder);
            }
            else {
                return holder;
            }
        }
        return this.getCertificateRemotelyFromEsams(channelName, version);
    }

    /**
	 * Obtains specific version of nonKey-asset (login/password, salt, etc.) from eSAMS
	 * 
	 * @param channelName Name of non-key asset (password, salt, etc) to retrieve from eSAMS.
	 * @param version Version of object desired (may be actual ver# of one of two 'tags'/labels from NameService intf).
	 * @return Holder subclass containing desired object and actual version # returned.
	 */
    getNonKey(channelName, version = -1) {
        return this.getNonKeyInternal(channelName, version);
    }

    async getNonKeyRemotely(channelName, version) {
        const config = getConfig();
        if (config.isFideliusEnabled()) {
            const holder = await this.getNonKeyRemotelyFromFidelius(
                channelName, version).catch(err => err);

            if (holder instanceof Error) {
                if (config.isFideliusFallbackEnabled()) {
                    logger.warn(`Exception while getting secrets from Fidelius, channel: ${
                        channelName}, version: ${version}, falling back to ESAMS to get the secrets`);    
                }
                else {
                    throw holder;
                }
            }
            else {
                return holder;
            }
        }

        return this.getNonKeyRemotelyFromEsams(channelName, version);
    }
}

module.exports = {
    NameService,
    getPKCS8PrivateKey,
    generateHashKey,
    EKRHolder,
    KeyPairHolder,
    CertificateHolder,
    EKRRotationEnum,
    EKRVerifyEnum,
    CONST,
    logger,
    clients: {
        patronus,
        protego,
        fidelius,
        esams
    }
};
