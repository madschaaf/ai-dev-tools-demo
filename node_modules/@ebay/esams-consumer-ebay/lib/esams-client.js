'use strict';

const { X509Certificate } = require('crypto');

const stringify = require('json-stringify-safe');

const serviceClient = require('@ebay/service-client-ebay');

const PKCS8_ENCODED_PRIVATE_KEY_HEADER = '-----BEGIN PRIVATE KEY-----\n';
const PKCS8_ENCODED_PRIVATE_KEY_FOOTER = '\n-----END PRIVATE KEY-----';

const {
    getIdentityFilePaths,
    getDefaultIdentityFile,
    getIdentity
} = require('./identity-utils');

class EsamsClient {
    constructor() {
        this._headers = {};
    }

    _getHeaders() {
        if (!this._headers['X-EBAY-DELIVERABLE-IDENTITY']) {
            const identityFile = getDefaultIdentityFile();
            if (!identityFile) {
                throw new Error(`ESAMS identity file(s) not found: ${getIdentityFilePaths()}`);
            }
            this._headers['X-EBAY-DELIVERABLE-IDENTITY'] = getIdentity(identityFile);
        }
        return this._headers;
    }

    getSecretKey(channelName, channelVersion) {        
        return new Promise((resolve, reject) => {
            const client = serviceClient.context({}).getClient('esamsConsumerSvc');
            client.post({
                body: {
                    channelName: channelName,
                    channelVersion: String(channelVersion)
                }
            })
            .options({
                headers: this._getHeaders(),
                service: 'EsamsService',
                operation: 'getSecretKey'
            })
            .end((err, response) => {
                if (err) {
                    return reject(err);
                }
    
                response = response.body;
    
                if (!response || !response.secretKey) {
                    return reject(new Error(`secret key is missing in response: ${stringify(response)}`));
                }
    
                const result = {};
                result.encodedSecretKey = response.secretKey.encodedSecretKey;
                result.algorithm = response.secretKey.algorithm;
                result.expiration = response.secretKey.keyExpiryDate && new Date(response.secretKey.keyExpiryDate).getTime();
                
                response.attributes = response.attributes || {};
                result.verifyPeriod = response.attributes.verifyPeriod;
                result.rotationPeriod = response.attributes.rotationPeriod;
                result.channelVersion = response.attributes.channelVersion;
                
                resolve(result);
            });
        });
    }

    getNonKey(channelName, channelVersion) {
        return new Promise((resolve, reject) => {
            const client = serviceClient.context({}).getClient('esamsConsumerSvc');
            client.post({
                body: {
                    channelName: channelName,
                    channelVersion: String(channelVersion)
                }
            })
            .options( {
                headers: this._getHeaders(),
                service: 'EsamsService',
                operation: 'getNonKey'
            })
            .end((err, response) => {
                if (err) {
                    return reject(err);
                }

                response = response.body;

                if (!response || !response.value) {
                    return reject(new Error(`Non key is missing in response: ${stringify(response)}`));
                }

                const result = {};
                result.value = response.value;
                response.attributes = response.attributes || {};
                result.channelVersion = response.attributes.channelVersion;

                return resolve(result);
            });
        });
    }

    getKeyPair(channelName, channelVersion) {
        return new Promise((resolve, reject) => {
            const client = serviceClient.context({}).getClient('esamsConsumerSvc');
            client.post({
                body: {
                    channelName: channelName,
                    channelVersion: String(channelVersion)
                }
            })
            .options({
                headers: this._getHeaders(),
                service: 'EsamsService',
                operation: 'getKeyPair'
            })
            .end((err, response) => {
                if (err ) {
                    return reject(err);
                }
    
                response = response.body;
    
                if (!response || !response.privateKey) {
                    return reject(new Error(`Private key is missing in response: ${stringify(response)}`));
                }
    
                if (!response || !response.certificateList || !response.certificateList.length) {
                    return reject(new Error(`Certificate list is missing in response: ${stringify(response)}`));
                }
                
                const result = {};
                result.privateKey = PKCS8_ENCODED_PRIVATE_KEY_HEADER + response.privateKey.encodededPrivateKey + PKCS8_ENCODED_PRIVATE_KEY_FOOTER;
                result.privateKeyAlgorithm = response.privateKey.algorithm;
    
                result.publicKey = response.certificateList[0].encodedCertifcate;
                result.publicKeyAlgorithm = response.certificateList[0].algorithm;
    
                response.attributes = response.attributes || {};
                result.verifyPeriod = response.attributes.verifyPeriod;
                result.rotationPeriod = response.attributes.rotationPeriod;
                result.channelVersion = response.attributes.channelVersion;
    
                return resolve(result);
            });
        });
    }

    getCertificate(channelName, channelVersion) {
        return new Promise((resolve, reject) => {
            const client = serviceClient.context({}).getClient('esamsConsumerSvc');
            client.post({
                body: {
                    channelName: channelName,
                    channelVersion: String(channelVersion)
                }
            })
            .options({
                headers: this._getHeaders(),
                service: 'EsamsService',
                operation: 'getCertificate'
            })
            .end((err, response) => {
                if (err) {
                    return reject(err);
                }
    
                response = response.body;
                
                if (!response || !response.certificate || !response.certificate.encodedCertifcate) {
                    return reject(new Error(`Certificate is missing in response: ${stringify(response)}`));
                }
    
                const result = {};
                result.encodedCertifcate =  response.certificate.encodedCertifcate;
                result.algorithm = response.certificate.algorithm;
    
                response.attributes = response.attributes || {};
                result.verifyPeriod = response.attributes.verifyPeriod;
                result.rotationPeriod = response.attributes.rotationPeriod;
                result.channelVersion = response.attributes.channelVersion;
    
                return resolve(result);
            });
        }).then(data => {
            data.certificate = new X509Certificate(Buffer.from(data.encodedCertifcate, 'base64'));
            return data;
        });
    }
}

module.exports = {
    EsamsClient
};
