'use strict';

const Assert = require('assert');
const ono = require('@jsdevtools/ono');
const Provider = require('@ebay/service-client-ebay');
const { getConfig } = require('@ebay/spellcaster-ebay');

/**
 * This class depends on TrustFabric and expects the trust
 * fabric to be initialized before the methods are called.
 *
 * @source: https://github.corp.ebay.com/raptor-io-components/raptor-esams-component/blob/master/EsamsServiceConsumer/src/main/java/com/ebay/platform/security/nextgen/client/PatronusClient.java
 */
class PatronusClient {
    getPath(channelName, version) {
        Assert.ok(channelName, 'channelName must be provided');
        Assert.ok(version !== undefined, 'version must be provided');
        // eslint-disable-next-line no-param-reassign
        channelName = channelName.split('?').shift();
        // if uuid
        const isUuid = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i.test(channelName);
        return isUuid ? `/keys/${channelName}/export` :
            `/channels/${channelName}${version !== -1 ? `/versions/${version}` : ''}`;
    }

    getQueryParamRealm(path) {
        const pathSplit = path.split('?');
        if (pathSplit.length > 1) {
            const searchParams = new URLSearchParams(pathSplit.pop());
            return searchParams.get('realm');
        }
    }

    getPatronusKey(channelName, version = -1) {
        const path = this.getPath(channelName, version);
        const realm = this.getQueryParamRealm(channelName);
        const query = realm ? {
            realm
        } : {};

        return this.invokeService(path, query);
    }

    /**
     * async getAsymmetricKey
     */
    async getAsymmetricKey(channelName, version = -1) {
        const path = this.getPath(channelName, version);
        const realm = this.getQueryParamRealm(channelName);
        const query = {
            format: 'X509'
        };
        if (realm) {
            query.realm = realm;
        }
        const data = await this.invokeService(path, query);
        if (data.type.toUpperCase() !== 'ASYMMETRIC') {
            throw new Error(`Failed to get key pair as requested path ${
                path} does not return ASYMMETRIC key, the actual type is ${data.type}`);
        }
        return data;
    }

    getPatronusKeyByIssuerAndSerialNumber(issuer, serialNumber) {
        const path = `/channels/issuer/${issuer}/serialNumber/${serialNumber}`;
        const query = {
            format: 'X509'
        };
        return this.invokeService(path, query);
    }

    invokeService(path, query) {
        return new Promise((resolve, reject) => {
            const client = Provider.context({}).getClient('patronus-client');
            client.get(query)
                .path(path)
                .end((err, res) => {
                    if (err) {
                        return reject(ono(err, `Error while making key request to Patronus ${err.message}`));
                    }
                    if (res.statusCode >= 300) {
                        return reject(new Error(
                            `Unexpected status code while making key request to Patronus, status code: ${
                                res.statusCode}, body: ${res.body && res.body.toString() || 'empty'}`));
                    }
                    resolve(res.body);
                });
        });
    }

    isEnabled() {
        const config = getConfig();
        return config.isPatronusEnabled();
        // tfTokenAvailable && config.isPatronusFallbackEnabled(); make sense only when we check
        //  for tf token availability, which we assume is always available.
    }
}

module.exports = {
    PatronusClient
};
