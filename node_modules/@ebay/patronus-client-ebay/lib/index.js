const provider = require('@ebay/service-client-ebay');
const trustFabric = require('@ebay/trust-fabric-ebay');
const assert = require('assert');
const { deprecate } = require('util');
const allowedList = {};

// @Deprecated
class PatronusClient {
    // Asymmetric key pair e.g RSA(Public & Private key pair)
    getAsymmetricKeyPair(keyPathOrKeyId, callback) {
        assert.ok(keyPathOrKeyId, 'keyPathOrKeyId is required');

        this._makeRequest(`${keyPathOrKeyId}/export`, { method: 'GET' }, 'patronus-get-key', (err, res) => {
            if (err || !res) {
                return callback(err || new Error('Response is empty'));
            }

            if (res.type.toUpperCase() !== 'ASYMMETRIC') {
                // eslint-disable-next-line max-len
                return callback(new Error(`Failed to get key pair as requested keyPathOrKeyId ${keyPathOrKeyId} is NOT ASYMMETRIC`));
            }
            callback(null, res);
        });
    }

    // Private key e.g AES
    getSymmetricKey(keyPathOrKeyId, callback) {
        assert.ok(keyPathOrKeyId, 'keyPathOrKeyId is required');

        this._makeRequest(`${keyPathOrKeyId}/export`, { method: 'GET' }, 'patronus-get-key', (err, res) => {
            if (err || !res) {
                return callback(err || new Error('Response is empty'));
            }

            if (res.type.toUpperCase() !== 'SYMMETRIC') {
                // eslint-disable-next-line max-len
                return callback(new Error(`Failed to get secert key as requested keyPathOrKeyId ${keyPathOrKeyId} is NOT SYMMETRIC`));
            }
            callback(null, res);
        });
    }

    // Used only for eSAMS backward compatibility during migration
    // analog of com.ebay.platform.security.nextgen.client.PatronusClient getAsymmetricKey
    getEsamsSymmetricKey(channelName, version, callback) {
        assert.ok(channelName, 'ChannelName is required');

        if (version && version !== -1) {
            // eslint-disable-next-line no-param-reassign
            channelName = `${channelName}/versions/${version}`;
        }

        this._makeRequest(channelName, { method: 'GET' }, 'patronus-channel-key', (err, res) => {
            if (err) {
                return callback(err);
            }
            if (res.type.toUpperCase() !== 'SYMMETRIC') {
                // eslint-disable-next-line max-len
                return callback(new Error(`Failed to get secert key as requested channel ${channelName} is NOT SYMMETRIC`));
            }
            callback(null, res);
        });
    }

    // Used only for eSAMS backward compatibility during migration
    // analog of com.ebay.platform.security.nextgen.client.PatronusClient getAsymmetricKey
    getEsamsKeyPair(channelName, version, callback) {
        assert.ok(channelName, 'ChannelName is required');

        if (version && version !== -1) {
            // eslint-disable-next-line no-param-reassign
            channelName = `${channelName}/versions/${version}`;
        }

        this._makeRequest(channelName, { method: 'GET' }, 'patronus-channel-key', (err, res) => {
            if (err) {
                return callback(err);
            }
            if (res.type.toUpperCase() !== 'ASYMMETRIC') {
                // eslint-disable-next-line max-len
                return callback(new Error(`Failed to get keypair as requested channel ${channelName} is NOT ASYMMETRIC`));
            }
            callback(null, res);
        });
    }

    _makeRequest(keyPath, options, serviceName, callback) {
        assert.ok(keyPath, 'Path is required');

        // eslint-disable-next-line no-param-reassign
        options = options || {};
        options.headers = options.headers || {};

        trustFabric.getToken((error, token) => {
            if (error) {
                return callback(new Error(`Unable to generate token for calling Patronus ${ error}`));
            }

            if (process.env.PATRONUS_SUCCESS_CODES) {
                options['error-handler'] = {
                    'success-codes': JSON.parse(process.env.PATRONUS_SUCCESS_CODES)
                };
            }

            const client = provider.context({}).getClient(serviceName);
            client.request(options)
                .path(keyPath)
                .set('Authorization', `Bearer ${token}`)
                .end((err, res) => {
                    if (err || !res || !res.body) {
                        return callback(new Error(`Error while making key request to Patronus ${
                            err}`), null);
                    }
                    if (res.statusCode >= 300) {
                        return callback(new Error(`Unexpected status code while making key request to Patronus ${
                            `status code: ${res.statusCode}`}, body: ${
                            res.body && JSON.stringify(res.body) || 'empty'}`), null);
                    }

                    callback(null, res.body);
                });
        });
    }

    isAppWhiteListed(appName, type, callback) {
        this.isAppWhiteListedDeprecated = this.isAppWhiteListedDeprecated ||
            deprecate(() => {}, 'The method isAppWhiteListed is deprecated in favor of patronus.isEnabled');
        this.isAppWhiteListedDeprecated(); // trigger deprecation warning

        assert.ok(appName, 'App Name is required');
        assert.ok(type, 'Type is required');
        if (allowedList[appName] !== undefined) {
            return callback(null, allowedList[appName][type]);
        }

        const client = provider.context({}).getClient('patronus-whitelist');
        client.get()
            .path(`${appName}/config`)
            .end((err, res) => {
                if (err || !res || !res.body) {
                    return callback(new Error(`Error while reading whitelist from Patronus config${ err}`), false);
                }
                // Cache appname to avoid calls
                allowedList[appName] = res.body;
                callback(null, allowedList[appName][type]);
            });
    }
}

module.exports = new PatronusClient();
