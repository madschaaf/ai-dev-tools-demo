'use strict';

var Url = require('url'),
    utilsEbay = require('@ebay/utils-ebay'),
    Async = require('async'),
    url = require('url'),
    Objpath = require('object-path'),
    tryrequire = require('try-require');

var cal = require('@ebay/cal'),
    security = require('@ebay/security-ebay'),
    SiteMeta = require('@ebay/site-meta-ebay'),
    ebayAppMeta = require('@ebay/appmeta-ebay'),
    kernelServ = require('@ebay/kernel-services-ebay'),
    logger = require('@ebay/logging-inc').logger('commons-ebay/middleware');

var reqUtils = require('./request-utils'),
    appContext = require('./app-context'),
    requestContext = require('./request-context');

const Querystring = require('querystring');

const clientHints = require('@ebay/client-hints-ebay');
const modConfig = require('@ebay/module-config-inc');

function patchSecure(req) {
    delete req.secure;

    Object.defineProperty(req, 'secure', {
        get: function () {
            var isSecure = req.ebay.isSecure() || false;
            return isSecure;
        },
        configurable: true
    });
}

function clientInfo(req, maskedPayload) {
    const headers = req.headers;
    const scriptPath = url.parse(maskedPayload).pathname;
    const serverName = utilsEbay.getServerName(req);

    const referer = headers.referer && headers.referer.trim();
    const xff = headers['x-forwarded-for'];

    return `RemoteIP=${
            req.ebay.getRemoteAddr()
        }&${
            genTlsClientInfo(req)
        }&Server=${
            serverName
        }&Script=${
            scriptPath
        }&Encoding=${
            headers['accept-encoding']
        }&Agent=${
            headers['user-agent']
        }${
            referer ? `&Referer=${referer}` : ''
        }${
            xff ? `&ForwardedFor=${xff}` : ''
        }`;
}

function genTlsClientInfo(req) {
    const isSecure = req.ebay.isSecure();

    const tlsInfo = {
        Protocol: isSecure ? 'HTTPS' : 'HTTP'
    };

    if (isSecure) {
        const { version, ip } = utilsEbay.parseClientTLSVersionHeader(req);
        if (version) {
            tlsInfo.TlsVersion = version;
            tlsInfo.TlsIP = ip;
        }
    }
    
    const callerApp = req.headers['x-ebay-client-app-name'];
    if (callerApp) {
        tlsInfo.CallerApp = callerApp;
    }

    return Querystring.stringify(tlsInfo);
}

/**
 * - binding request level localstorage
 * - generating a new rlogid for request
 * - checking if the request is secure or not
 * - calling kernelService for siteInfo
 * - calling appMetaService for appMeta
 */
function CommonsMiddleware(options) {
    options = options || {};
    var isService = options.type === 'service';

    var version;
    var brogan = tryrequire('@ebay/brogan-ebay/package.json');
    var commonsinc = tryrequire('@ebay/commons-inc/package.json');

    if (brogan && brogan.version) {
        version = brogan.version.split('.');
        if (version[0] < 4 || (version[0] === '4' && version[1] === '0' && version[2] < 5)) {
            throw new Error('commons-ebay version 4.0.4 or higher requires brogan-ebay 4.0.5 or higher');
        }
    }

    if (commonsinc && commonsinc.version) {
        version = commonsinc.version.split('.');
        if (version[0] < 4 || (version[0] === '4' && version[1] === '0' && version[2] < 4)) {
            throw new Error('commons-ebay version 4.0.4 or higher requires commons-inc 4.0.4 or higher');
        }
    }

    return function commonsEbay(req, res, next) {

        Async.series([
            function ch(done) {
                clientHints.getClientHintConfig().then((cfg) => {
                    req.clientHintsConfig = cfg;
                    if(cfg && cfg.isEnabled() === true) {
                        // Send Accept Client Hint header
                        const hints = cfg.getCHAcceptHeaders() || [];                                
                        res.setHeader('accept-ch', hints.join());       
                    }
                }).finally(done);
            },
            function requestCtx(done) {
                req.ebay = requestContext.getFactory(options.type).create(req, res, options);
                patchSecure(req);
                req.isInternalRequest = req.ebay.isInternalRequest;

                var requestUrl = reqUtils.getRequestURL(req);
                req.ebay.requestUrl = requestUrl;

                // use dummy even to get access to parent object and set corelation id that will be propagated across all events
                // since this is the only place where we get hold of the value
                const parentTx = cal.createEvent('dummy').parent;
                if (parentTx) {
                    parentTx.correlationId = req.ebay.getCorrelationRequestId().getCorrelationRequestId();
                }
                var payload = security.getMaskPayload(req);
                cal.createEvent('URL', 'ClientInfo', 0, clientInfo(req, payload)).complete();
                cal.createEvent('URL', 'Payload', 0, payload).complete();
                cal.createEvent('OTEL', 'OTEL', '0', `spanId=${req?.otel?.spanId}&traceId=${req?.otel?.traceId}` +
                    `&OTELSampled=${req?.otel?.isRecording}`).complete();
                const parentReqRlogId = req.headers['rlogid'];
                if(parentReqRlogId) {
                    cal.createEvent('URL', 'Backward_RLOGID', 0, `rlogid=${parentReqRlogId}`).complete();
                }

                cal.createEvent('URL', 'isSecure', 0, ''+req.ebay.isSecure()).complete();
                //Log Additional CAL if Remote Address is 127.0.0.1, which means someone is spoofing headers
                if(req.headers && req.ebay.getRemoteAddr() === '127.0.0.1') {
                    let ipAddress = 'x-ebay-akamai-9=' + req.headers['x-ebay-akamai-9'];
                    ipAddress += '&x-ebay-client-ip=' + req.headers['x-ebay-client-ip'];
                    ipAddress += '&x-forwarded-for=' + req.headers['x-forwarded-for'];
                    cal.createEvent('URL', 'IP Spoofing Detected', 0, ipAddress).complete();
                }

                // if req.ebay is a service context, this will be a no-op
                req.ebay.setIsolateCookie();

                done();
            },
            function appmeta(done) {
                ebayAppMeta.getAppMeta(appContext.appName, function (err, appMeta) {
                    if (err) {
                        logger.error('Failed to get appmeta - run "appregister" to register your pages, refer to "@ebay/appmeta-register-ebay" for more details', err);
                    }
                    if (appMeta) {
                        req.ebay.appMeta = appMeta;
                    }
                    done();
                });
            },
            function experienceservice_meta(done) {
                var expSvc = reqUtils.getExpSvcByRoute(req);
                if (expSvc && expSvc.operation) {

                    expSvc.operation = expSvc.operation.trim();
                    req.ebay.expSvc = expSvc;

                    ebayAppMeta.getAppMeta(expSvc.name, true, function getAppMeta(err, appMeta) {
                        if (err) {
                            logger.error('Failed to get appmeta - run "appregister" to register your pages, refer to "@ebay/appmeta-register-ebay" for more details', err);
                        }

                        if (appMeta) {
                            var operationId = appMeta.getPageId(req.ebay.expSvc.operation);
                            if (operationId) {
                                req.ebay.expSvc.operationId = operationId;
                            } else {
                                logger.error('Failed to find Experience Service OperationId for pageUrl:', req.url, ', Operation: ', req.ebay.expSvc.operation, new Error('Experience Service Operation Id is not found'));
                            }
                            req.ebay.expSvc.operationId = operationId;
                        }

                        done();
                    });
                } else {
                    done();
                }

            },
            function setup(done) {
                isService ?
                    service(req, done) :
                    web(req, done);
            }
        ], function (errors, results) {
            next();
        });
    };
}

function service(req, next) {
    // based on market id we should set site info
    let mktId = req.ebay.getMarketplaceId();
    let locale = req.ebay.getAcceptLanguages()[0];
    let siteId;
    // re-map to COS market place id standard
    if (mktId === 'EBAY-FRCA' || mktId === 'EBAY-CA' && locale === 'fr-CA') {
        mktId = 'EBAY-CA';
        siteId = 210;
        locale = locale || 'fr-CA';
    }
    else if (mktId === 'EBAY-ENCA') {
        mktId = 'EBAY-CA';
        siteId = 2;
    }
    else if (mktId === 'EBAY-GB') {
        siteId = 3;
    }
    else if (/EBAY[-_]NLBE|EBAY[-_]BE[-_]NL/.test(mktId) || mktId === 'EBAY-BE' && locale === 'nl-BE') {
        mktId = 'EBAY-BE';
        siteId = 123;
        locale = locale || 'nl-BE';
    }
    else if (/EBAY[-_]FRBE|EBAY[-_]BE[-_]FR/.test(mktId) || mktId === 'EBAY-BE' && locale === 'fr-BE') {
        mktId = 'EBAY-BE';
        siteId = 23;
        locale = locale || 'fr-BE';
    }
    else {
        const siteMeta = SiteMeta.getSiteByName(mktId.split('-').join('_'));
        siteId = siteMeta && siteMeta.value || 0;
        siteId = siteId === 1 ? 0 : siteId;
    }
    locale = locale || 'en-US';
    const localeParts = locale.split(/[-_]/);
    req.ebay.siteInfo = {
        'marketplace-id': mktId,
        'user-preferences': {
            country: mktId.split(/[-_]/).pop() || 'US',
            language: `${localeParts[0]}-${localeParts[1]}`
        },
        'site-id': siteId,
        'locale-info': {
            country: localeParts[1],
            language: localeParts[0]
        }
    };

    logger.warn('site-info', req.ebay.siteInfo);

    next();
}

function web(req, next) {
    var tasks = {
        kernel: function kernel(cb) {
            var host = req.ebay.host;

            if (reqUtils.getHeaderValue(req, 'X-eBay-EP-Proxy-Request')) {
                var bpoolUrl = reqUtils.getHeaderValue(req, 'X-eBay-Original-URL');
                if (bpoolUrl) {
                    var bpoolUrlParsed = Url.parse(bpoolUrl);
                    host = bpoolUrlParsed.hostname || req.headers.host;
                }
            }

            kernelServ.getSiteInfo(host, function (err, siteInfo) {
                if (err) {
                    logger.error('Failed to get site-info', err);
                }
                if (siteInfo) {
                    req.ebay.siteInfo = siteInfo;
                }
                cb();
            });
        }
    };
    // if no authentication is expected, then skip sign-in link retrieval
    // temporary putting sigin-in-link options till we implement url building for all routes
    if ((Objpath.get(req, 'route.config.security') && Objpath.get(req, 'route.config.security') !== 'L0SESSION') || Objpath.get(req, 'route.config.sign-in-link')) {
        tasks.signInPageUrl = function signInPageUrl(cb) {
            var options = {},
                pageId = req.ebay.getPageId(),
                baseUrl = (req.ebay.isSecure() ? 'https' : 'http') + '://' + req.headers.host + req.url;

            // we need to provide only base url for sign-in link
            options.returnUrl = baseUrl;
            options.pageId = pageId || 1;
            kernelServ.getSignInLink(options, function (err, link) {
                if (err) {
                    logger.error('Failed to get sign-in link', err);
                }
                if (link) {
                    var requestBaseUrlEncoded = encodeURIComponent(baseUrl);

                    // now replace baseUrl with return url and parameters
                    const skipRu = Objpath.get(req, 'route.config.sign-in-link.skip-ru');
                    req.ebay.signInPageUrl = link.replace(requestBaseUrlEncoded, skipRu === true ?
                        '' : encodeURIComponent(req.ebay.requestUrl));
                }
                cb();
            });
        };
    }

    Async.parallel(tasks, function (errors, results) {
        modConfig(module, (_, config) => {
            const siteId = req.ebay.getSiteId();
            if (!(siteId === 0 || siteId === 1 || siteId === 100)) {
                const suffix =
                    config.get('commons:cal:CountryDiffCmdName') && Objpath.get(req.ebay.getSiteInfo(), 'locale-info.country') ||
                    config.get('commons:cal:IntlDiffCmdName') && 'INTL';
    
                if (suffix) {
                    // let's find the root transaction, the one we want to modify
                    // we do it here because all information we want to use happens in commons-ebay module
                    let parent = cal.createEvent().parent;
                    while(parent) {
                        if (!parent.parent) {
                            break;
                        }
                        parent = parent.parent;
                    }
                    if (parent.type === 'URL') {
                        const calPageName = `${parent.name}_${suffix}`;
                        // Add to context to use by OTEL for pagename
                        req.ebay.calPageName = calPageName;
                        parent.name = calPageName;
                    }
                }    
            }
            next();
        });
    });
}

module.exports = CommonsMiddleware;
