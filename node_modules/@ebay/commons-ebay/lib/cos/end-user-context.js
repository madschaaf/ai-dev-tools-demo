'use strict';

var AppContext = require('@ebay/app-context-ebay');

var hmvUtils = require('../header-multi-value'),
    upl = require('./user-physical-location-context'),
    ucl = require('./user-contextual-location'),
    oui = require('./original-user-id'),
    ui = require('./user-id'),
    utils = require('../request-utils'),
    urlHelper = require('url'),
    _ = require('underscore'),
    Assert = require('assert'),
    NodeUtil = require('util'),
    logger = require('@ebay/logging-inc').logger('commons-ebay/end-user-ctx'),
    CONST = {
        END_USER_CLIENT_ID: 'clientId',
        END_USER_ORIGINAL_CLIENT_ID: 'origClientId',
        END_USER_IP: 'ip',
        END_USER_AGENT_ACCEPT: 'userAgentAccept',
        END_USER_AGENT_ACCEPT_ENCODING: 'userAgentAcceptEncoding',
        END_USER_AGENT_ACCEPT_CHARSET: 'userAgentAcceptCharset',
        END_USER_AGENT: 'userAgent',
        END_USER_STARTING_POINT_URI: 'uri',

        /*
            Parameter: applicationURL
            To be set by the framework from application's http request;
                no getter/setter in the end user context class api;
            Description: The complete request URL being handled by
                the application that initiated a service invocation chain;
                this is similar to the uri element, except that this
                element will include scheme and hostname along
                with any query parameter information
        */
        END_USER_APPLICATION_URL: 'applicationURL',
        END_USER_PHYSICAL_LOCATION: 'physicalLocation',
        END_USER_CONTEXTUAL_LOCATION: 'contextualLocation',

        END_USER_ID: 'id',
        END_USER_ID_PROVIDER: 'idp',

        END_USER_REFERER: 'referer',
        END_USER_XFF: 'xff',

        END_USER_PROXIED: 'isProxied',
        END_USER_DEVICE_ID: 'deviceId',

        END_USER_ORIGINAL_ID: 'origUserId',

        /*
            Parameter: guessedUserId
            To be set by an application;
            Expose getter/setter in the end user context class api;
            Description:
                A public user id of an eBay user that MAY have initiated
                this service call chain. This id is derived as an estimate or
                a "best guess" based on identity attributes available to the
                producing point.
            Producing guessed user id:
                It is allowed to be set from an internal point only (within eBay data centers).
                An application or a service MAY compute and set a value
                    if no value has already been set.
                A service MUST NOT override a previously set value.
                A service MUST pass the value when calling another service thus
                    enabling forwarding of the value down the call graph.
                Consuming guessed user id: It MUST NOT replace or used
                    insted of an authenticated user id.
                It MUST NOT be used for request authorization.
                If authenticated user id is available in the request,
                    it takes precedence over the guessed user id for any aspect of
                    a service implementation (personalization, tracking, etc)
        */
        END_USER_GUESSED_USER_ID: 'guessedUserId',

        /*
            Param: guessedUserIdLegacy
            To be set by an application; expose getter/setter in the end user context class api;
            Description: A legacy user id (aka Oracle user id) of the guessed user id
        */
        END_USER_GUESSED_USER_ID_LEGACY: 'guessedUserIdLegacy',

        /*
            Param: expectSecureURL
              To be set by application or by the framework if an application did not set it:
            set to true if the application's request was served over HTTPS AND application
            did not set the value, otherwise set to false; expose getter/setter
            in the end user context class api;
              Description: End user application may request that URLs returned in
            the service response are defined with a secure variation of the URL scheme
            if such scheme is supported for the referred resource. For example, if http is
            a supported scheme, the end user app can request that URL is built
            with https scheme.
              The service MUST honor the request if the referred resouce supports the secure protocol.
        */
        END_USER_EXPECT_SECURE_URL: 'expectSecureURL',

        /*
            Parameter: deviceIdType
            To be set by an application; expose getter/setter in the end user context class api;
            Description: describes if the device id parameter is specified by value or
                by reference; applicable if deviceId parameter has been set.
                Allowed values are ID or IDREF;
        */
        END_USER_DEVICE_ID_TYPE: 'deviceIdType',
        END_USER_DEVICE_ID_TYPE_ENUM: ['ID', 'IDREF'],
        END_USER_FULLSITE_EXPERIENCE: 'fullSiteExperience',

        X_EBAY_C_IDENTITY: 'X-EBAY-C-IDENTITY',
        X_EBAY_C_ENDUSERCTX: 'X-EBAY-C-ENDUSERCTX',

        /**
         * Parameter: userId
         * UserId parameter will be populated with LightWeight a/c id and role
         * keys:
         *      acctId: Account Id of LightWeight
         *      acctRole: Role of the account (visitor/ppa/fpa)
         * e.g userId=acctId%3D1352137109%2CacctRole%3Dvisitor%2C
         */
        END_USER_USER_ID: 'userId',
        END_USER_IS_PIGGYBACKED: 'isPiggybacked',
        END_USER_ASAC_USER_ID: 'asacUserId',

        /**
         * As part of EU payments project, two new attributes have been added
         * https://jirap.corp.ebay.com/browse/NODE-3486
         */
        END_USER_SILENT_VERIFICATION_STATUS: 'svst',
        END_USER_SILENT_VERIFICATION_TIMESTAMP: 'svts',

        SEC_GPC: "sec-gpc",
    },
    HttpHeaders = {
        ACCEPT: 'Accept',
        ACCEPT_ENCODING: 'Accept-Encoding',
        ACCEPT_CHARSET: 'Accept-Charset',
        USER_AGENT: 'User-Agent'
    };

function getRequestURI(url) {
    var parsed = urlHelper.parse(url);
    return parsed.pathname;
}

/*
    Encodes URL parameters when needed. Returns relative or absolute URLs.
    '/here?a=1&a=$&a=%24' will become '/here?a=1&a=%24&a=%24'
*/
function sanitizeApplicationUrl(url = '/') {
    const dummyBaseUrl = 'https://www.ebay.com'; // ignored when the url is absolute
    const newUrl = new URL(url, dummyBaseUrl);
    newUrl.search = '';
    const newUrlParams = newUrl.searchParams;
    new URL(url, dummyBaseUrl).searchParams.forEach((value, name) => {
        newUrlParams.append(name, value);
    });

    let sanitizedUrl = url.substring(0, 1) === '/' ? newUrl.pathname + newUrl.search : newUrl.toString();

    // Truncate the URL to 1500 bytes if it exceeds the limit
    const byteLimit = 1500;
    if (Buffer.byteLength(sanitizedUrl, 'utf8') > byteLimit) {
        sanitizedUrl = Buffer.from(sanitizedUrl, 'utf8').slice(0, byteLimit).toString('utf8');
    }

    return sanitizedUrl;
}

function buildCtx(endUserContext) {
    var ctx = endUserContext.ctx = endUserContext.ctx || hmvUtils.create(),
        req = endUserContext.req;
    if (!ctx.get(CONST.END_USER_IP)) {
        ctx.set(CONST.END_USER_CLIENT_ID, AppContext.consumerId);
        ctx.set(CONST.END_USER_IP, utils.getRemoteAddr(req));
        ctx.set(CONST.END_USER_AGENT_ACCEPT, req.headers[HttpHeaders.ACCEPT] || req.headers[HttpHeaders.ACCEPT.toLowerCase()]);
        ctx.set(CONST.END_USER_AGENT_ACCEPT_ENCODING, req.headers[HttpHeaders.ACCEPT_ENCODING] || req.headers[HttpHeaders.ACCEPT_ENCODING.toLowerCase()]);
        ctx.set(CONST.END_USER_AGENT_ACCEPT_CHARSET, req.headers[HttpHeaders.ACCEPT_CHARSET] || req.headers[HttpHeaders.ACCEPT_CHARSET.toLowerCase()]);
        ctx.set(CONST.END_USER_AGENT, req.headers[HttpHeaders.USER_AGENT] || req.headers[HttpHeaders.USER_AGENT.toLowerCase()]);
        ctx.set(CONST.END_USER_STARTING_POINT_URI, getRequestURI(req.url));

        var identity = hmvUtils.parse(req.headers[CONST.X_EBAY_C_IDENTITY], false, true);
        ctx.set(CONST.END_USER_ID, identity.get(CONST.END_USER_ID));
        ctx.set(CONST.END_USER_ID_PROVIDER, identity.get(CONST.END_USER_ID_PROVIDER));

        if (!endUserContext.req.ebay.isService) {
            ctx.set(CONST.END_USER_APPLICATION_URL, sanitizeApplicationUrl(req.ebay.requestUrl));
            ctx.set(CONST.END_USER_REFERER, req.headers.referer);
            ctx.set(CONST.END_USER_XFF, req.headers['x-forwarded-for']);
            const adminUserId = req.ebay.getAdminUserId();
            ctx.set(CONST.END_USER_IS_PIGGYBACKED, !!adminUserId);
            if (adminUserId) {
                ctx.set(CONST.END_USER_ASAC_USER_ID, adminUserId);
            }

            // if sec-gpc header is present, then set the value in context
            if(req.headers[CONST.SEC_GPC]) {
                ctx.set(CONST.SEC_GPC, req.headers[CONST.SEC_GPC]);
            }
        }

        // if best guessed user id is not set, then set it
        if (!ctx.get(CONST.END_USER_GUESSED_USER_ID)) {
            ctx.set(CONST.END_USER_GUESSED_USER_ID, identity.get(CONST.END_USER_GUESSED_USER_ID));
        }
        ctx.set(CONST.END_USER_GUESSED_USER_ID_LEGACY, identity.get(CONST.END_USER_GUESSED_USER_ID_LEGACY));
        ctx.set(CONST.END_USER_EXPECT_SECURE_URL, identity.get(CONST.END_USER_EXPECT_SECURE_URL));
        ctx.set(CONST.END_USER_DEVICE_ID_TYPE, identity.get(CONST.END_USER_DEVICE_ID_TYPE));

        if (ctx.get(CONST.END_USER_EXPECT_SECURE_URL) === undefined) {
            ctx.set(CONST.END_USER_EXPECT_SECURE_URL, req.ebay.isSecure());
        }
    }
}

function EndUserContext(req) {
    // ignore header for frontend
    var header = req.ebay.isService ?
        (req.headers[CONST.X_EBAY_C_ENDUSERCTX] || req.headers[CONST.X_EBAY_C_ENDUSERCTX.toLowerCase()]) : {};

    this.req = req;
    this.ctx = hmvUtils.parse(header, false, true);

    this.userPhysicalLocation = tryParse(CONST.END_USER_PHYSICAL_LOCATION, function () {
        return upl.create(
            this.ctx.get(CONST.END_USER_PHYSICAL_LOCATION),
            req);
    }.bind(this)) || upl.create(null, req);

    this.userContextualLocation = tryParse(CONST.END_USER_CONTEXTUAL_LOCATION, function () {
        return ucl.create(
            this.ctx.get(CONST.END_USER_CONTEXTUAL_LOCATION),
            req);
    }.bind(this)) || ucl.create(null, req);

    var userOrigIdCtxStr = this.ctx.get(CONST.END_USER_ORIGINAL_ID);
    if (userOrigIdCtxStr) {
        this.origUserIdContext = tryParse(CONST.END_USER_ORIGINAL_ID, function () {
            return oui.create(
                userOrigIdCtxStr,
                req);
        }.bind(this));
    }

    this.userId = ui.create(this.ctx.get(CONST.END_USER_USER_ID), req);

    // For web request only. For service, context will have from above.
    const cfg = this.req.clientHintsConfig;
    if(!req.ebay.isService && cfg && cfg.isEnabled() === true) {
        // Chain Headers for End User Ctx
        const chChainHeaders = cfg.getCHChainHeaders() || [];
        for(let elem of chChainHeaders) {
            if(this.req.headers[elem]) {
                this.ctx.set(elem, this.req.headers[elem]);
            }
        }
    }

    this.req = req;
    buildCtx(this);
}

function tryParse(name, fn) {
    try {
        return fn();
    }
    catch (err) {
        logger.error('Failed to parse ' + name, err);
    }
}

EndUserContext.prototype = {
    getUserAgent: function() {
        return this.ctx.get(CONST.END_USER_AGENT);
    },

    isPiggybackedUser() {
        return this.ctx.get(CONST.END_USER_IS_PIGGYBACKED) === 'true';
    },

    getIPAddress: function() {
        return this.ctx.get(CONST.END_USER_IP);
    },

    getID: function() {
        return this.ctx.get(CONST.END_USER_ID);
    },

    getIdentityProvider: function() {
        return this.ctx.get(CONST.END_USER_ID_PROVIDER);
    },

    getDeviceId: function() {
        return this.ctx.get(CONST.END_USER_DEVICE_ID);
    },

    getUserAgentAcceptHeader: function() {
        return this.ctx.get(CONST.END_USER_AGENT_ACCEPT);
    },

    getUserAgentAcceptEncodingHeader: function() {
        return this.ctx.get(CONST.END_USER_AGENT_ACCEPT_ENCODING);
    },

    getUserAgentAcceptCharsetHeader: function() {
        return this.ctx.get(CONST.END_USER_AGENT_ACCEPT_CHARSET);
    },

    getStartingPointURI: function() {
        return this.ctx.get(CONST.END_USER_STARTING_POINT_URI);
    },

    getApplicationURL: function getApplicationURL() {
        return this.ctx.get(CONST.END_USER_APPLICATION_URL);
    },

    getClientHints: function getClientHints() {
        const cfg = this.req.clientHintsConfig;
        const chainClientHints = cfg && cfg.getCHChainHeaders() || [];

        let clientHints = {};
        if(chainClientHints) {
            for(let key of chainClientHints) {
                clientHints[key] = this.ctx.get(key);
            }
        }
        return clientHints;
    },

    getSecGpc: function getSecGpc() {
        return this.ctx.get(CONST.SEC_GPC);
    },

    isProxied: function() {
        if(!_.isBoolean(this.isProxied)){
            var value = this.ctx.get(CONST.END_USER_PROXIED);
            this.isProxied = value === 'true';
        }
        return this.isProxied;
    },

    getUserContextualLocation() {
        return this.userContextualLocation;
    },

    getUserPhysicalLocation() {
        return this.userPhysicalLocation;
    },

    getUserLocationContext: NodeUtil.deprecate(function() {
        return this.getUserPhysicalLocation();
    }, 'This method is deprecated, please use req.ebay.getUserPhysicalLocation'),

    getOriginalUserIdContext: function() {
        return this.origUserIdContext;
    },

    getUserIdContext: function() {
        return this.userId;
    },

    getReferer: function getReferer() {
        return this.ctx.get(CONST.END_USER_REFERER);
    },

    getXFF: function getXFF() {
        return this.ctx.get(CONST.END_USER_XFF);
    },

    getGuessedUserId: function getGuessedUserId() {
        return this.ctx.get(CONST.END_USER_GUESSED_USER_ID);
    },

    setGuessedUserId: function setGuessedUserId(guessedUserId, force) {
        if (this.getGuessedUserId()) {
            if (!force) {
                return;
            }
            logger.warn(new Error('Forcing to set guessed user id, which is against COS standard'));
        }
        return this.ctx.set(CONST.END_USER_GUESSED_USER_ID, guessedUserId);
    },

    getGuessedUserIdLegacy: function getGuessedUserIdLegacy() {
        return this.ctx.get(CONST.END_USER_GUESSED_USER_ID_LEGACY);
    },

    setGuessedUserIdLegacy: function setGuessedUserIdLegacy(userIdLegacy, force) {
        if (this.getGuessedUserIdLegacy()) {
            if (!force) {
                return;
            }
            logger.warn(new Error('Forcing to set guessed user id legacy, which is against COS standard'));
        }
        return this.ctx.set(CONST.END_USER_GUESSED_USER_ID_LEGACY, userIdLegacy);
    },

    getExpectSecureURL: function getExpectSecureURL() {
        var value = this.ctx.get(CONST.END_USER_EXPECT_SECURE_URL);
        return typeof value === 'string' ? value === 'true' : !!value;
    },

    setExpectSecureURL: function setExpectSecureURL(value) {
        Assert.ok(typeof value === 'boolean', 'Should be boolean value');
        return this.ctx.set(CONST.END_USER_EXPECT_SECURE_URL, value);
    },

    getDeviceIdType: function getDeviceIdType() {
        return this.ctx.get(CONST.END_USER_DEVICE_ID_TYPE);
    },

    setDeviceIdType: function setDeviceIdType(value) {
        if (value) {
            Assert.ok(CONST.END_USER_DEVICE_ID_TYPE_ENUM.indexOf(value) !== -1,
                'Should have one of the allowed values [ID, IDREF]');
        }
        return this.ctx.set(CONST.END_USER_DEVICE_ID_TYPE, value);
    },

    getAdminUserId() {
        return this.ctx.get(CONST.END_USER_ASAC_USER_ID);
    },

    buildHeader: function(filter) {
        this.ctx.set(CONST.END_USER_PHYSICAL_LOCATION, this.userPhysicalLocation.buildHeader());
        this.ctx.set(CONST.END_USER_CONTEXTUAL_LOCATION, this.userContextualLocation.buildHeader());

        // propagate deprecated clientId to origClientId when it is not already set
        if (!this.ctx.get(CONST.END_USER_ORIGINAL_CLIENT_ID)) {
            this.ctx.set(CONST.END_USER_ORIGINAL_CLIENT_ID, this.ctx.get(CONST.END_USER_CLIENT_ID));
        }

        // we update with origUserIdContext only if internal context value is not already set
        // https://jirap.corp.ebay.com/browse/NODE-2864
        // this is the place which caused the the issue despite oauth trying to set correct user/account ids
        // to this.ctx value, which were ignored
        if (!this.ctx.get(CONST.END_USER_ORIGINAL_ID) && this.origUserIdContext) {
            this.ctx.set(CONST.END_USER_ORIGINAL_ID, this.origUserIdContext.buildHeader());
        }

        if (this.userPrefersDesktopExperience() !== undefined) {
            this.ctx.set(CONST.END_USER_FULLSITE_EXPERIENCE, this.userPrefersDesktopExperience());
        }
        // still not set, use context value
        if (!this.ctx.get(CONST.END_USER_GUESSED_USER_ID)) {
            try {
                this.ctx.set(CONST.END_USER_GUESSED_USER_ID, this.req.ebay.getBestUserId());
            }
            catch (err) {
                logger.warn('Failed to get best guessed user id', err);
            }
        }

        const tokenAttrs = this.req.ebay.isService && this.req.security && this.req.security.getTokenAttributes();
        if (tokenAttrs &&
            tokenAttrs.tokenShieldVerificationStatus !== undefined &&
            tokenAttrs.tokenShieldVerificationTime !== undefined
        ) {
            this.ctx.set(CONST.END_USER_SILENT_VERIFICATION_STATUS, tokenAttrs.tokenShieldVerificationStatus);
            this.ctx.set(CONST.END_USER_SILENT_VERIFICATION_TIMESTAMP, tokenAttrs.tokenShieldVerificationTime);
        }

        let userIdKV = this.userId.buildHeader();
        if(userIdKV && !this.ctx.get(CONST.END_USER_USER_ID)) {
            this.ctx.set(CONST.END_USER_USER_ID, userIdKV);
        }

        let euctx = this.ctx.toString(filter);
        return euctx;
    },

    update: function(outboundContext, filter) {
        outboundContext[CONST.X_EBAY_C_ENDUSERCTX] = this.buildHeader(filter);
    },

    userPrefersDesktopExperience: function() {
        if (this.req && this.req.query && this.req.query.redirect && this.req.query.redirect === 'mobile') {
            return true;
        }

        if (this.req && this.req.ebay && this.req.ebay.cookies && /Y/i.test(this.req.ebay.cookies.getCookieValue('_fsom'))) {
            return true;
        }

        return;
    }
};

module.exports.create = function(req) {
    return new EndUserContext(req);
};

module.exports.CONST = CONST;
module.exports.sanitizeApplicationUrl = sanitizeApplicationUrl;
