const objPath = require('object-path');
const debug = require('debug')('service-security-ebay:token-utils');

const SecurityError = require('../errors').SecurityError;
const ErrorCategory = require('@ebay/errors-ebay/errors').ErrorCategory;
const utils = require('./utils');
const cache = require('./cache');
const validateToken = require('./validate-token');
const assertScopes = require('./assert-scopes');

const loadConfig = require('util').promisify(require('@ebay/module-config-inc'));
const { parse } = require('@ebay/iaf-ebay');
const {
    validateRequestUserToken
} = require('./validate-user-token');
const logger = require('@ebay/logging-inc').logger('service-security-ebay/token-utils');

module.exports.loadToken = require('./load-token');
module.exports.validateTokenAndGetAttributes = require('./validate-token');

module.exports.extractToken = function extractToken(req) {
    const authorization = req.headers && req.headers.authorization;

    if (/^bearer /i.test(authorization)) {
        debug('token extracted', authorization);
        return authorization.substring('bearer '.length);
    }
    debug('token is not found in headers');

    throw new SecurityError({
        message: 'token is missing in the header',
        type: 'bad-token',
        category: ErrorCategory.USER,
        statusCode: 403
    });
};

module.exports.getRouteScopes = function getRouteScopes(req, policyName) {
    const route = req.route;

    const security = objPath.get(route, ['security', 0]);

    if (!security) {
        debug('no security for the route', req.path);
        return;
    }

    return security[policyName];
};

module.exports.loadAttributesFromCache = function loadAttributesFromCache(token) {
    const key = utils.checksum(token);
    const attrs = cache.get(key);
    const value = attrs && attrs.expirationDate && attrs.expirationDate > Date.now() ?
        { attributes: attrs } : undefined;

    debug('attributes from cache', value);
    return value;
};

module.exports.putAttributesToCache = function putAttributesToCache(token, data) {
    // if it came from validate attributes, then we need to store it into cache
    if (token) {
        const key = utils.checksum(token);
        cache.set(key, data.attributes);
        debug('putting attributes to cache', data.attributes);
    }
    return data;
};

module.exports.validateScopes = function validateScopes(routeScopes, tokenAttributes) {
    /**
     * 1. get token scopes
     * 2. get route scopes
     * 3. compare/validate
    */
    let tokenScopes = objPath.get(tokenAttributes, 'attributes.attributes.scope');
    tokenScopes = tokenScopes && tokenScopes.split(' ');
    // now validate it
    assertScopes(routeScopes, tokenScopes);
};

module.exports.validateCompoundScopes = function validateCompoundScopes(routeScopes, tokenAttributes) {
    /**
     * 1. get token scopes
     * 2. get route scopes
     * 3. compare/validate
     */
    let tokenScopes = objPath.get(tokenAttributes, 'attributes.attributes.scope');
    tokenScopes = tokenScopes && tokenScopes.split(' ');
    // now validate it
    assertScopes.assertCompoundScopes(routeScopes, tokenScopes);
};

module.exports.getTokenDetails = async function getTokenDetails(req) {
    const tokenRaw = module.exports.extractToken(req);
    debug('raw token:', tokenRaw);
    const tokenMeta = parse(tokenRaw);

    const config = await loadConfig(__dirname);
    const enableUserTokenSessionManagement = config.get('service-security-ebay:usertokensessionmgmt') || false;
    const attributes = (enableUserTokenSessionManagement && tokenMeta.isByReference()) ?
        await validateRequestUserToken(req) :
        await (async () => {
            const enforceJwtJweTokens = config.get('service-security-ebay:enforceJwtJweTokens') || false;
            if (enforceJwtJweTokens && !tokenRaw.startsWith('ey')) {
                const err = new Error('Token is not JWT or JWE. Please use the JWT or JWE token.');
                logger.error(err.message);
                throw err;
            }
            const token = await module.exports.loadToken(tokenRaw);
            // eslint-disable-next-line no-shadow
            const attributes = module.exports.loadAttributesFromCache(token) ||
                await module.exports.validateTokenAndGetAttributes(token);
            debug('token attributes:', attributes);
            module.exports.putAttributesToCache(token, attributes);
            return attributes;
        })();

    // validate to make sure public user token is not used to sneak other user in via end-user-context
    if (attributes.attributes.domain === 'EBAYUSER' && req.ebay && req.ebay.getEndUserContext) {
        const ectx = req.ebay.getEndUserContext();
        if (ectx.getOriginalUserIdContext() !== undefined) {
            const err = new Error('Unauthorized');
            logger.error('The incoming request has origUserId and public user token', err);
            throw Object.assign(err, {
                code: 403
            });
        }
    }

    // AXIS-19218(raptor-core-auth-component PR#206): handle the FGQL use case
    let scope = attributes && attributes.attributes && attributes.attributes.attributes
        && attributes.attributes.attributes.scope;
    if (scope) {
        const scopeValue = scope.split(' ');
        const gatewayScopes = config.get('identity-context-ebay:gateway-scopes');

        if (scopeValue.some(str => gatewayScopes.includes(str))) {
            const identityContext = req && req.headers && req.headers[config.get('identity-context-ebay:header-name')];
            const claims = identityContext && await validateToken.validateIdCtxHeaderAndGetAttributes(identityContext);

            if (claims) {
                const originalScopes = claims.scope;
                const subject = claims.sub;

                const existingScopes = new Set(scopeValue);
                for (const originalScope of originalScopes.split(' ')) {
                    if (!existingScopes.has(originalScope)) {
                        scope += ` ${originalScope}`;
                    }
                }
                attributes.attributes.attributes.scope = scope;
                attributes.attributes.attributes.originalSubject = subject;
            }
        }
    }

    return attributes;
};
