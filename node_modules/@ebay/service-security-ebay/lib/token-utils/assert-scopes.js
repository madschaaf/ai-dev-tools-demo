'use strict';

const _ = require('underscore');
const SecurityError = require('../errors').SecurityError;
const debug = require('debug')('service-security-ebay:token-utils:assert-scopes');

module.exports = function assertScopes(routeScopes, tokenScopes) {
    /**
     * 1) Check that scopes from token is subset of scopes assigned to service operation
     *
     * Error cases
     * 1) If scopesAssignedToServiceOperation is empty - Grant access
     * 2) If token attributes doesn't contain scope throw exception
     * 3) Throw exception if any of the required scopes are not in token scope
     */

    if (!routeScopes || !routeScopes.length) {
        return;
    }

    // Support FGQL as gateway to pass through dynamic scopes for SubGraphs
    if (routeScopes && routeScopes.length === 1 && routeScopes[0] === '') {
        return;
    }

    debug('asserting scopes, routeScopes: %s, tokenScopes: %s', routeScopes, tokenScopes);

    if (!tokenScopes || !tokenScopes.length) {
        throw new SecurityError({
            message: `Required scope is missing in the token, required: ${routeScopes}`,
            type: 'bad-scope'
        });
    }

    const similarScopes = _.intersection(routeScopes, tokenScopes);
    if (routeScopes.length > similarScopes.length) {
        throw new SecurityError({
            message: `Scopes are missing in the token: ${_.difference(routeScopes, similarScopes)}`,
            type: 'bad-scope'
        });
    }
};

/**
 * Validates that token scopes satisfy at least one of the route scope conditions.
 * Supports compound scopes using the "&" operator, where all parts must be present.
 *
 * @param {Array<string>} routeScopes - Array of scope conditions. Each condition can be:
 *                                      - A simple scope string (e.g., "public")
 *                                      - A compound scope string (e.g., "buy&user")
 * @param {Array<string>} tokenScopes - Array of scopes from the authentication token
 * @throws {SecurityError} If token scopes are empty or don't satisfy any route scope condition
 * @example
 * // Simple scope validation - passes if token has "public"
 * assertCompoundScopes(["public"], ["public", "user"]);
 *
 * // Compound scope validation - passes if token has both "buy" AND "user"
 * assertCompoundScopes(["buy&user"], ["buy", "user"]);
 *
 * // Multiple conditions - passes if token satisfies ANY condition
 * assertCompoundScopes(["public", "buy&user"], ["buy", "user"]);
 * // First condition ("public") fails as token lacks "public" scope
 * // Second condition ("buy&user") passes as token has both "buy" AND "user" scopes
 * passes because second condition is satisfied
 */
function assertCompoundScopes(routeScopes, tokenScopes) {
    if (!routeScopes || !routeScopes.length) {
        return;
    }

    debug('asserting compound scopes, routeScopes: %s, tokenScopes: %s', routeScopes, tokenScopes);
    if (!tokenScopes || !tokenScopes.length) {
        throw new SecurityError({
            message: `Required scope is missing in the token, required at least one of: ${routeScopes}`,
            type: 'bad-scope'
        });
    }

    // Convert tokenScopes to Set for faster lookups
    const tokenScopesSet = new Set(tokenScopes);

    // Check if any routeScope condition is satisfied
    const satisfiedScope = routeScopes.some(scope => {
        if (scope.includes('&')) {
            // For compound scopes like "a&b", all parts must be present
            const parts = scope.split('&');
            return parts.every(part => tokenScopesSet.has(part));
        }
        // For simple scopes, just check if present
        return tokenScopesSet.has(scope);
    });

    if (!satisfiedScope) {
        throw new SecurityError({
            message: `Token must satisfy at least one of these scope conditions: ${routeScopes}`,
            type: 'bad-scope'
        });
    }
}

module.exports.assertCompoundScopes = assertCompoundScopes;
