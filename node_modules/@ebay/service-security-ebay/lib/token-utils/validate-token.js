'use strict';

const {
    decodeProtectedHeader,
    importPKCS8,
    jwtDecrypt
} = require('jose');
const jws = require('jws');
const Config = require('./esams');
const Iaf = require('@ebay/iaf-ebay').iaf;
const loadConfig = require('util').promisify(require('@ebay/module-config-inc'));

const SIGNATURE_CHANNEL = 'site.iaf.signature.keypair';

function authenticateToken(options) {
    return new Promise((resolve, reject) => {
        Iaf.authenticateToken(options, (err, token, attributes) => {
            if (err) {
                return reject(err);
            }
            resolve({
                token,
                attributes
            });
        });
    });
}

/**
 * @callback returns token
*/
module.exports = async function validateTokenAndGetAttributes(token) {
    // check if token is jwt
    if (token.startsWith('ey')) {
        return module.exports.validateJwtTokenAndGetAttributes(token);
    }
    const config = await Config.getConfig();
    const tokenInfo = await module.exports.authenticateToken({
        consumerId: config.consumerId,
        secret: config.secret,
        targetService: '',
        token
    }).catch(err => err);

    if (tokenInfo instanceof Error) {
        const err = tokenInfo;
        if (err.code === 'bad-token') {
            return module.exports.authenticateToken({
                consumerId: config.consumerId,
                secret: config.secret,
                targetService: 'ScopedToken',
                token: token
            });
        }
        throw err;
    }

    return tokenInfo;
};

async function validateJweTokenAndGetAttributes(token) {
    const header = decodeProtectedHeader(token);

    const privateKeyHolder = await Config.getPrivateKey(header.key, header.ver);
    const privateKey = await importPKCS8(privateKeyHolder.encodedPrivateKey, privateKeyHolder.algorithm);
    // Decrypt the token
    const result = await jwtDecrypt(token, privateKey);

    // The result object contains the decrypted content
    const payload = result.payload;
    return {
        token: `${payload.Domain}/${payload.sub}`,
        attributes: {
            expirationDate: payload.exp * 1000,
            domain: payload.Domain,
            accountId: undefined,
            userId: payload.client_id,
            attributes: {
                ScopePolicy: payload.Policy,
                ClientType: payload.ClientType,
                AppId: payload.AppId,
                scope: payload.scope || payload.scopes,
                appid: payload.appid,
                iss: payload.iss,
                AppImmutableId: payload.AppImmutableId,
                DevId: payload.DevId,
                iat: String(payload.iat),
                client_id: payload.client_id,
                jwt: payload
            }
        }
    };
}

function validateJwtTokenAndGetAttributes(token) {
    const tokenCount = token.split('.');
    if (tokenCount.length === 5) {
        // this is JWE token
        return validateJweTokenAndGetAttributes(token);
    }
    return validateJwsTokenAndGetAttributes(token);
}

async function validateJwsTokenAndGetAttributes(token) {
    const jwt = jws.decode(token);
    if (!jwt) {
        throw Object.assign(new Error(`Invalid token, decoding failed.`), {
            statusCode: 403
        });
    }

    const algorithm = jwt.header.alg;
    const version = jwt.header.ver;
    jwt.payload = JSON.parse(jwt.payload);

    const certificate = await Config.getCertificate(SIGNATURE_CHANNEL, version);

    if (!jws.verify(token, algorithm, certificate.publicKey)) {
        throw new Error(`Invalid token, signature verification failed.`);
    }

    const payload = jwt.payload;
    return {
        token: `${payload.Domain}/${payload.client_id}`,
        attributes: {
            expirationDate: payload.exp * 1000,
            domain: payload.Domain,
            accountId: undefined,
            userId: payload.client_id,
            attributes: {
                ScopePolicy: payload.ScopePolicy,
                ClientType: payload.ClientType,
                AppId: payload.AppId,
                scope: payload.scope,
                appid: payload.appid,
                iss: payload.iss,
                AppImmutableId: payload.AppImmutableId,
                DevId: payload.DevId,
                iat: String(payload.iat),
                client_id: payload.client_id,
                jwt: payload
            }
        }
    };
}

async function validateIdCtxHeaderAndGetAttributes(idCtxHeader) {
    const jwt = jws.decode(idCtxHeader);
    if (!jwt) {
        throw Object.assign(new Error(`Invalid IdCtxHeader, decoding failed.`), {
            statusCode: 403
        });
    }
    const algorithm = jwt.header.alg;
    const version = jwt.header.ver;

    const config = await loadConfig(__dirname);
    const unixTimestamp = Math.floor(Date.now() / 1000);
    const isExp = (unixTimestamp - jwt.payload.exp || 0)
        >= config.get('identity-context-ebay:allowed-clock-skew-seconds');
    if (isExp) {
        throw new Error(`Invalid IdCtxHeader, expired.`);
    }

    const certificate = await Config.getCertificate(SIGNATURE_CHANNEL, version);
    if (!jws.verify(idCtxHeader, algorithm, certificate.publicKey)) {
        throw new Error(`Invalid IdCtxHeader, signature verification failed.`);
    }

    return jwt.payload;
}

module.exports.SIGNATURE_CHANNEL = SIGNATURE_CHANNEL;
module.exports.validateJwtTokenAndGetAttributes = validateJwtTokenAndGetAttributes;
module.exports.validateJweTokenAndGetAttributes = validateJweTokenAndGetAttributes;
module.exports.validateJwsTokenAndGetAttributes = validateJwsTokenAndGetAttributes;
module.exports.validateIdCtxHeaderAndGetAttributes = validateIdCtxHeaderAndGetAttributes;
module.exports.authenticateToken = authenticateToken;
