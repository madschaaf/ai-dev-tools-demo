'use strict';

/* Delivers heartbeats to CAL for PERFMON. It is triggered
 * every time monitor-inc sends data to Sherlock. Normally,
 * this will be once per minute. Data values mostly derive
 * from the metrics being reported by monitor-inc to Sherlock.
* For now, the AutoStresser tool can only monitor CAL heartbeats
* and not Sherlock so we must log the same metrics to two places.
*/

// Node heaps can get a bit larger (around 1.4GB) but monitor-inc
// will restart the process if 1.2GB is exceeded as using up the
// last bit of heap leads to excessive GCing and little work getting done.
var MAX_NODE_MEM = 1.2e9;  // 1.2GB

var cal = require('@ebay/cal'),
    os = require('os'),
    freemem,
    cpu,
    lastStats = {cpu: 0};

// Event triggered by monitor-inc
// Note: If monitor-inc is not present, no heartbeats will be
// emitted to CAL. A separate interval timer could be added
// here to deal with this but hopefully monitor- will be on.
process.on('monitorStats', function (stats) {
    lastStats = stats;
    // monitor-inc sends heap_used in KBs. *1000 gives us bytes again
    // (1.2GBbytes - heap_used in bytes) = remaining bytes free
    // Perfmon expects jvmMemAvailable to be in bytes
    freemem = MAX_NODE_MEM - (stats.heap_used*1000);
    cpu = Math.round(isNaN(stats.cpu) ? 0 : stats.cpu);
    var upHrs = process.uptime() / 3600;

    // For Traffic Mirror, change perfmon to perfmon_tm for metrics isolation.
    const perfmon = (process.env.TRAFFIC_MIRROR === '1' ||  process.env.TRAFFIC_MIRROR === 'true')? 'PerfMon_TM' : 'PerfMon';

    var hb = cal.createHeartbeat(perfmon, 'OS');
    hb.addData('cpuUsage', cpu);
    hb.addData('jvmCpuUsage', cpu);
    hb.addData('jvmMemoryUsed', stats.heap_used*1000);
    hb.addData('jvmMemAvail', freemem);
    hb.addData('jvmMemTotal', MAX_NODE_MEM);
    hb.addData('jvmVirtualBytes', MAX_NODE_MEM);
    hb.addData('osName', os.type());
    hb.addData('appServer', 'node ' + process.version);
    hb.addData('jdk','64');
    hb.addData('numProcessors', os.cpus().length);
    hb.addData('serverUpHrs', upHrs);
    hb.complete();

    hb = cal.createHeartbeat(perfmon, 'GC');
    hb.addData('gccount', stats.gc_count);
    // Convert percentage value to integer (.05 -> 5) to match expected form
    hb.addData('gcovhdx10', Math.round(stats.gcInterval*100));
    hb.complete();

    hb = cal.createHeartbeat(perfmon, 'THREAD');
    hb.addData('appserverBusyThreads', stats.noWorkers);
    hb.complete();

    hb = cal.createHeartbeat(perfmon, 'TPS');
    hb.addData('tps', Math.round(stats.tps));
    hb.addData('transactionTime', Math.round(stats.urlTime ? stats.urlTime.toFixed(2) : 0));
    hb.addData('javaCpuTime', cpu);
    // the fallback from errorCount to eps is temporary for backwards compatibility due to dependency on
    // monitor-inc module, TODO: if you are working on this module, you can remove Math.round(stats.eps) from
    // the bleow statement
    hb.addData('errorCount', stats.errorCount || Math.round(stats.eps) || 0);
    hb.addData('oomErrorCount', stats.oomError || 0);
    hb.complete();

    hb = cal.createHeartbeat(perfmon, 'RESTARTS');
    hb.addData('restartCount', stats.restarts || 0);
    hb.complete();

    hb = cal.createHeartbeat(perfmon, 'HttpStatusMetrics');
    hb.addData('m:resSecs', 60);
    hb.addData('g:4XXCount', stats.http4XX);
    hb.addData('g:unknownStatusCode', 0);
    hb.addData('g:3XXCount', stats.http3XX);
    hb.addData('g:2XXCount', stats.http2XX);
    hb.addData('g:5XXCount', stats.http5XX);
    hb.complete();

    hb = cal.createHeartbeat(perfmon, 'SecurityViolation');
    hb.addData('csrf', stats.csrf || 0);
    hb.addData('redirect', stats.redirect || 0);
    hb.addData('csp', stats.csp || 0);
    hb.addData('xss', stats.xss || 0);
    hb.complete();
});

module.exports.getMetrics = function getMetrics() {
    return lastStats;
};
