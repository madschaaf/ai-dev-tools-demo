'use strict';

// TODO Need to validate that request originates within eBay and for update
// command that the IP is allowed to issue config updates.

var defaultComponents = require('./default-components'),
    renderers = require('./renderers'),
    express = require('express'),
    path = require('path'),
    fs = require('graceful-fs'),
    _ = require('underscore'),
    configBean = require('@ebay/config-bean-ebay'),
    hostipChecker = require('@ebay/hostip-checker-ebay'),
    cal = require('@ebay/cal'),
    util = require('util'),
    ProfilerProvider = require('./profiler'),
    metaModel = require('@ebay/meta-inc/lib/metaModel'),
    dependencyTreeModel = require('@ebay/meta-inc/lib/dependencyTree'),
    path = require('path'),
    utils = require('@ebay/utils-ebay'),
    ViUtils = require('./utils.js'),
    Prxy = require('./proxy'),
    urllib = require('url');

const rlogIdGenerator = require('@ebay/utils-ebay/lib/rlogid-generator');
var url = require('url');
const allowView = ViUtils.allowView;
const os = require('os');
const interfaces = os.networkInterfaces();
const localMachineAddresses = Object.keys(interfaces)
    .reduce((results, name) => results.concat(interfaces[name]), [])
    .filter((iface) => iface.family === 'IPv4' && !iface.internal)
    .map((iface) => iface.address);

const env = require('@ebay/environment-ebay');

// Initialize default components for SiteValidator
var componentStatus = require('./component-status.js');
defaultComponents.initSiteValidatorComponents();

const appLogFolder = path.join(process.cwd(), './logs');
const DISCOVERY_JSON_FILE = '.discovery.json';
const DISCOVERY_JSON_PATH = path.join(process.cwd(), '.cache/' + DISCOVERY_JSON_FILE);
const envoyLogFolder = `${process.env.CRONUSAPP_HOME}/manifests/active/Envoy/cronus/scripts/log`;
const nodeAgentLogFolder = `${process.env.CRONUSAPP_HOME}/manifests/active/NodeAgent/cronus/scripts/logs`;
var memoryDumpState;
var cpuProfileInProgress;

var CHANNEL_STATUS = {
    0: 'INITIAL_MARK_DOWN',
    1: 'MARK_UP',
    2: 'OPS_MARK_DOWN',
    3: 'OPS_EXTERNAL_PERSIS_MARK_DOWN',
    4: 'APP_AUTO_MARK_DOWN'
};

// Allow ECV requests and assume ready for traffic
//TODO is there a better place to do this where we know things
// are truly ready?
componentStatus.enableComponentStatus();

var monApp = module.exports = express();

const {
    platformMetrics,
    applicationMetrics,
    namespaces
} = require('@ebay/prometheus-ebay');

const viMetricsCounter = platformMetrics.createCounter(
    'vi_requests_total',
    'VI Requests for HTTP and HTTPS',
    ['protocol']
);

const trustfabricComponent = require('./trustfabric-components');

// Setup static resource serving for js, css, images, xsl
monApp.use('/js', express.static(path.join(__dirname, './public/scripts')));
monApp.use('/css', express.static(path.join(__dirname, './public/stylesheets')));
monApp.use('/v3console/resources/xsl', express.static(path.join(__dirname, './public/transforms')));
monApp.use('/images/vi', express.static(path.join(__dirname, './public/images')));
monApp.use('/css/smoothness/images', express.static(path.join(__dirname, './public/images')));
monApp.use('/hystrix', require('./hystrix'));

monApp.engine('.ejs', require('ejs').__express);
monApp.set('views', path.join(__dirname, './public/views'));
monApp.set('view engine', 'ejs');
monApp.use(require('body-parser').urlencoded({
    extended: true
}));

monApp.use((req, res, next) => {
    // x-forwarded-proto is set by envoy
    const protocol = req?.headers?.['x-forwarded-proto'] || 'http';
    viMetricsCounter.inc({ protocol });
    next();
});

// Routes supported by ValidateInternals
monApp.get('/v3console/ValidateInternals(2)?', function (req, res) {
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ValidateInternals', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    if (proxyIfRequested(req, res)) {
        return;
    }
    logEvent(req, res, 'ValidateInternals');

    var component = req.query.component,
        view = req.query.view;

    //if component, go to component status, otherwise show the index page
    if (!component || component === 'hostInformation' ||
        component === 'hostinformation' || component === 'Host Information') {
        renderers.renderDefaultComponentStatus(req, res);
    } else if (component === 'Troubleshooting Info') {
        renderers.renderTroubleshooting(req, res);
    } else if (component === 'Envoy Info') {
        renderers.renderEnvoyInfo(req, res);
    } else if (component === 'Environment Properties') {
        renderers.renderEnvironmentProperties(req, res);
    } else if (component === 'serviceclientstatus' || component === 'Service Client') {
        renderers.renderServiceComponentsTree(req, res);
    } else if (!_.contains(componentStatus.getComponents(), component)) {
        if (component) {
            // Replace any string that matches the regex with a space
            component = component.replace(stringParameterVectors, ' ');
        }
        res.status(404).send('no such component ' + component);
    } else if (component === 'Global Config Status') {
        renderers.renderComponentStatusByTemplate('global-config-status', req, res);
    } else if (component === 'CookieStats' || component === 'CookieletStats') {
        renderers.renderCookieCookieletComponent('cookie-cookielet-statistics-view', req, res);
    } else if (component === 'Fire Marshal Policy') {
        renderers.renderFireMarshalPolicy(req, res);
    } else {
        renderers.renderComponentStatus(req, res);
    }

});

monApp.get('/v3console/ViewConfigCategoryList', function (req, res) {
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ViewConfigCategoryList', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    if (proxyIfRequested(req, res)) {
        return;
    }
    logEvent(req, res, 'ViewConfigCategoryList');
    renderers.renderConfigCategoryList(req, res);
});

monApp.get(/^\/v3console\/ViewConfigCategory(Xml)?/, function (req, res) {
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ViewConfigCategoryXml', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    logEvent(req, res, 'ViewConfigCategoryXml');
    // Be sure all beans on disk are also reflected in memory. Some other
    // instance may have created one that we are unaware of and have no
    // file watch on yet.
    configBean.syncDiskBeans();
    renderers.renderConfigBean(req, res);
});

monApp.get(/^\/v3console\/UpdateConfigCategory(Xml)?/, updateConfigCategory);
monApp.post(/^\/v3console\/UpdateConfigCategory(Xml)?/, updateConfigCategory);

function updateConfigCategory(req, res) {
    try {
        // Validate TF Token for Update Configs
        trustfabricComponent.validate(req, res, () => {
            assertUpdate(req);
        });
    }
    catch (err) {
        logErrorEvent(req, res, 'UpdateConfigCategory', err.message);
        res.status(403).send(err.message);
        return;
    }

    if (proxyIfRequested(req, res)) {
        return;
    }

    var query = req.query,
        id = query.id,
        clear = query.clear,
        value = _.omit(query, 'id', 'forceXml', 'clear');

    var bean = configBean.getBeanById(id);
    if (!bean) {
        res.status(404).send('no such configbean ' + id);
    } else {
        // For multiple node instances. Force this instance
        // to load all beans just to be sure we have them all and have
        // file watchers on them.
        configBean.syncDiskBeans();
        var upd = cal.createHeartbeat('UPDATE_VI', id);
        if (clear === 'true') {
            upd.addData('resetBean', id);
            bean.reset();

        } else {
            // Set possibly multiple changed values
            for (var name in value) {
                var keyval = value[name];
                if (name === 'SVC_CHANNEL_STATUS' && CHANNEL_STATUS[keyval]) {
                    keyval = CHANNEL_STATUS[keyval];
                }
                var result = bean.set(name, keyval); //set new value
                upd.addData('prop', name);
                upd.addData('value', keyval);
                upd.addData('oldValue', result);
                upd.complete();

                // Create a CAL event for the update
                logUpdateEvent(req, id, name, keyval, result, res);

                if (result instanceof Error) {
                    logErrorEvent(req, res, 'UpdateConfigCategory', result);
                    res.status(403).send(result);
                    upd.complete();
                    return;
                }
            }
        }
        upd.complete();
        renderers.renderConfigBean(req, res); //redisplay changed bean
    }
}


monApp.get('/v3console/ComponentStatus(List)?', function (req, res) {
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ComponentStatusList', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    if (proxyIfRequested(req, res)) {
        return;
    }

    logEvent(req, res, 'ComponentStatusList');

    renderers.renderComponentStatusList(req, res);
});

let createDiscoveryLink = () => {
    return new Promise((resolve, reject) => {
        fs.stat(DISCOVERY_JSON_PATH, (err, stats) => {
            if (err) {
                resolve([]);
            } else {
                resolve([{
                    'text': DISCOVERY_JSON_FILE,
                    'link': './logs?logfile=' + DISCOVERY_JSON_FILE,
                    'mtime': stats.mtime,
                    'size': stats.size
                }]);
            }
        });
    });
};

let readDir = function (folder, prefix = '') {
    return new Promise((resolve, reject) => {
        fs.readdir(folder, (err, files) => {
            if (files) {
                try {
                    let logs = files.map(function (file) {
                        let stats = fs.statSync(path.join(folder, file));
                        return {
                            'text': prefix ? prefix + "/" + file : file,
                            'link': './logs?logfile=' + prefix + file,
                            'mtime': stats.mtime,
                            'size': stats.size
                        };
                    });
                    resolve(logs);
                } catch (e) {
                    reject(e);
                }
            } else {
                resolve([]);
            }
        });
    });
};

monApp.get('/v3console/logs', function (req, res) {
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ViewLogs', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    logEvent(req, res, 'ViewLogs');
    let logfile = req.query.logfile;
    if (!logfile) {
        Promise.all([
            readDir(appLogFolder),
            createDiscoveryLink(),
            (ViUtils.isEnvoyEnabled() && readDir(envoyLogFolder, 'envoy/')) || true,
            (ViUtils.isEnvoyEnabled() && readDir(nodeAgentLogFolder, 'nodeagent/')) || true,
        ]).then(logs => { //array of arrays
            if (logs && logs.length > 0) {
                res.type('html').render('line-reader', {
                    'links': [].concat.apply([], logs)
                });
            } else {
                res.type('text').send("No log files found");
            }
        }).catch((e) => {
            res.type('text').send("No log files found : " + e);
        });
    } else {
        let logFolder = appLogFolder;
        if (logfile.indexOf('envoy/') > -1) {
            logFolder = envoyLogFolder;
        } else if (logfile.indexOf('nodeagent/') > -1) {
            logFolder = nodeAgentLogFolder;
        }
        //Use only real file name and strip any directories
        logfile = path.basename(logfile);
        let logpath = path.join(logFolder, logfile);
        if (logfile === DISCOVERY_JSON_FILE) {
            logpath = DISCOVERY_JSON_PATH;
        }
        fs.exists(logpath, function (exists) {
            if (exists) {
                const rstream = fs.createReadStream(logpath);
                rstream.pipe(res);
            } else {
                res.send("Log file does not exist:" + logfile);
            }
        });
    }
});


monApp.get('/v3console/meta', function (req, res) {
    var model = {};
    // Get route/middleware stack from parent app as we are a subapp
    // Note: require must be done here rather than at top. Matter of timing.
    logEvent(req, res, 'ViewMeta');
    var parentApp = require('./index').getParentApp();
    req.routeStack = parentApp && parentApp._router && parentApp._router.stack;
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ViewMeta', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    metaModel.getModel(req, res, model, function (err, model) {
        res.setHeader('Cache-Control', 'no-cache');
        res.json(model);
    });
});

monApp.get('/v3console/modules', function (req, res) {
    var parentApp = require('./index').getParentApp();
    req.routeStack = parentApp && parentApp._router && parentApp._router.stack;
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ViewModules', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    logEvent(req,res, 'ViewModules');
    dependencyTreeModel.getDependencyTree(function (err, treePath) {
        if (err) {
            return res.send(err);
        }
        fs.createReadStream(treePath).pipe(res);
    });
});



monApp.get('/v3console/profile', function (req, res) {
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ViewProfileType', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    if (proxyIfRequested(req, res)) {
        return;
    }

    logEvent(req,res, 'ViewProfileType');

    var base = process.cwd() + '/logs';
    if (!fs.existsSync(base)) {
        fs.mkdirSync(base);
    }

    switch (req.query.type) {
        case 'cpu':
            if (!handleCpuProfileRequest(req, res)) {
                // in case profiling is in progress
                return;
            }
            break;
        case 'memory':
            handleMemoryProfileRequest(req);
            if (req.query.start === 'true') {
                res.redirect('profile?type=' + req.query.type);
                return;
            }
            break;
        case 'delete':
            // Handle profile file deletion
            var profilePath = process.cwd() + '/logs/' + req.query.file.replace('\/', '');
            if (fs.existsSync(profilePath)) {
                fs.unlink(profilePath, (err) => {
                    if (err) console.error('Error deleting file:', err);
                });
            }
            res.redirect('/admin/v3console/profile?type=' + req.query.redirectType);
            return;
        default:
            return res.status(400).send('Bad request');
    }

    renderers.renderProfilePage(req, res);
});
monApp.get('/v3console/servicehostlist', function (req, res) {
    var parentApp = require('./index').getParentApp();
    req.routeStack = parentApp && parentApp._router && parentApp._router.stack;
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'ServiceHostlist', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    logEvent(req,res, 'ServiceHostlist');
    var hostlist = getServiceHostList();
    res.setHeader('Cache-Control', 'no-cache');
    res.json(hostlist);
});

function getMetrics(namespace) {
    const anyMetrics = namespace && namespaces && namespaces[namespace];
    if (anyMetrics) {
        return anyMetrics;
    }
    // in case old version of prometheus is used
    if (namespace === 'platform') {
        return platformMetrics;
    }
}

monApp.get('/prometheus/:namespace', async function (req, res) {
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'Prometheus', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    if (proxyIfRequested(req, res)) {
        return;
    }

    logEvent(req,res, 'Prometheus');

    const namespace = req.params.namespace;
    const anyMetrics = getMetrics(namespace);
    if (!anyMetrics) {
        logErrorEvent(req, res, 'Prometheus', 'Requested metrics ${namespace} not found');
        res.status(404).send(`Requested metrics ${namespace} not found`);
        return;
    }

    if (namespace === 'platform' && !anyMetrics.isEnabled()) {
        logErrorEvent(req, res, 'Prometheus', 'Prometheus not enabled');
        res.status(403).send('Prometheus not enabled');
        return;
    }

    const promMetrics = req.headers['accept'] && req.headers['accept'].includes('application/openmetrics-text') ? await anyMetrics.readOpenMetrics() :  await anyMetrics.readPrometheusMetrics();
    res.set('Content-Type', promMetrics.contentType);
    res.end(promMetrics.metrics || '# No Custom Metrics Exists');
});


monApp.get('/prometheus', async function (req, res) {
    if (!allowView(req, res)) {
        logErrorEvent(req, res, 'Prometheus', 'ValidateInternals not allowed');
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    if (proxyIfRequested(req, res)) {
        return;
    }

    logEvent(req,res, 'Prometheus');

    const promMetrics = req.headers['accept'] && req.headers['accept'].includes('application/openmetrics-text') ? await applicationMetrics.readOpenMetrics() :  await applicationMetrics.readPrometheusMetrics();
    res.set('Content-Type', promMetrics.contentType);
    res.end(promMetrics.metrics || '# No Custom Metrics Exists');
});

function getServiceHostList() {
    var beanList = configBean.getConfigBeanList(),
        hostlist = [];
    beanList.forEach(function (name, cb) {
        var theBean = configBean.getBeanById(name);
        var attrs = theBean.getAttributes();
        if (attrs) {
            var url;
            var defaultUrl;
            var hostname;
            var status;
            status = theBean.get('SVC_CHANNEL_STATUS');
            // filer out only components that represent service by using SVC_CHANNEL_STATUS field as an indication of this
            if (status) {
                url = theBean.get('ENDPOINT_URL');
                defaultUrl = theBean.get('DEFAULT_ENDPOINT_URL');
                hostname = theBean.get('hostname');
                url = url || defaultUrl;
                if (url && url.indexOf('http') > -1) {
                    url = urllib.parse(url).hostname;
                }
                var host = url || defaultUrl || hostname;
                if (host && hostlist.indexOf(host) < 0) {
                    hostlist.push(host);
                }
            }
        }
    });
    return hostlist;
}

function handleMemoryProfileRequest(req) {
    var dumpsNumber = parseInt(req.query.dumps, 10) || 2;
    var intervalRequested = parseInt(req.query.interval, 10) || 10;
    var units = req.query.units || 'min';
    var start = req.query.start;
    var base = process.cwd() + '/logs';
    var workerId = ViUtils.getWorkerId();

    if (start === 'true') {
        var interval = intervalRequested * (units === 'hour' ? 3600000 : 60000);

        if (memoryDumpState && memoryDumpState.timer) {
            clearInterval(memoryDumpState.timer);
        }

        memoryDumpState = {
            requested: dumpsNumber,
            left: dumpsNumber,
            interval: intervalRequested,
            units: units,
            intervalMs: interval,
            lastDump: Date.now()
        };

        // trigger first dump
        periodicDump();
        // schedule next dump
        memoryDumpState.timer = setInterval(periodicDump, interval).unref();
    }

    if (memoryDumpState) {
        req.memoryDumpState = memoryDumpState;
        memoryDumpState.nextDump = memoryDumpState.lastDump + memoryDumpState.intervalMs - Date.now();
    }

    async function periodicDump() {
        memoryDumpState.left--;
        if (memoryDumpState.left <= 0) {
            clearInterval(memoryDumpState.timer);
            memoryDumpState.timer = undefined;
        }
        var ts = Date.now();
        var fileName = util.format('heapdump-%s-%s.heapsnapshot', ts, workerId);
        var heapdumpPath = base + '/' + fileName;
        const profiler = ProfilerProvider.getHeapProfiler();
        const snapshot = await profiler.takeSnapshot();
        snapshot.export()
            .pipe(fs.createWriteStream(heapdumpPath))
            .on('finish', function () {
                snapshot.delete();
            });
        memoryDumpState.lastDump = ts;
    }
}

function sleep(duration) {
    return new Promise(resolve => setTimeout(resolve, duration).unref());
}

function handleCpuProfileRequest(req, res) {
    var duration = req.query.duration;
    if (!req.query.file && duration && duration <= 120 && duration > 0) {
        if (cpuProfileInProgress) {
            res.status(403).send('CPU profiling is in progress');
            // signal we already handled response
            return false;
        }
        cpuProfileInProgress = true;
        var workerId = ViUtils.getWorkerId();

        var fileName = util.format('cpu-profile-%s-%s.cpuprofile', Date.now(), workerId);
        var base = process.cwd() + '/logs';
        if (!fs.existsSync(base)) {
            fs.mkdirSync(base);
        }
        var cpudumpPath = base + '/' + fileName;

        setTimeout(async function delayStart() {
            const profiler = ProfilerProvider.getCPUProfiler();
            const session = await profiler.startProfiling();
            await sleep(duration * 1000); //Convert to millisec
            cpuProfileInProgress = false;
            const profile = await session.stopProfiling();
            profile.export().pipe(fs.createWriteStream(cpudumpPath))
                .on('finish', function () {
                    profile.delete();
                });
        }, 500);

        req.query.file = fileName;
    } else {
        req.query.view = 'true';
    }

    return true;
}

function cleanIPV6(ip) {
    if (ip && /^::ffff:(\d{1,3}\.){3,3}\d{1,3}$/.test(ip)) {
        ip = ip.replace(/^::ffff:/, '');
    }
    return ip;
}

// Returns true if IP is internal and update is allowed, else false.
function assertUpdate(req) {
    //DO NOT ALLOW UPDATE if x-client-ip has multiple IP address as this header set only by Envoy
    //If multiple exists, it means someone is spoofing
    if (req.headers && req.headers['x-client-ip'] && req.headers['x-client-ip'].indexOf(',') > -1) {
        throw new Error(`A trusted header is being spoofed`);
    }

    const ip = ViUtils.isEnvoyEnabled() ? req.headers['x-client-ip'] : utils.getRemoteAddrFromTrustedHeader(req);
    if (env.isProd() && !ViUtils.isEnvoyEnabled()) {
        const connectionIp = cleanIPV6(req.ip);
        console.info(`Validating connection ip ${connectionIp} against client ip ${ip}`);
        if (ip !== connectionIp &&
            !(localMachineAddresses.includes(connectionIp) ||
                connectionIp === '127.0.0.1')) {
            throw new Error(`The original request IP address '${
                connectionIp}' must be the same as IP address '${
                ip}' obtained from trusted header.`);
        }
    }
    var chk = hostipChecker.checkIpSync(ip);
    if (chk.isInternal && chk.hasUpdate && !utils.isIPFromAkamaiHeader(req)) {
        console.info("Allowing VI update for ", ip, chk);
        return;
    } else if (localMachineAddresses.includes(ip)) {
        console.info("Allowing VI update for ", ip);
        return;
    }
    throw new Error(`The host with IP address ${ip} is not authorized for write access.`);
}

module.exports.$internals = {
    assertUpdate
};

function clientInfo(req, maskedPayload) {
    var headers = req.headers || {};
    maskedPayload = url.parse(maskedPayload).pathname;
    var scriptPath = '/' + maskedPayload.split('/')[1];

    var formatString = 'RemoteIP=%s&Server=%s&Script=%s&Encoding=%s&Agent=%s';
    var params = [utils.getRemoteAddr(req),
        'www.ebay.com',
        scriptPath,
        headers['accept-encoding'],
        headers['user-agent']
    ];

    if (headers.referer && headers.referer.trim()) {
        formatString += '&Referer=%s';
        params.push(headers.referer);
    }

    if(headers['x-forwarded-for']) {
        formatString += '&ForwardedFor=%s';
        params.push(headers['x-forwarded-for']);
    }

    params.unshift(formatString);
    return util.format.apply(util, params);
}

function logUpdateEvent(req, id, name, keyval, result, res) {
    cal.createTransaction('URL_ADMIN', 'UpdateConfigCategoryXml', async function (err, tx) {
        if (err) {
            console.error('Error creating CAL transaction', err);
            tx.complete();
        }
        // get req payload
        var reqUrl = req.originalUrl;
        var payload = url.parse(reqUrl).pathname;
        cal.createEvent('URL_ADMIN', 'ClientInfo', 0, clientInfo(req, payload)).complete();
        cal.createEvent('URL_ADMIN', 'Payload', 0, reqUrl).complete();

        var event = cal.createEvent('URL_ADMIN', 'Update');
        event.addData('Component', id);
        event.addData('Property', name);
        event.addData('NewValue', keyval);
        event.addData('OldValue', result);
        event.complete();
        await logRlogId(req, res, cal);

        tx.complete();
    });
}

function logEvent(req, res, name) {
    cal.createTransaction('URL_ADMIN', name, async function (err, tx) {
        if (err) {
            console.error('Error creating CAL transaction', err);
            tx.complete();
        }

        var reqUrl = req.originalUrl;
        var payload = url.parse(reqUrl).pathname;
        cal.createEvent('URL_ADMIN', 'ClientInfo', 0, clientInfo(req, payload)).complete();
        cal.createEvent('URL_ADMIN', 'Payload', 0, reqUrl).complete();
        await logRlogId(req, res, cal);

        tx.complete();
    });
}

function logErrorEvent(req, res, name, errMessage) {
    cal.createTransaction('URL_ADMIN', name, async function (err, tx) {
        if (err) {
            console.error('Error creating CAL transaction', err);
            tx.complete();
        }

        var reqUrl = req.originalUrl;
        var payload = url.parse(reqUrl).pathname;
        cal.createEvent('URL_ADMIN', 'ClientInfo', 0, clientInfo(req, payload)).complete();
        cal.createEvent('URL_ADMIN', 'Payload', 0, reqUrl).complete();
        cal.createEvent('URL_ADMIN', 'Error', 0, errMessage).complete();
        await logRlogId(req, res, cal);
        tx.complete();
    });
}

async function logRlogId(req, res, cal) {
    const parentReqRlogId = req.headers['rlogid'];
    if (parentReqRlogId) {
        const rlogId = rlogIdGenerator.generate(req);
        if (rlogId) {
            res.setHeader('rlogid', rlogId);
        }
        await cal.createEvent('URL_ADMIN', 'Backward_RLOGID', 0, `rlogid=${parentReqRlogId}`).complete();
    }
}

function proxyIfRequested(req, res) {
    // if it is not viewing of the results, i.e. file is missing
    // then check if worker id matches the current one
    // if not, then proxy into correct worker via localhost:900{worker number}
    const workerId = ViUtils.getWorkerId();
    if (req.query.worker !== undefined &&
        (req.query.worker !== workerId && parseInt(req.query.worker) !== workerId)) {
        const currentPort = ViUtils.getPort(req);
        const targetPort = ViUtils.getWorkerPort(req.query.worker);
        if (currentPort === targetPort) {
            return false;
        }
        const proxy = Prxy.create({
            hostname: 'localhost',
            port: targetPort,
            protocol: 'http:',
            path: '/admin',
            socketTimeout: 5000,
            connectTimeout: 300
        });
        // proxy now
        proxy(req, res);
        return true;
    }
    return false;
}

var stringParameterVectorsQuotesAllowed = [
    '<script',
    'alert',
    '<applet',
    '<object',
    '<iframe',
    '<embed',
    '<!\\[CDATA\\[',
    '<\\[\\[',
    '</script>',
    '</applet>',
    '</object>',
    '</iframe>',
    '</embed>',
    '\\]\\]>',
    '<',
    '>',
    '//',
    'javascript:', // jshint ignore:line
    'data:'
].reduce(function (acc, val) {
    return acc + '|' + val;
}, '').substr(1);

var  stringParameterVectors = new RegExp([
    '\'',
    '"'
].reduce(function (acc, val) {
    return acc + '|' + val;
}, stringParameterVectorsQuotesAllowed), 'ig');

stringParameterVectorsQuotesAllowed = new RegExp(stringParameterVectorsQuotesAllowed, 'ig');

module.exports.clientInfo = clientInfo;
module.exports.logUpdateEvent = logUpdateEvent;
module.exports.logEvent = logEvent;
module.exports.logErrorEvent = logErrorEvent;
module.exports.logRlogId = logRlogId;
