'use strict';


var path = require('path'),
    Os = require('os'),
    tryRequire = require('try-require'),
    net = require('net'),
    HostipChecker = require('@ebay/hostip-checker-ebay'),
    UtilsEbay = require('@ebay/utils-ebay'),
    Async = require('async'),
    exec = require('child_process').exec,
    nodeVersion = process.versions.node || '0.0.0',
    majorMinor = nodeVersion.split('.'),
    major = parseInt(majorMinor[0], 10),
    minor = parseInt(majorMinor[1], 10),
    option = minor >= 10 ? {
        'encoding': 'utf8'
    } : 'utf8';

const debug = require('debug')('validate-internals-ebay:utils');
/*
    The port is used as a base in multi-process envirinment to target specific validate Internals
    endpoint listening on BASE_PORT + workerId, where workerId is pm_id environment variable
 */
const BASE_PORT = 10100;

exports.BASE_PORT = BASE_PORT;
exports.readFileOption = function readFileOption() {
    return option;
};

var debugInfo;

const cores = Os.cpus().length;
let maxWorkersIndex;

/*
 * Build Debug info
 * Read manifest.json for scm and version info
 * if this json file is missing (in local), using git commands build scm info
 */
exports.buildDebugInfo = function buildDebugInfo() {
    var root = process.cwd(),
        manifestJson = tryRequire(path.join(root, 'manifest.json'));

    if (!debugInfo) {
        if (manifestJson && manifestJson.scm) {
            debugInfo = {
                scm : manifestJson.scm,
                version : manifestJson.version
            };
        }
    }
    return debugInfo;
};

exports.isDevRuntime = function isDevRuntime() {
    return process.env.pm_id === undefined;
};

function getWorkerId() {
    return process.env.pm_id || 0;
}
exports.getWorkerId = getWorkerId;

exports.getWorkersNumber = function getWorkersNumber() {
    updateWorkersMaxIndex();
    return process.env.pm_id === undefined ? 1 :
        // assume standard ebay box with 3 workers by default when no info is availabele yet
        (maxWorkersIndex !== undefined ? maxWorkersIndex + 1 : 3);
};

exports.getWorkerPorts = function getWorkerPorts() {
    updateWorkersMaxIndex();
    return workerPorts;
};

exports.getWorkerPort = function getWorkerPort(workerId) {
    if (workerId !== undefined) {
        return BASE_PORT + parseInt(workerId);
    }
    return BASE_PORT + parseInt(getWorkerId());
};

function isPortFree(port, callback) {
    const tester = net.createServer()
	// catch errors, and resolve false
	.once('error', err => callback(false))
	// return true if succeed
	.once('listening', () => tester.once('close', () => callback(true)).close())
	.listen(port);
}
exports.isPortFree = isPortFree;

exports.getHeader = function getHeader(obj, name) {
    return obj.headers[name] || obj.headers[name.toLowerCase()];
};

exports.removeTokenFromGitUrl = function removeTokenFromGitUrl(gitUrl){
    const res = "https://" + gitUrl.substring(gitUrl.indexOf("github.corp.ebay.com"));
    return res;
};

exports.tryParse = function tryParse(value) {
    try {
        return JSON.parse(value);
    } catch (e) {
        return undefined;
    }
};

exports.round = function round(number, precision) {
    precision = precision || 0;
    var factor = Math.pow(10, precision);
    var tempNumber = number * factor;
    var roundedTempNumber = Math.round(tempNumber);
    return roundedTempNumber / factor;
};

let workersIndexDetection;
let workerPorts = [];
function updateWorkersMaxIndex() {
    workerPorts = [];

    if (cores > 1 && process.env.pm_id !== undefined) {

        if (workersIndexDetection) {
            return workersIndexDetection;
        }

        let max = 0;

        debug('# detecting max workers index, current number is', max);
        workersIndexDetection = new Promise(resolve => {
            Async.times(cores, (index, next) => {
                const port = BASE_PORT + index;
                debug('# checking port', port);
                isPortFree(port, function (err, output) {
                    if (err) {
                        return next();
                    }
                    max = Math.max(max, index);
                    workerPorts.push(port);
                    next();
                });
            }, () => {
                debug('# max workers index detected', max);
                // update
                maxWorkersIndex = max;
                resolve(max);
            });

            // trottle worker detection
            // clean up promise/queue after 10 seconds
            setTimeout(() => {
                workersIndexDetection = undefined;
            }, parseInt(process.env.TROTTLE_WORKER_DETECTION_INTERVAL) || 10000);

        });
        return workersIndexDetection;
    }

    return Promise.resolve(maxWorkersIndex);
}

exports.updateWorkersMaxIndex = updateWorkersMaxIndex;

// Returns true if IP is internal, else false.
function allowView(req) {
    var ip = UtilsEbay.getRemoteAddr(req);
    var chk = HostipChecker.checkIpSync(ip);
    if (chk && chk.isInternal && !UtilsEbay.isIPFromAkamaiHeader(req)) {
        return true;
    }
    return false;
}
exports.allowView = allowView;

function getPort(req) {
    return req.app && req.app.get('port') ||
        req.socket && req.socket.localPort || 0;
}
exports.getPort = getPort;

function isEnvoyEnabled() {
    return process.env.ENABLE_E2ETLS && (process.env.ENABLE_E2ETLS === true || process.env.ENABLE_E2ETLS === 'true');
}
exports.isEnvoyEnabled = isEnvoyEnabled;

function isMeshEnabled() {
    return process.env.MESH_ENABLED && (process.env.MESH_ENABLED === true || process.env.MESH_ENABLED === 'true');
}
exports.isMeshEnabled = isMeshEnabled;

function isContainerPdlcEnabled(){
    return process.env.CONTAINER_PDLC && (process.env.CONTAINER_PDLC === true || process.env.CONTAINER_PDLC === 'true');
}
exports.isContainerPdlcEnabled = isContainerPdlcEnabled;

function getUbuntuVersion(callback) {
    exec('lsb_release -a', (error, stdout, stderr) => {
        if (error) {
            callback(error);
            return;
        }

        const outputLines = stdout.split('\n');
        const descriptionLine = outputLines.find(line => line.startsWith('Description:'));
        if (!descriptionLine || typeof descriptionLine !== 'string') {
            callback(new Error('Ubuntu version not found'));
            return;
        }
        const version = descriptionLine.split(':')[1].trim();
        callback(null, version);
    });
}

exports.getUbuntuVersion = getUbuntuVersion;

/**
 * Capitalizes the first letter of a string
 * @param {string} str - The string to capitalize
 * @returns {string} The string with the first letter capitalized
 */
function capitalizeFirstLetter(str) {
    if (!str || typeof str !== 'string' || str.length === 0) {
        return str;
    }
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
exports.capitalizeFirstLetter = capitalizeFirstLetter;
