'use strict';
let Httpunch = require('@ebay/httpunch');
let _ = require('underscore');
let configBean = require('@ebay/config-bean-ebay');
const env = require('@ebay/environment-ebay');
const HostipChecker = require('@ebay/hostip-checker-ebay');
const ViUtils = require('./utils.js');
const UtilsEbay = require('@ebay/utils-ebay');
const TokenValidator = require('@ebay/trust-fabric-ebay/lib/TokenValidator');
const logger = require('@ebay/logging-inc').logger('validate-internals-ebay/TrustFabricValidator');
const envToRealmMap = {
    'development': ['staging', 'qa', 'feature', 'qate', 'lnp', 'dev'],
    'staging': ['staging', 'qa', 'feature', 'qate', 'lnp', 'dev'],
    'lnp': ['staging', 'qa', 'feature', 'qate', 'lnp', 'dev'],
    'sandbox': ['sandbox'],
    'production': ['production', 'pre-production'],
    'pre-production': ['production', 'pre-production']
};
const ACL_HOSTS = require('./access-control-list-hosts.js');
const defaultApps = ['fountdsvc','batchtools','lvsrules','fountagentmptprod','uc4mpprodtoolsagent','pgtf','montagelightning','adminproxy','adminproxypci','adminproxyrnpci','adminproxytcp'];
const beanInfo = {'enabled': true, 'fallbackToIP': true, 'allowlist': defaultApps};
const VI_TRUSTFABRIC_BEAN_ID = 'nodejs.config.ValidateInternals.TrustFabricConfigBean';
const DEFAULT_INTERVAL = 12 * 60 * 60; // 12 Hrs Refresh

class TrustFabricValidator {
    constructor() {
        this.isRunning = false;
        this.timer = undefined;
        if(env.isDev() || env.isTest()) {
            return;
        }        
        this.createBean();
        this.startTimer();
    }

    getTimerInterval() {
        return DEFAULT_INTERVAL;
    }

    validate(req, res, next) {
        // Skip in Dev & Test
        if(env.isDev() || env.isTest()) {
            return next();
        }

        const bean = configBean.getBeanById(VI_TRUSTFABRIC_BEAN_ID);
        if(!bean || bean.get('enabled') === false) {
            logger.warn(`TrustFabric Validation Skipped for ValidateInternals, enabled=${bean?.get('enabled')}`);
            return next();
        }

        const ip = ViUtils.isEnvoyEnabled() ? req.headers['x-client-ip'] : UtilsEbay.getRemoteAddrFromTrustedHeader(req);
        const tfHeader = req.headers['x-ebay-tf-authorization'];
        const tfToken = /^bearer /i.test(tfHeader) ? tfHeader.substring('bearer '.length) : undefined;

        if(tfToken) {            
            new TokenValidator(req)
                .validate(tfToken, {}, (err, decodedToken) => {
                    const fallbackToIP = bean.get('fallbackToIP');
                    const allowlist = bean.get('allowlist');

                    const doRespond = (msg) => {
                        return fallbackToIP ? next() : res.status(403).send(msg);
                    };

                    if (err) {
                        logger.warn(`TrustFabric Validation failed`, err);
                        return doRespond('ValidateInternals not allowed, TF check failed'); // Validation Failed              
                    }
                    const payload = decodedToken.payload;
                    const subject = payload.sub;
                    const sub = subject.split(',').reduce((accum, elem) => {
                        const data = elem.split('=');
                        accum[data[0].toLowerCase()] = data[1];
                        return accum;
                    }, {});

                    const appName = sub.o;
                    // Skip if AppName is not in allow list, continue with IP
                    if(!allowlist?.includes(appName)) {
                        logger.warn(`TrustFabric Verification failed with ${appName} not in AllowList ${allowlist}`);
                        return doRespond(`ValidateInternals not allowed, Caller App(${appName}) is not in allowlist(${allowlist})`);
                    }
                    
                    if(!HostipChecker.isInternalIp(ip)) {
                        return res.status(403).send('ValidateInternals not allowed, IP should be internal');
                    }

                    if(!payload.instances.includes(ip)) {
                        logger.warn(`TrustFabric Verification failed with IP(${ip}) in Instances(${payload.instances})`);
                        return doRespond('ValidateInternals not allowed, TF IP check failed');
                    }

                    if(!envToRealmMap[process.env.DEPLOY_ENV].includes(payload.realm?.toLowerCase())) {
                        logger.warn(`TrustFabric Verification failed with ENV(${process.env.DEPLOY_ENV}) in Realm(${payload.realm})`);
                        return doRespond('ValidateInternals not allowed, TF env check failed');
                    }
                    next();
                });
        } else {
            logger.warn('Missing TrustFabric token header for ValidateInternals Access, continuing with IP check');
            return next();
        }
    }

    

    createBean() {
        let viTrustFabricInfo = {
            'configbean': true,
            'id': VI_TRUSTFABRIC_BEAN_ID,
            'alias': VI_TRUSTFABRIC_BEAN_ID,
            'group': 'nodejs.config',
            'desc': 'ValidateInternals TrustFabric Header Config',
            'attributes': _.map(beanInfo, function (val, key) {
                return {
                    'name': key,
                    'value': val,
                    'readable': 'true',
                    'writable': 'true'
                };
            })
        };

        let viTrustFabricBean =  configBean.getBeanById(VI_TRUSTFABRIC_BEAN_ID);
        
        //Create Bean if it doesnt exists or update existing bean with the new values from Envoy
        if (!viTrustFabricBean) {
            viTrustFabricBean = configBean.define(viTrustFabricInfo);
        }
    }

    startTimer() {
        const fetchAndUpdate = async () => {
            try {
                // eslint-disable-next-line
                while(process.domain) {
                    process.domain.exit();
                }
                const data = await this.getAppAcl();
                this.persistToBeans(data);
            }
            catch (err) {
                logger.error('Failed to fetch App ACL(VI TrustFabric)from AuthzSvc', err);
            }
            finally {
                this.timer = setTimeout(fetchAndUpdate, this.getTimerInterval() * 1000).unref();
            }
        };

        if (!this.isRunning) {
            this.isRunning = true;
            setImmediate(fetchAndUpdate);
        }
    }

    clearTimer() {
        this.timer && clearTimeout(this.timer);
        this.timer = undefined;
        this.isRunning = false;
    }

    getAclUrl() {
        const host = ACL_HOSTS[process.env.DEPLOY_ENV] || ACL_HOSTS.staging;
        return `https://${host}/authzsvc/api/v2/appacl`;    
    }

    getAppAcl() {
        return new Promise((resolve, reject) => {
            Httpunch.get({
                url: this.getAclUrl(),
                method: 'GET',
                rejectUnauthorized: false
            },(err, res)=>{  
                if (err) {
                    return reject(err);
                }
                return resolve(JSON.parse(res.body.toString()));
            });
        });
    }

    persistToBeans(config) {
        const bean = configBean.getBeanById(VI_TRUSTFABRIC_BEAN_ID);

        if(!bean) {
            this.createBean();
        }

        if (config) {            
            bean.setPersist('allowlist', config);
        }
    }
}

module.exports = new TrustFabricValidator();
