'use strict';

const inspector = require('inspector');
const Readable = require('stream').Readable;

const logger = require('@ebay/logging-inc').logger('validate-internals-ebay/profiler');
const majorNodeVersion = parseInt(process.version.match(/^v(\d+)/)[1]);


const errorNoModule = `BLOCKING ERROR: Module "v8-profiler-node8" is not present.
validate-internals-ebay requires now Node v8.x in order to profile your app.
You need to ADD "v8-profiler-node8": "^6.1.1" in your "package.json"
Consider upgrading to node v10.x or greater 
`;

let v8profiler;
if (majorNodeVersion <= 8) {
    try {
        v8profiler = require('v8-profiler-node8');
    } catch(e) {
        throw new Error(`${errorNoModule}, originalError: ${e.stack}`);
    }
}

class V8CPUProfiler {
    startProfiling() {
        v8profiler.startProfiling('CPU Profile', true);
        let profile;

        return {
            stopProfiling() {
                profile = profile || v8profiler.stopProfiling();
                return profile;
            }
        };
    }
}

class CPUProfileReadableStream extends Readable {
    constructor(profile) {
        super();
        this.data = Buffer.from(JSON.stringify(profile));
        this.offset = 0;
    }

    _read(size) {
        const length = this.data.length;
        size = size || length;
        while(this.offset < length) {
            const newOffset = this.offset + size;
            const chunk = this.data.slice(this.offset, Math.min(length, newOffset));
            this.offset = newOffset;
            if (!this.push(chunk)) {
                return;
            }
        }
        this.push(null);
        this.data = undefined;
    }
}

class NativeProfile {
    constructor(profile) {
        this.stream = new CPUProfileReadableStream(profile);
    }

    export() {
        return this.stream;
    }

    delete() {
        // no need to delete
        // keep it for backwards compatibility
    }
}

class NativeCPUProfiler {
    async startProfiling() {
        const session = new inspector.Session();
        session.connect();

        await new Promise(resolve => {
            session.post('Profiler.enable', () => {
                session.post('Profiler.start', () => {
                    resolve();
                });
            });
        });

        return {
            async stopProfiling() {
                return await new Promise((resolve, reject) => {
                    session.post('Profiler.stop', (err, { profile }) => {
                        try {
                            session.disconnect();
                        }
                        catch (e) {
                            logger.error('profiler failed to disconnect from session', e);
                        }

                        if (err) {
                            return reject(err);
                        }

                        resolve(new NativeProfile(profile));
                    });
                });
            }
        };
    }
}

class HeapProfileReadableStream extends Readable {
    constructor() {
        super();
        this._buffer = [];
        this._open = true;
    }

    push(data) {
        if (!this._open || this._buffer.length) {
            this._buffer.push(data);
            return this._open;
        }

        this._open = super.push(data);
        return this._open;
    }

    _read() {
        this._open = true;
        while (this._buffer.length && this._open) {
            this._open = super.push(this._buffer.shift());
        }
    }
}

class HeapNativeProfiler {
    async takeSnapshot() {
        const session = new inspector.Session();        
        session.connect();
        
        const stream = new HeapProfileReadableStream();
        session.on('HeapProfiler.addHeapSnapshotChunk', m => {
            stream.push(m.params.chunk);
        });
        
        await new Promise(resolve => {
            session.post('HeapProfiler.takeHeapSnapshot', null, (err, r) => {
                session.disconnect();
                stream.push(null);
                resolve();
            });
        });

        return {
            export() {
                return stream;
            },

            delete() {}
        };
    }
}

class V8HeapProfiler {
    takeSnapshot() {
        const snapshot = v8profiler.takeSnapshot();

        return {
            export() {
                return snapshot.export();
            },

            delete() {
                snapshot.delete();
            }
        };
    }
}

function getHeapProfiler() {
    if (majorNodeVersion >= 10) {
        return new HeapNativeProfiler();
    }
    return new V8HeapProfiler();
}

function getCPUProfiler() {
    if (majorNodeVersion >= 10) {
        return new NativeCPUProfiler();
    }
    return new V8CPUProfiler();
}

module.exports = {
    getCPUProfiler,
    getHeapProfiler
};