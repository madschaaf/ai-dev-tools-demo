'use strict';
let Httpunch = require('@ebay/httpunch');
let _ = require('underscore');
let configBean = require('@ebay/config-bean-ebay');
const Async = require('async');
const URL = require('url');
const ViUtils = require('./utils');

const ENVOY_SERVER_INFO_URL = 'http://127.0.0.1:9901/server_info';
const ENVOY_CLUSTERS_URL = 'http://127.0.0.1:9901/clusters';
const ENVOY_LOGGING_URL = 'http://127.0.0.1:9901/logging';
const ENVOY_CERTS_INFO_URL = 'http://127.0.0.1:9901/certs';

const BEATS_PACKAGE_URL = 'https://127.0.0.1:12020/agent/dynamic_config/api/v1/software/beats/current/wiri';
const FILEBEAT_URL = 'http://127.0.0.1:5001/?pretty';
const METRICBEAT_URL = 'http://127.0.0.1:5002/?pretty';

const ENVOY_BEAN_ID = 'nodejs.config.EnvoyLoggingConfigBean';

function getEnvoyServerInfo(callback) {
    
    Async.parallel({
        serverInfo: (cb) => {
            Httpunch.get(ENVOY_SERVER_INFO_URL,(err, res)=>{
                let serverInfo = {            
                };
        
                if(err || (res && res.statusCode >= 300)) {
                    serverInfo.server_info = `Error Connecting Envoy Server Info URL at ${ENVOY_SERVER_INFO_URL}. ${err}`;
                } else {
                    try {
                        serverInfo = JSON.parse(res.body);    
                    } catch (error) {
                        serverInfo.server_info = res.body;
                    }                    
                }                
                cb(null, serverInfo);
            });
        },
        certsInfo: (cb) => {
            Httpunch.get(ENVOY_CERTS_INFO_URL,(err, res)=>{
                let certsInfo = {            
                };
        
                if(err || (res && res.statusCode >= 300)) {
                    certsInfo.certs_info = `Error Connecting Envoy Server Info URL at ${ENVOY_CERTS_INFO_URL}. ${err}`;
                } else {
                    try {
                        const resBody = JSON.parse(res.body);
                        const certs = resBody.certificates && resBody.certificates[0] || {};
                        const certChain = certs.cert_chain || [];
                        certsInfo = certChain.length > 0 ? certChain[0] : {};    
                    } catch (error) {
                        certsInfo.certs_info = res.body;
                    }                                
                }
                cb(null, certsInfo);
            });
        }
    }, (err, res) => {
        
        let model = _.extend(res.serverInfo || {}, res.certsInfo || {});
        let envoyServerInfo = {
            'name': 'server_info',
            'alias': 'server_info',
            'status': 'created',
            'properties': _.map(model, function (val, key) {
                return {
                    'name': key,
                    'value': val
                };
            })
        };
        callback(envoyServerInfo);

    });
}

function getEnvoyHealthInfo(callback) {
    Httpunch.get(ENVOY_CLUSTERS_URL,(err, res)=>{
        let healthInfo = {            
        };

        if(!err && res.statusCode < 300) {
            let envoyRes = res.body.toString() || '';
            let lines = envoyRes.split('\n') || [];
            lines.forEach((line)=> {
                let index = line.lastIndexOf('::');
                healthInfo[line.substring(0,index)] = line.substring(index+2) || '';
            });

        } else {
            healthInfo.health_info = `Error Connecting Envoy Clusters URL at ${ENVOY_CLUSTERS_URL}. ${err}`;
        }

        let envoyServerInfo = {
            'name': 'EnvoyHealthComponentStatus',
            'alias': 'EnvoyHealthComponentStatus',
            'status': 'created',
            'properties': _.map(healthInfo, function (val, key) {
                return {
                    'name': key,
                    'value': val
                };
            })
        };
        callback(envoyServerInfo);
    });
}

function createEnvoyLoggingBean() {

    Httpunch.post(ENVOY_LOGGING_URL+'?lua=info',(err, res)=>{
        let loggingInfo = {            
        };

        if(!err && res.statusCode < 300) {
            let envoyRes = res.body.toString() || '';
            let lines = envoyRes.split('\n') || [];
            lines.forEach((line)=> {
                if(line.indexOf('active loggers') < 0 && line.trim().length > 0) {
                    let index = line.indexOf(':');
                    let key = line.substring(0,index) || '';
                    let val = line.substring(index+2) || '';
                    loggingInfo[key.trim() || ''] = val.trim() || '';
                }
            });
        } else {
            loggingInfo.logging_info = `Error Connecting Envoy Logging URL at ${ENVOY_LOGGING_URL}. ${err}`;
        }

        let envoyLoggingInfo = {
            'configbean': true,
            'id': ENVOY_BEAN_ID,
            'alias': ENVOY_BEAN_ID,
            'group': 'nodejs.config',
            'desc': 'Envoy Log Levels',
            'attributes': _.map(loggingInfo, function (val, key) {
                return {
                    'name': key,
                    'value': val,
                    'readable': 'true',
                    'writable': 'true'
                };
            })
        };

        let envoyLogLevelBean =  configBean.getBeanById(ENVOY_BEAN_ID);
        
        //Create Bean if it doesnt exists or update existing bean with the new values from Envoy
        if (!envoyLogLevelBean) {
            envoyLogLevelBean = configBean.define(envoyLoggingInfo);            
        } else {
            Object.keys(loggingInfo).forEach((akey)=> {
                envoyLogLevelBean.set(akey, loggingInfo[akey]);
            });              
        }

        envoyLogLevelBean.on('changed', function () {
            envoyLogLevelBean.configbean.attributes.forEach((attr)=> {
                if(attr.lastUpdated && attr.value !== '') {
                    updateEnvoyLogging(attr.name, attr.value);
                }
            });            
        });
        
    });
}

function getBeatsInfo(callback) {
    
    Async.parallel({
        beatsPkgInfo: (cb) => {
            getBeatsDetails('Beats Package', BEATS_PACKAGE_URL, cb);
        },
        fileBeatsInfo: (cb) => {
            getBeatsDetails('File Beat', FILEBEAT_URL, cb);            
        },
        metricsBeatsInfo: (cb) => {
            getBeatsDetails('Metric Beat', METRICBEAT_URL, cb);  
        }
    }, (err, res) => {
        let model = {};

        model = _.extend(model, res.metricsBeatsInfo || {});
        model = _.extend(model, res.fileBeatsInfo || {});
        model = _.extend(model, res.beatsPkgInfo || {});
        
        if(ViUtils.isContainerPdlcEnabled()) {
            for(const key in model){
                model[key] = 'Not Available';
            }
        }

        let beatsInfo = {
            'name': 'BeatsPackageComponentStatus',
            'alias': 'BeatsPackageComponentStatus',
            'status': 'created',
            'properties': _.map(model, function (val, key) {
                return {
                    'name': key,
                    'value': val
                };
            })
        };
        callback(beatsInfo);
    });
}

function getBeatsDetails(servicename, url, cb) {
    let options = URL.parse(url);
    options.method = 'GET';
    options.rejectUnauthorized = false;    

    Httpunch.get(options, (err, res)=>{
        let info = {            
        };

        if(err || (res && res.statusCode >= 300)) {
            info[servicename] = `Error Connecting ${servicename} Server URL at ${url}. ${err}`;
        } else {
            info[servicename] = res.body.toString();                      
        }

        cb(null, info);
    });
}

function updateEnvoyLogging(type, value) {
    Httpunch.post(ENVOY_LOGGING_URL+`?${type}=${value}`,(err, res)=>{
        //noop
    });
}

module.exports = {
    getEnvoyServerInfo: getEnvoyServerInfo,
    getEnvoyHealthInfo: getEnvoyHealthInfo,
    createEnvoyLoggingBean: createEnvoyLoggingBean,
    getBeatsInfo: getBeatsInfo
};