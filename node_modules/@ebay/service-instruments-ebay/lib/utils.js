'use strict';
const querystring = require('querystring');
const NodePath = require('path');
const NodeUtils = require('util');
const dns = require('dns');
let HostIpChecker; // lazy init

module.exports.tryRequire = function tryRequire(name) {
    try {
        return require(name);
    }
    catch (e) {
        console.error(e);
    }
};

module.exports.tryResolve = function tryResolve(name) {
    try {
        return require.resolve(name);
    } catch (e) { // eslint-disable-line
    }
};

module.exports.normalizeModuleName = moduleName => moduleName.split('/').pop();

module.exports.formatUrl = function formatUrl(options) {
    // eslint-disable-next-line no-nested-ternary
    let qString = options.qs ? (typeof options.qs === 'string' ? options.qs :
        querystring.stringify(options.qs)) : options.search || '';
    qString = qString ? `?${qString}` : '';

    let path = NodePath.join(options.basepath || '', options.path || '');
    if (!path.startsWith('/')) {
        path = `/${path}`;
    }

    return NodeUtils.format('%s//%s:%s%s%s',
        options.protocol,
        options.hostname,
        options.port || (options.protocol === 'https:' ? 443 : 80),
        path,
        qString);
};

const deepMerge = module.exports.deepMerge = function deepMerge(destination, ...sources) {
    sources.forEach(source => {
        for (const key in source) {
            if (destination[key] &&
                typeof destination[key] === 'object' &&
                typeof source[key] === 'object' &&
               !Array.isArray(destination[key]) &&
               !Array.isArray(source[key])
            ) {
                deepMerge(destination[key], source[key]);
            }
            else {
                destination[key] = source[key];
            }
        }
    });
    return destination;
};

// The function provides ip by hostname and caches the result, returns promise with ip or null if error
function lookupIpByHost(hostname) {
    return new Promise((resolve, reject) => {
        dns.lookup(hostname, (_err, ip) =>
            // ignore error
            resolve(ip)
        );
    });
}

module.exports.isExternalService = async (hostname, lookup = lookupIpByHost) => {
    if (!hostname || hostname.indexOf('.') === -1 ||
        hostname === 'localhost' ||
        hostname.endsWith('.vip') ||
        hostname.endsWith('.vip.ebay.com') ||
        hostname.endsWith('.qa.ebay.com') ||
        hostname.endsWith('.stratus')) {
        return false;
    }

    // check ip address
    // error will never happen
    const address = await lookup(hostname).catch(err => err);
    if (!address) {
        return false;
    }
    HostIpChecker = HostIpChecker || require('@ebay/hostip-checker-ebay');
    return !(address === '127.0.0.1' ||
        address.startsWith('10.') ||
        address.startsWith('192.168.') ||
        HostIpChecker.isInternalIp(address));
};

module.exports.getClientConfigOrInjectDefault = (configObject, clientId) => {
    const clientConfig = configObject.get(`services:${clientId}`);
    const extendConfig = clientConfig?.extends;
    if (extendConfig) {
        const extendFromConfig = configObject.get(`service-instruments-ebay:${extendConfig}`);
        if (!extendFromConfig) {
            throw new Error(`Cannot find the config to extend from ${extendConfig} for client id: ${clientId}`);
        }
        const injectConfig = deepMerge({}, extendFromConfig, clientConfig);
        configObject.use({
            services: {
                [clientId]: injectConfig
            }
        });
    }
    if (clientConfig) {
        return clientConfig;
    }
    const defaultConfig = configObject.get(`service-instruments-ebay:default-client-config`);
    if (defaultConfig) {
        const injectConfig = Object.assign({}, defaultConfig);
        configObject.use({
            services: {
                [clientId]: injectConfig
            }
        });
        return injectConfig;
    }
};
