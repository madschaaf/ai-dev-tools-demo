'use strict';

const Assert = require('assert');
const Async = require('async');
const ConfigUtils = require('@ebay/module-config-inc/lib/utils');
const Cal = require('@ebay/cal');
const modConfig = require('@ebay/module-config-inc');
const ConfigBeans = require('@ebay/module-config-inc/lib/configbeans');
const Objutil = require('objutil');
const NodeUtils = require('util');
const UrlUtils = require('url');
const Lodash = require('lodash');
const tryRequire = require('try-require');
const Vi = tryRequire('@ebay/validate-internals-ebay');
const { normalizeModuleName } = require('./lib/utils');

const Trooba = require('trooba');
const hystrixHandler = require('trooba-hystrix-handler');
const circuitFactory = hystrixHandler.circuitFactory;
const metricsFactory = hystrixHandler.metricsFactory;
const commandFactory = hystrixHandler.commandFactory;

const RuntimeError = require('./lib/errors').RuntimeError;

const logger = require('@ebay/logging-inc').logger('service-instruments-ebay/circuit');

const DEFAULT_CONFIG = {
    circuitBreakerErrorThresholdPercentage: 50, // optional
    circuitBreakerForceClosed: false, // optional
    circuitBreakerForceOpened: false, // optional
    circuitBreakerRequestVolumeThreshold: 20, // optional
    circuitBreakerSleepWindowInMilliseconds: 5000, // optional
    requestVolumeRejectionThreshold: 0, // optional
    statisticalWindowNumberOfBuckets: 10, // optional
    statisticalWindowLength: 10000, // optional
    percentileWindowNumberOfBuckets: 6, // optional
    percentileWindowLength: 60000, // optional
    timeout: 0 // turn off timeout as we have our own in transport
};

const components = {};

const STATE_FIELDS = [
    'requestVolumeRejectionThreshold',
    'statisticalWindowNumberOfBuckets',
    'statisticalWindowLength',
    'percentileWindowNumberOfBuckets',
    'percentileWindowLength',
    'timeout'
];

let pipeModifiedStates = {};

/*
    We need to adjust state and error/response before and after circuit breaker.
*/
const circuitPipes = {};
const deprecatedMessages = {}; // store if deprecated message was already shown

module.exports = function doCircuit(pipe, config) {
    const clientId = pipe.context.clientId;
    validateConfig(config, clientId);
    Assert.ok(clientId, 'clientId should be provided in the requestContext');

    // get or create one
    let circuitPipe = circuitPipes[clientId];
    if (!circuitPipe) {
        circuitPipe = circuitPipes[clientId] = buildCircuitPipe(config);
    }

    // link it
    pipe.link(circuitPipe);
};

module.exports.metricsFactory = metricsFactory;
module.exports.circuitFactory = circuitFactory;
module.exports.commandFactory = commandFactory;

function buildCircuitPipe(config) {
    config = config && config.circuit ?
        Object.assign({}, DEFAULT_CONFIG, config.circuit) : DEFAULT_CONFIG;

    return Trooba
        .use(preCircuit, config)
        .use(hystrixHandler, config)
        .use(postCircuit, config)
        .build();
}

/*
    We need to adjust some parameters before we pass it to
    the generic hystrix handler
*/
function preCircuit(pipe, config) {
    const clientId = pipe.context.clientId;
    pipe.context.command = clientId;
    const circuitBreaker = circuitFactory.getOrCreate(
        Object.assign({ commandKey: clientId }, config));
    const componentStatus = getOrCreateComponentStatus(pipe, config);

    let isCircuitBreakerOpen;

    if (pipe.context.circuit) {
        updateCircuitBreaker(pipe.context.circuit);
    }

    let _options;

    pipe.on('request', (request, next) => {
        logger.info('preCircuit handler', clientId);

        // sync with config bean state
        componentStatus.syncTo(request, (err, options) => {
            if (err) {
                return pipe.throw(err);
            }

            _options = options;

            // if we have any circuit configuration, use it
            if (options.circuit) {
                // plain copying of values from config to circuit breaker
                updateCircuitBreaker(options.circuit);
            }

            // sync from config bean to circuit breaker
            if (componentStatus.isAutoMarkdown() && !circuitBreaker.circuitOpen) {
                circuitBreaker.circuitOpen = true;
                circuitBreaker.circuitOpenedOrLastTestedTime = Date.now();
            }

            // check if the service was force markdown
            // if yes, force open the circuit,
            // otherwise, reset to false
            // the source of truth is always SVC_CHANNEL_STATUS over circuitBreakerForceOpened
            if (componentStatus.isForceMarkdown()) {
                circuitBreaker.circuitBreakerForceOpened = true;
                circuitBreaker.circuitOpen = true;
            }
            else if (circuitBreaker.circuitBreakerForceOpened) {
                // make sure dashboard reflects it
                circuitBreaker.circuitOpen = true;
                if (!componentStatus.isForceMarkdown()) {
                    componentStatus.forceOpenCircuit();
                }
            }

            // remeber the state we need to use on response/error flow to adjust
            // the component state
            isCircuitBreakerOpen = circuitBreaker.isOpen();

            validateConfig(options, clientId);
            // run curcuit logic
            next();
        });
    });

    function updateState() {
        // now we need to see if circuit state has changed and adjust component status
        // as long as it was not forced open
        if (isCircuitBreakerOpen !== circuitBreaker.isOpen() &&
            !componentStatus.isForceMarkdown()) {
            // sync back from circuit breaker to component status
            circuitBreaker.isOpen() ?
                componentStatus.openCircuit() :
                componentStatus.closeCircuit();
        }
    }

    pipe.once('response', (response, next) => {
        updateState();
        const stats = metricsFactory.getOrCreate({ commandKey: clientId }).getHealthCounts();
        if (response && typeof response === 'object') {
            response.errorCount = stats.errorCount;
        }
        if (response.socket && typeof response.socket.getProtocol === 'function') {
            componentStatus.setTlsSocketProtocol(response.socket.getProtocol());
        }
        next();
    });

    pipe.once('error', (err, next) => {
        updateState();
        const stats = metricsFactory.getOrCreate({ commandKey: clientId }).getHealthCounts();
        err.errorCount = stats.errorCount;

        if (err.message === 'OpenCircuitError') {
            err.code = 'AlreadyMarkedDown';
        }
        else if (circuitBreaker.isOpen()) {
            logger.error(err);

            const endpoint = NodeUtils.format('%s%s%s',
                UrlUtils.format(_options),
                _options.basehost || '',
                _options.path || '');

            err = new RuntimeError(`The service is being marked down with status APP_AUTO_MARK_DOWN, endpoint: ${
                endpoint}, name: ${clientId}`, err);
            err.code = 'APP_AUTO_MARK_DOWN';
        }

        next(err);
    });

    // eslint-disable-next-line no-shadow
    function updateCircuitBreaker(config) {
        Object.assign(circuitBreaker, Lodash.pick(config, [
            'circuitBreakerErrorThresholdPercentage',
            'circuitBreakerSleepWindowInMilliseconds',
            'circuitBreakerForceClosed',
            'circuitBreakerForceOpened'
        ]));

        if (config.circuitBreakerRequestVolumeThreshold !== undefined) {
            circuitBreaker.circuitBreakerRequestVolumeThresholdValue =
                config.circuitBreakerRequestVolumeThreshold;
        }
    }
}

/*
    We need to adjust some parameters after we are done
    with the generic circuit handler
*/
function postCircuit(pipe) {
    const clientId = pipe.context.clientId;
    let options;

    pipe.on('request', (request, next) => {
        logger.info('postCircuit handler', clientId);
        options = request;

        next();
    });

    pipe.on('error', (err, next) => {
        next(handleError(err));
    });

    pipe.on('response', (response, next) => {
        if (!isSuccessCode(options, response.statusCode) && response.statusCode >= 400) {
            if (Buffer.isBuffer(response.body)) {
                // convert error to string
                response.body = response.body.toString('utf-8');
            }
            const errBody = typeof response.body === 'object' ? JSON.stringify(response.body) : response.body;
            let err = new Error(`HTTP ${response.statusCode}, response: ${errBody}`);
            err.res = response;
            err.body = response.body;
            err.statusCode = response.statusCode;
            err = handleError(err);
            pipe.throw(err);
            return;
        }

        next();
    });

    function handleError(err) {
        // adjust error and
        // record type of timeout if any
        if (err.code === 'ETIMEDOUT') {
            err.type = 'SOCK_TIMEOUT';
        }
        if (err.code === 'ECONNRESET') {
            err.code = 'ETIMEDOUT';
            err.type = 'CONN_TIMEOUT';
        }

        return err;
    }
}

function validateConfig(config, clientId) {
    if (!config || config['markdown-threshold'] === undefined || deprecatedMessages[clientId]) {
        return;
    }

    console.warn(`[WARN] Please remove markdown-threshold from ${clientId} config and adjust circuit:circuitBreakerErrorThresholdPercentage and circuit:circuitBreakerRequestVolumeThreshold according to your needs or rely on default values, please see https://github.corp.ebay.com/nodejs/service-instruments-ebay and  https://github.com/Netflix/Hystrix/wiki/Configuration#CommandCircuitBreaker`);

    deprecatedMessages[clientId] = true;
}

function isSuccessCode(statusList, statusCode) {
    if (statusCode) {
        const successCodes = (statusList['error-handler'] && statusList['error-handler']['success-codes']) || [];
        return successCodes.indexOf(statusCode) > -1 ||
            successCodes.indexOf(statusCode.toString()) > -1;
    }

    return false;
}

function getOrCreateComponentStatus(pipe, config) {
    const clientId = pipe.context.clientId;
    const caller = pipe.context.caller;
    if (!caller) {
        throw new Error('caller should be provided');
    }

    const moduleRef = caller || module;
    const modRoot = ConfigUtils.moduleRoot(moduleRef);
    const moduleName = normalizeModuleName(ConfigUtils.moduleName(modRoot));

    return components[clientId] ||
        (components[clientId] =
            new ComponentStatus(clientId,
                moduleName, moduleRef, config));
}

function ComponentStatus(clientId, moduleName, moduleRef, config) {
    this.clientId = clientId;
    this.moduleName = moduleName;
    this.moduleRef = moduleRef;
    this.config = config;
}

module.exports.ComponentStatus = ComponentStatus;

function getComponentStatus(clientId) {
    return components[clientId];
}

module.exports._getComponentStatus = getComponentStatus;

let proto = ComponentStatus.prototype;

proto.syncTo = function syncTo(options, callback) {
    const self = this;
    const clientId = self.clientId;
    const clientPath = `services:${clientId}`;

    modConfig(this.moduleRef, (err, configObject) => {
        const clientConfig = configObject.get(clientPath);
        if (!clientConfig) {
            setImmediate(() => {
                callback(new Error(`Service config for client ${clientId} is not found, search`));
            });
            return;
        }

        const state = self.state;
        if (!state) {
            // inject config for client service
            const injectConfig = {
                services: {},
                '@ConfigBean': {}
            };

            // inject service status
            clientConfig.SVC_CHANNEL_STATUS = 'MARK_UP';
            // to control any debug instrumentation for service client calls
            clientConfig.debug = 'false';
            injectConfig.services[clientId] =
                injectConfig.services[clientId] || {};

            // inject circuit breaker config directly to service definition
            clientConfig.circuit =
                Object.assign({}, DEFAULT_CONFIG, clientConfig.circuit, self.config);

            const beanDef = injectConfig['@ConfigBean'][self.moduleName] =
                injectConfig['@ConfigBean'][self.moduleName] || {};

            const clientBeanDef = beanDef[clientId] = beanDef[clientId] || {};

            // create mapping to shorter name
            addMapping(clientBeanDef, clientConfig, `services:${clientId}:`);
            configObject.use(injectConfig);
            // create config bean
            const bean = ConfigBeans.createConfigBean(self.moduleName, configObject);
            ConfigBeans.registerRaptorConfigs(self.moduleName, configObject, bean);
            self.state = new ConfigBeanWrapper(clientId, bean[clientId]);

            // monitor changes
            configObject.on('change', () => onConfigChange(configObject, clientId));
            // register hystrix component status once during config bean creation
            registerHystrixComponentStatus(clientId);

            // enable metrics publishing
            enableHystrixMetricsPublishing(true);
        }

        Objutil.deepMerge(clientConfig, options);

        setImmediate(callback.bind(null, null, options));
    });

    // eslint-disable-next-line no-shadow
    function onConfigChange(configObject, clientId) {
        // eslint-disable-next-line no-shadow
        const clientPath = `services:${clientId}`;
        // reset command cache to recreate them with updated values
        const circuitConfig = configObject.get(clientPath).circuit;
        // calculate state to see if we need to rebuild the pipe
        const state = pipeModifiedStates[clientId] = pipeModifiedStates[clientId] || {};

        for (let i = 0; i < STATE_FIELDS.length; i++) {
            const name = STATE_FIELDS[i];
            if (state[name] !== circuitConfig[name]) {
                logger.info(`config change detected for ${clientId}, cleaned up the command cache to rebuild`);
                // change requires refresh
                pipeModifiedStates[clientId] = Object.assign({}, circuitConfig);
                circuitPipes[clientId] = buildCircuitPipe(configObject.get(clientPath).circuit);
                commandFactory.resetCache();
                return;
            }
        }
    }
};

function addMapping(def, baseConf, basePath, rootKey) {
    Object.keys(baseConf).forEach((key) => {
        if (typeof baseConf[key] === 'object' && !Array.isArray(baseConf[key])) {
            return addMapping(def,
                baseConf[key],
                `${basePath + key}:`,
                `${rootKey ? rootKey + key : key}:`);
        }
        if (key === 'circuitBreakerForceClosed' ||
            key === 'circuitBreakerForceOpened') {
            // do not expose them into config bean
            // control is via SVC_CHANNEL_STATUS
            return;
        }
        def[basePath + key] = rootKey ? rootKey + key : key;
    });
}

proto.isForceMarkdown = function isForceMarkdown() {
    const status = this.state && this.state.get('SVC_CHANNEL_STATUS');
    return status && /MARK_DOWN$/.test(status) && status !== 'APP_AUTO_MARK_DOWN';
};

proto.isAutoMarkdown = function isAutoMarkdown() {
    const status = this.state && this.state.get('SVC_CHANNEL_STATUS');
    return status === 'APP_AUTO_MARK_DOWN';
};

proto.closeCircuit = function closeCircuit() {
    this.state && this.state.set('SVC_CHANNEL_STATUS', 'MARK_UP');
};

proto.openCircuit = function openCircuit() {
    this.state && this.state.set('SVC_CHANNEL_STATUS', 'APP_AUTO_MARK_DOWN');
};

proto.forceOpenCircuit = function forceOpenCircuit() {
    this.state && this.state.set('SVC_CHANNEL_STATUS', 'MARK_DOWN');
};

proto.setTlsSocketProtocol = function (tlsSocketProtocol) {
    this.state && this.state.set('tlsSocketProtocol', tlsSocketProtocol);
};

/*
The metricx goes to CAL as a heartbeat and gets published into TSDB
*/
let timer;

function enableHystrixMetricsPublishing(enabled, interval) {
    if (enabled === false) {
        clearInterval(timer);
        timer = undefined;
        return timer;
    }

    if (!timer) {
        timer = setInterval(() => {
            const clientIds = Object.keys(circuitPipes);
            Async.eachSeries(clientIds, (clientId, next) => {
                publishHystrixMetrics(clientId);
                setImmediate(next);
            });
        }, parseInt(interval) || 60000);
        timer.unref();
    }

    return timer;
}

function normalize(val) {
    return val ? val.replace(/\//, '.') : val;
}

function publishHystrixMetrics(clientId) {
    const metrics = generateMetrics(clientId);
    const hb = Cal.createHeartbeat('HystrixCommand', clientId);
    hb.addData(metrics);
    hb.complete();
}

module.exports.enableHystrixMetricsPublishing = enableHystrixMetricsPublishing;
module.exports.publishHystrixMetrics = publishHystrixMetrics;
module.exports.reset = function reset() {
    circuitFactory.resetCache();
    metricsFactory.resetCache();
    commandFactory.resetCache();
    pipeModifiedStates = {};
    timer && clearInterval(timer);
};

function generateMetrics(clientId) {
    const metrics = metricsFactory.getOrCreate({ commandKey: clientId });

    const healthCounts = metrics.getHealthCounts();

    return {
        'm:resSecs': 60,
        't:name': normalize(clientId),
        'g:errorPercentage': healthCounts.errorPercentage || 0,
        'g:rollingCountEmit': 0,
        'g:rollingCountFallbackEmit': 0,
        'g:rollingCountFailure': metrics.getRollingCount('FAILURE') || 0,
        'g:rollingCountSuccess': metrics.getRollingCount('SUCCESS') || 0,
        'g:rollingCountFallbackFailure': metrics.getRollingCount('FALLBACK_FAILURE') || 0,
        'g:rollingCountFallbackSuccess': metrics.getRollingCount('FALLBACK_SUCCESS') || 0,
        'g:rollingCountFallbackRejection': 0, // contribute to hystrixjs to generate this metrics
        'g:rollingCountTimeout': metrics.getRollingCount('TIMEOUT') || 0,
        'g:rollingCountExceptionsThrown': 0,
        'g:rollingCountCollapsedRequests': 0,
        'g:rollingCountBadRequest': 0,
        'g:rollingCountResponsesFromCache': 0,
        'g:rollingCountShortCircuited': metrics.getRollingCount('SHORT_CIRCUITED') || 0,
        'g:latencyExecute_mean': metrics.getExecutionTime('mean') || 0,
        'g:latencyTotal_mean': metrics.getExecutionTime('mean') || 0,
        'g:executionSemaphorePermitsInUse': metrics.getCurrentExecutionCount() || 0,
        'g:rollingCountThreadPoolRejected': 0,
        'g:rollingCountSemaphoreRejected': metrics.getRollingCount('REJECTED') || 0
    };
}

module.exports.generateMetrics = generateMetrics;

function registerHystrixComponentStatus(clientId) {
    /*
        Register hystrix metrics component status if validate internals is available
    */
    if (Vi) {
        const name = `${clientId}-hystrix-command`;
        Vi.register(name, () => {
            const metrics = metricsFactory.getOrCreate({ commandKey: clientId });
            const circuitBreaker = circuitFactory.getOrCreate({ commandKey: clientId });

            function createEntry(key, value) {
                return {
                    name: key,
                    value: value
                };
            }

            const success = metrics.getCumulativeCount('SUCCESS');
            const error = metrics.getCumulativeCount('FAILURE');
            const timeout = metrics.getCumulativeCount('TIMEOUT');
            const shortCircuited = metrics.getCumulativeCount('SHORT_CIRCUITED');

            const fallbackFailure = metrics.getCumulativeCount('FALLBACK_FAILURE');
            const fallbackSuccess = metrics.getCumulativeCount('FALLBACK_SUCCESS');

            return {
                name: name,
                alias: name,
                properties: [
                    createEntry('CircuitBreakerStatus', circuitBreaker.isOpen() ? 'Open' : 'Closed'),
                    createEntry('TotalCount',
                        success + error + timeout + shortCircuited
                    ),
                    createEntry('SuccessCount', success),
                    createEntry('ErrorCount', error),
                    createEntry('FailureCount', error + timeout),
                    createEntry('TimeoutCount', timeout),
                    createEntry('FallBackSucessCount', fallbackSuccess),
                    createEntry('FallBackFailureCount', fallbackFailure),
                    createEntry('AverageLatency', metrics.getExecutionTime('mean'))
                ]
            };
        });
    }
}

function ConfigBeanWrapper(clientId, bean) {
    Assert.ok(bean);
    this.clientId = clientId;
    this.bean = bean;
}

proto = ConfigBeanWrapper.prototype;

proto.get = function get(name) {
    return this.bean.get(name);
};

proto.set = function set(name, value) {
    this.bean.set(name, value);
};
