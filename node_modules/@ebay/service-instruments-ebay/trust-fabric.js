'use strict';

const logger = require('@ebay/logging-inc').logger('service-instruments-ebay/trust-fabric');
const trustFabricClient = require('@ebay/trust-fabric-ebay');
const { isExternalService } = require('./lib/utils');

module.exports = function trustFabric(pipe) {
    pipe.on('request', async (request, next) => {
        const clientId = pipe.context.clientId;

        const options = request;
        options.headers = options.headers || {};

        const tfConfig = request['trust-fabric'];
        // setting up scopes requires manually building a new TokenGenerator, default token generator does
        // zero scope management for us.
        let tokenGenerator;
        if (tfConfig?.scopes && tfConfig.scopes instanceof Array) {
            tokenGenerator = new trustFabricClient.TokenGenerator({ scopes: tfConfig.scopes });
        }
        else {
            // fall back to the trust-fabric-client default export instance
            tokenGenerator = trustFabricClient;
        }
        const tfHeader = tokenGenerator.getTfHeader();

        if (!tfHeader || tfConfig === false) {
            return next();
        }

        // adding force flag to trust-fabric config to hard enable TF for critical services
        const forceEnabled = tfConfig?.force === true;

        const isAppWiredOn = await new Promise(resolve => tfHeader.isAppWiredOn(enable => resolve(enable)));
        const isExternal = await isExternalService(request.hostname);

        const isAppEnabled = forceEnabled || (isAppWiredOn && !isExternal);

        logger.info(`[TRUST-FABRIC] Trust fabric enabled: ${isAppEnabled} ` +
            `(force: ${forceEnabled}, wiredOn: ${isAppWiredOn}, external: ${isExternal}), clientId: ${clientId}`);

        if (isAppEnabled) {
            tokenGenerator.getToken((err, tfToken) => {
                if (err) {
                    // log only for information purposes here
                    logger.warn(`[TRUST-FABRIC] Error while getting token, clientId: ${clientId}`,
                        { error: err.message, stack: err.stack });
                }

                if (!err && tfToken) {
                    const headerName = tfConfig && tfConfig.headerName;
                    const addAuthorizationHeader = tfConfig && tfConfig.addAuthorizationHeader || false;

                    const headersToAdd = [];

                    if (addAuthorizationHeader) {
                        options.headers.authorization = `Bearer ${tfToken}`;
                        headersToAdd.push('authorization');
                    }

                    if (headerName) {
                        const name = headerName.name || headerName;
                        const prefix = headerName.bearer ? `Bearer ` : '';
                        options.headers[name] = `${prefix}${tfToken}`;
                        headersToAdd.push(name);
                    }

                    options.headers['x-ebay-tf-authorization'] = `Bearer ${tfToken}`;
                    headersToAdd.push('x-ebay-tf-authorization');
                }
                else if (!tfToken && !err) {
                    logger.warn(`[TRUST-FABRIC] No token received (no error), clientId: ${clientId}`);
                }

                next();
            });
        }
        else {
            logger.warn(`[TRUST-FABRIC] TrustFabric token is disabled for this app, clientId: ${clientId}`, {
                hostname: request.hostname,
                force: forceEnabled,
                appWiredOn: isAppWiredOn,
                external: isExternal
            });
            next();
        }
    });
};
