'use strict';

const deployEnv = require('@ebay/environment-ebay');
const logger = require('@ebay/logging-inc').logger('service-instruments-ebay/discovery');
const URL = require('url').URL;
const ConfigUtils = require('@ebay/module-config-inc/lib/utils');
const cfgBean = require('@ebay/config-bean-ebay');
const sdEbay = require('@ebay/service-discovery-ebay');
const DISCOVERY_COMPONENT_STATUS_BEAN_ID = 'ServiceDiscoveryClientComponentStatus';
const TLS = {
    'TLSv1.1': 'TLSv1_method',
    'TLSv1.2': 'TLSv1_2_method'
};
const { normalizeModuleName } = require('./lib/utils');

sdEbay.loadCacheFromFile()
    .catch(e => {
        const m = 'Unable to build service-discovery cache from file, trying to refresh ';
        if (deployEnv.isDev() || deployEnv.isTest()) {
            logger.warn(m, e);
        }
        else {
            logger.error(m, e);
        }

        // eslint-disable-next-line no-shadow
        sdEbay.refreshCache().catch(e => {
            // eslint-disable-next-line no-shadow
            const m = 'Unable to refresh service-discovery and build cache';
            if (deployEnv.isDev() || deployEnv.isTest()) {
                logger.warn(m, e);
            }
            else {
                logger.error(m, e);
            }
        });
    });

module.exports = function discovery(pipe) {
    pipe.on('request', async (request, next) => {
        const clientId = pipe.context.clientId;
        const pipeConfig = pipe.config || {};
        if (pipeConfig.discovery === false) {
            logger.info('Service discovery, disabled', clientId);
            next(); // discovery is disabled for this service/clientId
        }
        else {
            const appLabels = pipeConfig.applicationLabels || {};
            const cout = sdEbay.lookup(pipeConfig.urn, appLabels);
            if (cout) {
                logger.info(`Service discovery, cache hit`, clientId);
                cout.serviceEndpoint = updateConfigBean(pipe, clientId, cout.serviceEndpoint);
                const newRequest = patchRequest(request, cout);
                next(newRequest);
            }
            else {
                logger.info('Service discovery, cache miss %s, falling back to config', clientId);
                next();
            }
        }
    });
};

function patchRequest(request, cout) {
    const u = new URL(cout.serviceEndpoint);
    const obj = {
        protocol: u.protocol,
        hostname: u.hostname,
        port: u.port
    };
    if (cout.metadata && cout.metadata.tlsVersion) {
        obj.secureProtocol = TLS[cout.metadata.tlsVersion] || 'TLSv1_2_method';
    }
    const newRequest = Object.assign({}, request, obj);
    if (obj.protocol === 'http:') {
        delete newRequest.https;
        newRequest.agent = false;
    }
    if (obj.protocol === 'https:' && !request.https) {
        newRequest.https = 'eBayRootCert';
    }
    return newRequest;
}

/**
 * Priority of resolution : if(already discovered) use (config-bean endpoint)
 * else (use service-discovery endpoint & update cfBean endpoint)
 **/
function updateConfigBean(pipe, clientId, serviceEndpoint) {
    const moduleRef = pipe.context.caller || module;
    const modRoot = ConfigUtils.moduleRoot(moduleRef);
    const moduleName = normalizeModuleName(ConfigUtils.moduleName(modRoot));
    const cfBean = cfgBean.getBeanById(`nodejs.config.${moduleName}.${clientId}`);
    if (!cfBean) {
        return serviceEndpoint;
    }
    const compStatusBean = cfgBean.getBeanById(DISCOVERY_COMPONENT_STATUS_BEAN_ID);
    const u = new URL(serviceEndpoint);
    if (cfBean && cfBean.get('_discovered') === undefined) {
        // Updating original properties & keeping a track of old ones
        cfBean.setPersist('_discovered', Date.now());
        cfBean.setPersist('_orig_protocol', cfBean.get('protocol'));
        cfBean.setPersist('_orig_hostname', cfBean.get('hostname'));
        cfBean.setPersist('_orig_port', cfBean.get('port'));
        cfBean.setPersist('protocol', u.protocol);
        cfBean.setPersist('hostname', u.hostname);
        cfBean.setPersist('port', u.port);
        // cache[clientId].secureProtocol && cfBean.setPersist('secureProtocol', cache[clientId].secureProtocol);
    }
    else if (cfBean && cfBean.get('_discovered') < compStatusBean.get('lastUpdatedTime')) {
        cfBean.setPersist('_discovered', Date.now());
        cfBean.setPersist('protocol', u.protocol);
        cfBean.setPersist('hostname', u.hostname);
        cfBean.setPersist('port', u.port);
    }
    else {
        serviceEndpoint = `${cfBean.get('protocol')}//${
            cfBean.get('hostname')}${cfBean.get('port') ? `:${cfBean.get('port')}` : ''}`;
        logger.info('Service discovery resolution from configbean, %s, %s', clientId, serviceEndpoint);
    }
    return serviceEndpoint;
}
