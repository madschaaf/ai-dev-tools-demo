'use strict';

const cal = require('@ebay/cal');

const Stream = require('@ebay/streams-ebay'),
    EventStream = Stream.EventStream,
    ChunkedStream = Stream.ChunkedStream,
    Hoek = require('hoek'),
    httpfy = require('./http-api');

const Objutil = require('objutil');
const StreamUtils = require('./stream-utils');
const TransportUtils = require('./utils');

/**
 * Generic transport is just a passthrough to httpunch (regular http request) with JSON parsing for JSON content-type.
 * @type {exports}
 */
module.exports = function sseTransport(pipe, config) {
    pipe.on('request', (request) => {
        const st = Date.now();
        let req;        //eslint-disable-line
        let responseStream;
        let isFinished;

        const onceError = Hoek.once((err) => {
            isFinished = true;
            pipe.throw(err);
        });

        config && Objutil.merge(config, request);

        const eventhose = new EventStream();

        eventhose
            .on('data', function onstreamdata(eventdata) {
                let eventErr;

                if (eventdata) {
                    if (eventdata.is('error')) {
                        eventErr = eventdata;
                    }
                    else if (eventdata.is('end-event')) {
                        this.emit('end');
                        return;
                    }

                    if (req.res.headers['sse-content-type'] === 'application/json') {
                        eventdata = eventdata.toJson();
                    }

                    cal.createTransaction('Model', eventdata.name, (
                        err, event) => {
                        event.timestamp = st;
                        event.complete();
                    });
                }

                if (eventErr) {
                    eventErr = new Error('Error Event Received');
                    eventErr = Objutil.mixin(eventdata, eventErr);
                    pipe.throw(eventErr);
                }
                else {
                    responseStream = responseStream || pipe.streamResponse(req.res);
                    responseStream.write(eventdata);
                }
            })
            .once('error', (err) => {
                let statusCode = req.res && req.res.statusCode;

                statusCode = statusCode >= 400 ? statusCode : statusCode;
                err.statusCode = statusCode || 'ParseError';

                onceError(err);
            })
            .once('finish', () => {
                if (isFinished) {
                    return;
                }
                if (!responseStream) {
                    return pipe.respond(req.res);
                }
                responseStream.end();
            });

        // add x-forwarded-for
        TransportUtils.addXFF(pipe, request, config);

        req = StreamUtils.startStream(request);
        req.on('error', onceError);
        req.once('response', (response) => {
            req.res = response;
            if (response.statusCode >= 300) {
                /** Handle this for redirection cases separately..
                 Redirections are valid data
                 ***/
                response.once('finish', () => {
                    pipe.respond(req.res);
                });
                return;
            }

            const stream = new ChunkedStream();
            stream.pipe(eventhose);
            response.pipe(stream);
        });

        req.end();
    });

    httpfy(pipe);
};
