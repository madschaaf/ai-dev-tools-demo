'use strict';

const Assert = require('assert');
const Httpunch = require('@ebay/httpunch');
const Objutil = require('objutil');
const NodeUtils = require('util');

const Cal = require('@ebay/cal');
const Legacy = require('../lib/legacy');
const debug = require('debug')('@ebay/service-client-ebay/transport');
const Pkg = require('../package.json');

const logger = require('@ebay/logging-inc').logger('service-instruments-ebay/utils');

const MASKED_NAMES = [
    'authorization',
    'x-ebay-tf-authorization',
    'x-ebay-session-authorization'
];

module.exports.addXFF = function (pipe, request, config) {
    const xffEnabled = request && request.xff !== undefined ? request.xff : config && config.xff;
    if (xffEnabled === false) {
        return;
    }
    const app = pipe.context.app;
    const webRequestHeaders = app && app.request && app.request.headers || {};

    let xff = webRequestHeaders['x-forwarded-for'] || '';

    if (webRequestHeaders['x-ebay-client-ip']) {
        xff += (xff ? ',' : '') + webRequestHeaders['x-ebay-client-ip'];
    }

    if (xff) {
        request.headers['x-forwarded-for'] = xff;
    }
};

module.exports.updateRequest = function updateRequest(request) {
    request.protocol = Httpunch.utils.suffix(request.protocol || 'https:', ':');
    request.method = request.method || 'POST';

    Assert.ok(Httpunch.utils.isHttpMethod(request.method), `method ${request.method} is not an http method.`);
    Assert.ok(request.hostname, 'hostname must be defined.');

    request.agent || Httpunch.agents.create(request);

    if (!request.headers['user-agent']) {
        request.headers['user-agent'] = Httpunch.utils.userAgentString({
            name: Pkg.name,
            version: Pkg.version
        });
    }

    Legacy.updateRequest(request);

    if (request.search) {
        // adjust for httpunch query string from standard
        request.qs = request.search;
    }

    debug('transport(): %s//%s:%s%s',
        request.protocol,
        request.hostname,
        request.port,
        request.path);
};

module.exports.validateLongVip = request => {
    if (request.hostname && /\.(stratus|vip)$/.test(request.hostname)) {
        logger.warn('Detected short vip %s that must be fixed, this will become error in near future',
            request.hostname);
    }
};

module.exports[Symbol.for('internals')] = {
    logger
};

function sanitize(obj, headersToMask) {
    if (obj && typeof obj === 'object') {
        const addlHeadersToMask = MASKED_NAMES.concat(headersToMask || []);
        return Object.keys(obj).reduce((memo, name) => {
            if (addlHeadersToMask.includes(name.toLocaleLowerCase())) {
                memo = memo || Objutil.clone(obj);
                memo[name] = '******';
            }
            return memo;
        }, undefined) || obj;
    }
    return obj;
}

module.exports.sanitize = sanitize;

function generateHeadersInfo(headers, headersToMask) {
    if (headers) {
        headersToMask = headersToMask || [];
        const evt = Cal.createEvent('request', 'RequestHeaders')
            .addData(sanitize(headers, headersToMask));
        evt.type = evt.parent && evt.parent.name || evt.type;
        evt.complete();
    }
}

module.exports.generateHeadersInfo = generateHeadersInfo;

function generateMetricsEvents(metrics) {
    metrics.events.forEach((event) => {
        const tx = Cal.createTransaction('request', event.name);
        tx._doComplete = function noon() {
        };
        tx.type = tx.parent && tx.parent.name || tx.type;
        tx.timestamp = event.start;
        tx.duration = event.duration;
        tx.complete();
    });
}

module.exports.generateMetricsEvents = generateMetricsEvents;

module.exports.attachHostInfo2Error = function attachHostInfo2Error(error, request) {
    if (error && error.message) {
        error.message = NodeUtils.format('Host: %s//%s:%s, error: %s',
            request.protocol,
            request.hostname,
            request.port || 80,
            error.message);
    }
};
