/* eslint-disable no-shadow */
'use strict';
/* eslint-disable no-var,prefer-arrow-callback,prefer-spread,no-console */

var httpfy = require('trooba-http-api');
var Hmv = require('@ebay/header-multi-value-ebay');
var Utils = require('../lib/browser-utils');
var Legacy = require('../lib/legacy');

var Client = httpfy.Client;
var Request = httpfy.Request;
var legacyCounter = 0;

var promise = Promise.resolve();
function defer(fn) {
    promise.then(fn).catch(rethrow);
}

function rethrow(err) {
    setTimeout(function () {
        throw err;
    });
}

/**
 * Provides ebay extended API based on trooba-http-api module
 */
module.exports = function httpApi(pipe) {
    httpfy(pipe, pipe.context.ClientCtr || ExtendedClient);
};

module.exports.api = function api(pipe) {
    return new ExtendedClient(pipe);
};

function ExtendedClient() {
    Client.apply(this, arguments);
}

module.exports.ExtendedClient = ExtendedClient;

ExtendedClient.prototype = Object.create(Client.prototype);

ExtendedClient.prototype.request = function request(request) {
    return Client.prototype.request.call(this, request, ExtendedRequest);
};

// Keep backward compatible with old code
ExtendedClient.prototype.post = function post(options) {
    if (options.body !== undefined || options.request !== undefined || options.wsdl) {
        options.method = 'POST';
        return this.request(options);
    }
    return Client.prototype.post.call(this, options);
};

ExtendedClient.prototype.context = function context(ctx) {
    // support request based context or context that is already formated as ctx.app
    if (ctx.res && !ctx.app) {
        ctx = {
            app: {
                request: ctx,
                response: ctx.res
            }
        };
    }
    else {
        ctx = Object.assign({}, ctx);
    }
    var newClient = new ExtendedClient(this.pipe, this.config);
    newClient.ctx = ctx;
    return newClient;
};

function ExtendedRequest() {
    Request.apply(this, arguments);
}

ExtendedRequest.prototype = Object.create(Request.prototype);

ExtendedRequest.prototype.endAsAsync = function () {
    var self = this;
    return new Promise(function (resolve, reject) {
        self.end(function (err, res) {
            if (err) {
                return reject(err);
            }
            resolve(res);
        });
    });
};

ExtendedRequest.prototype.end = function end(callback) {
    var request = this.request;
    // handle legacy code to keep backward compatibility
    Legacy.updateBody(request);

    var pipe = Request.prototype.end.apply(this);
    var _response;

    if (callback) {
        // we would like to avoid promise capture and stream uncaught errors into callbacks
        callback = asyncCallback(callback);
        // dedup trooba pipe errors thrown via pipe.throw(err)
        var onceCallback = Utils.once(callback);
        pipe.on('response', function onResponse(response, next) {
            if (!pipe.context.$responseStream) {
                return onceCallback(null, response);
            }
            _response = response;
            next();
        });
        pipe.on('response:data', function onData(data, next) {
            callback(null, {
                statusCode: _response.statusCode,
                body: data,
                headers: _response.headers
            });
            next();
        });
        pipe.on('error', function onErr(err) {
            onceCallback(err);
        });
    }

    return pipe;
};

function asyncCallback(orig) {
    return function () {
        var args = arguments;
        defer(function () {
            orig.apply(null, args);
        });
    };
}

// add multi value support
ExtendedRequest.prototype.set = function set(key, value) {
    var hmvKey;
    // adding support for multi value headers on server and client side
    if (arguments.length === 3) {
        hmvKey = arguments[0];
        key = arguments[1];
        value = arguments[2];
        var current = this.request.headers[hmvKey];
        if (current) {
            if (typeof current !== 'object') {
                // assume multivalue is already stringified, so parse it back
                current = Hmv.parse(current);
            }
        }
        else {
            // if does not exist, create one
            current = Hmv.create({});
        }
        // set the value
        current.set(key, value);
        // make sure it is set back to headers (it will be stringified automatically via toString)
        this.request.headers[hmvKey] = current;
        this.request.mvheaders = this.request.mvheaders || {};
        this.request.mvheaders[hmvKey] = true;
    }
    else if (arguments.length === 1) {
        hmvKey = arguments[0];
        var self = this;
        return {
            set: function _set(name, value) {
                self.set(hmvKey, name, value);
                return this;
            },
            build: function _build() {
                return self;
            }
        };
    }
    else {
        Request.prototype.set.apply(this, arguments);
    }
    return this;
};

// backwards compatibility with legacy code
ExtendedRequest.prototype.header = function headerDeprecated(key, value) {
    showDeprecationMessage('header(key, value) function has been deprecated, please use set(key, value)');
    return this.set.apply(this, arguments);
};

ExtendedRequest.prototype.headers = function headersDeprecated(kvps) {
    // eslint-disable-next-line max-len
    showDeprecationMessage('headers(kvps) function has been deprecated, please use set(key, value) to set header values');
    var self = this;
    Object.keys(kvps).forEach(function forEach(key) {
        self.set(key, kvps[key]);
    });
    return this;
};

ExtendedRequest.prototype.fallback = function fallback(fn) {
    this.context.fallback = fn;
    return this;
};

function showDeprecationMessage() {
    if (legacyCounter++ < 20) {
        console.log.apply(console, arguments);
    }
}
