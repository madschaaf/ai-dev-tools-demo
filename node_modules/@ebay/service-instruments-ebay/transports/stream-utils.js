'use strict';

const Httpunch = require('@ebay/httpunch');
const debug = require('debug')('@ebay/service-instruments-ebay/stream');
const TransportUtils = require('./utils');

module.exports.startStream = function startStream(request) {
    TransportUtils.updateRequest(request);
    TransportUtils.validateLongVip(request);

    debug('# request:', request);
    const req = Httpunch.request(request);
    process.domain && process.domain.add(req);
    let httpErr;

    req.once('response', (res) => {
        req.res = res;
        if (res.statusCode >= 300 && res.statusCode < 400) {
            Httpunch.utils.read(res, (err, result) => {
                res.body = result;
                req.res.emit('finish');
            });
        }
        else if (res.statusCode >= 400) {
            httpErr = new Error(`HTTP ${res.statusCode}`);
            httpErr.statusCode = res.statusCode;

            httpErr.message = '';
            httpErr.res = res;
            Httpunch.utils.read(res, (err, result) => {
                if (result) {
                    res.body = result;
                    httpErr.message += result.toString();
                }
                req.emit('error', httpErr);
            });
        }

        // TODO: enable below once response timeout becomes available
        // res.once('error', function (err) {
        //     if (err.code === 'ECONNRESET') {
        //         err.code = 'ETIMEDOUT';
        //     }
        //     reply(err);
        // });
    });
    req.once('finish', () => {
        if (request.debug === true || request.debug === 'true') {
            const addlMaskheaders = request.maskHeaders || [];
            TransportUtils.generateHeadersInfo(request.headers, addlMaskheaders);
            TransportUtils.generateMetricsEvents(req.metrics);
        }
    });
    req.once('abort', function () {
        const err = new Error('Connection aborted');
        err.code = 'ETIMEDOUT';
        this.emit('error', err);
    });

    return req;
};
