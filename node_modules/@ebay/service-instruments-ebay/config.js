'use strict';

const moduleConfig = require('@ebay/module-config-inc');
const debug = require('debug')('@ebay/service-instruments-ebay/config');
const Objutil = require('objutil');
const Trooba = require('trooba');
const Async = require('async');
const Resolver = require('./lib/resolver');
const AsyncValue = require('raptor-async/AsyncValue');
const { getClientConfigOrInjectDefault } = require('./lib/utils');

const logger = require('@ebay/logging-inc').logger(
    'service-instruments-ebay/config');

const pipes = {};
const configs = {};

const shortVipRegEx = new RegExp(/(.)*\.(vip|stratus)$/);

/*
 * Config provider that uses module-config-inc if available
 * This is ebay specific functionality that will be removed once the module goes public
*/
module.exports = function config(pipe, cfg) {
    debug('# config handler invoked', cfg);

    const clientId = pipe.context.clientId;
    const caller = pipe.context.caller;
    const configured = new AsyncValue();
    // merge config to request context
    let svcClientConfig;

    if (!clientId) {
        throw new Error('clientId is missing in the context');
    }

    let pipeConfig = configs[clientId];
    if (pipeConfig) {
        debug('# cached pipe config for', clientId);
        resolveAndLink();
    }
    else {
        debug('# creating pipe config for', clientId);
        initResolveAndLink();
    }

    pipe.on('request', (request, next) => {
        logger.info(`[CONFIG] Starting config handler for clientId: ${clientId}`);
        debug('# running config handler %s with root %s and meta location: %s',
            clientId, caller, cfg && cfg.location || 'default');

        configured.done((err) => {
            if (err) {
                return pipe.throw(err);
            }
            // inject client config
            // merge config to request context
            Objutil.deepMerge(svcClientConfig, request);
            next(request);
        });
    });

    function initResolveAndLink() {
        debug('# init pipe config', clientId, caller);
        Async.parallel({
            lib: moduleConfig.bind(null, cfg && cfg.location || module),
            client: moduleConfig.bind(null, caller)
        // eslint-disable-next-line no-shadow
        }, (err, config) => {
            if (err) {
                configured.reject(err);
                return;
            }

            pipeConfig = configs[clientId] =
                configs[clientId] || new PipeConfig(clientId, config);
            resolveAndLink();
        });
    }

    function resolveAndLink() {
        debug('# resolve a pipe', clientId, caller);
        // HTTPS Overrides
        httpsOverrides(pipeConfig);

        svcClientConfig = pipeConfig.clientConfig;
        const pipeMeta = pipeConfig.resolve(pipe);
        if (pipeMeta.instruments.length) {
            let cfgPipe = pipes[pipeMeta.key];
            if (!cfgPipe) {
                debug('# building the pipe', pipeMeta.key);
                cfgPipe = pipes[pipeMeta.key] = buildPipe(pipeMeta);
            }

            debug('# linking pipe', pipeMeta.key);
            cfgPipe && pipe.link(cfgPipe);
        }
        configured.resolve();
    }
};

function PipeConfig(clientId, config) {
    this.clientId = clientId;
    this.config = config;

    this.initConfig();
    this.loadInstruments();
    this.loadMetadata();
}

module.exports.PipeConfig = PipeConfig;

PipeConfig.prototype.initConfig = function initConfig() {
    debug('# loading configuration for', this.clientId);

    const clientConfig = getClientConfigOrInjectDefault(this.config.client, this.clientId);
    const clientLibConfig = this.config.client.get('service-instruments-ebay');
    const libConfig = this.config.lib.get('service-instruments-ebay');

    if (!clientConfig) {
        throw new Error(`Cannot find configuration for clientId: ${this.clientId}`);
    }

    // the consumer can also define everything in-line (inside client config)
    // but it is not shared between other clients
    debug('# configuration for', this.clientId, 'is', clientConfig);

    this.clientConfig = clientConfig;
    this.clientLibConfig = clientLibConfig;
    this.libConfig = libConfig;
};

/**
 * Updates instruments with mandatory ones unless they are explicitly disabled
 * @param {string[]} instruments
 * @param {any} clientConfig
 * @returns
 */
module.exports.updateInstruments = function (instruments, clientConfig) {
    instruments = [...instruments];
    if (clientConfig['add-instruments']) {
        // clone it and add to it with concat
        instruments = instruments.concat(clientConfig['add-instruments']);
    }

    // add tracing by default only to the configs with custom instrument list
    // if tracing was not explicitly disabled and is not already in the list of instruments
    if (clientConfig.instruments && clientConfig.tracing !== false && instruments.indexOf('tracing') === -1) {
        instruments = instruments.concat('tracing');
    }

    // add metrics by default only to the configs with custom instrument list
    // if metrics was not explicitly disabled and is not already in the list
    // of instruments
    if (clientConfig.instruments && clientConfig.metrics !== false && instruments.indexOf('metrics') === -1) {
        instruments = instruments.concat('metrics');
    }

    // add discovery by default only to the configs with custom instrument list
    // if discovery was not explicitly disabled and is not already in the list of instruments
    if (clientConfig.instruments && clientConfig.discovery !== false && instruments.indexOf('discovery') === -1) {
        instruments = instruments.concat('discovery');
    }

    // add trust fabric by default only to the configs with custom instrument list
    // if trust fabric was not explicitly disabled and is not already in the list of instruments
    if (clientConfig.instruments && clientConfig['trust-fabric'] !== false &&
    instruments.indexOf('trust-fabric') === -1) {
        instruments = instruments.concat('trust-fabric');
    }

    // add https by default only to the configs with custom instrument list
    // if https was not explicitly disabled and is not already in the list of instruments
    if (clientConfig.instruments && clientConfig.https !== false && instruments.indexOf('https') === -1) {
        instruments = instruments.concat('https');
    }

    // add aid by default only to the configs with custom instrument list
    // if aid was not explicitly disabled and is not already in the list of instruments
    if (clientConfig.instruments && clientConfig.aid !== false && instruments.indexOf('aid') === -1) {
        instruments = instruments.concat('aid');
    }

    // add traffic-mirror by default only to the configs with custom instrument list
    // if traffic-mirror was not explicitly disabled and is not already in the list of instruments
    if (clientConfig.instruments && clientConfig['traffic-mirror'] !== false
        && instruments.indexOf('traffic-mirror') === -1) {
        instruments = instruments.concat('traffic-mirror');
    }

    // add header-propogation by default only to the configs with custom instrument list
    // if header-propogation was not explicitly disabled and is not already in the list of instruments
    if (clientConfig.instruments && clientConfig['header-propagation'] !== false
        && instruments.indexOf('header-propagation') === -1) {
        instruments = instruments.concat('header-propagation');
    }

    // add sddz-proxy by default only to the configs with custom instrument list
    // if sddz-proxy was not explicitly disabled and is not already in the list of instruments
    if (clientConfig.instruments && clientConfig['sddz-proxy'] !== false
        && instruments.indexOf('sddz-proxy') === -1) {
        instruments = instruments.concat('sddz-proxy');
    }

    return instruments;
};

PipeConfig.prototype.loadInstruments = function loadInstruments() {
    const clientConfig = this.clientConfig;
    const instruments = clientConfig.instruments ||
        this.libConfig['default-instruments'] || [];

    this.instruments = module.exports.updateInstruments(instruments, clientConfig);
    this.clientConfig = clientConfig;
    this.transport = clientConfig.transport;
};

PipeConfig.prototype.loadMetadata = function loadMetadata() {
    this.instrumentsMeta = this.libConfig['instruments-metadata'];
    if (this.instrumentsMeta) {
        debug('# loaded instrument metadata', this.instrumentsMeta);
        this.instrumentsMeta =
            Resolver.updateInstrumentsMetadata(this.instrumentsMeta);
    }
    if (this.clientLibConfig) {
        const clientInstrumentMeta = this.clientLibConfig['instruments-metadata'];
        this.instrumentsMeta =
            clientInstrumentMeta ?
                Resolver.updateInstrumentsMetadata(clientInstrumentMeta) :
                this.instrumentsMeta;
    }
};

PipeConfig.prototype.resolve = function resolve(pipe) {
    const self = this;
    let key = this.clientId;
    let instruments = pipe.context.instruments || this.instruments;
    debug('# instruments:', instruments);
    // if context has extra instrument metadata resolve it into instrument list
    if (this.instrumentsMeta) {
        instruments = instruments.map((name) => {
            if (typeof name === 'string') {
                const meta = self.instrumentsMeta[name];
                if (meta) {
                    return meta;
                }
            }
            return name;
        });
        debug('# resolved instruments', instruments);
    }

    instruments = Resolver.resolveInstruments(instruments);
    instruments.forEach((instr) => {
        key = key || 'key';
        key += `:${instr.name}`;
    });

    let transport = pipe.context.transport || this.transport;
    if (transport) {
        debug('# adding transport from config', transport.name || transport);
        key += `:${transport}`;
        // this is lazy binding of transport
        transport = Resolver.resolveInstrumentMeta(transport);
        instruments.push(transport);
    }

    return {
        key: key,
        instruments: instruments,
        config: this.clientConfig
    };
};

function buildPipe(pipeMeta) {
    const pipe = new Trooba();
    // resolve instruments and build pipe
    pipeMeta.instruments.forEach((meta) => {
        debug('# registering handler', meta.module);
        pipe.use(meta.instrument, pipeMeta.config);
    });

    return pipe.build();
}

function httpsOverrides(pipeConfig) {
    const clientConfig = pipeConfig.clientConfig;
    const httpsEnforcement = process.env.ENABLE_HTTPS === 'true' || process.env.ENABLE_HTTPS === true;
    if (httpsEnforcement) {
        if (!clientConfig.protocol || clientConfig.protocol === 'http:') {
            clientConfig.protocol = 'https:';
            if (clientConfig.port === 80 || clientConfig.port === '80') {
                clientConfig.port = 443;
            }
        }

        if (clientConfig.protocol === 'https:') {
            clientConfig.https = 'eBayRootCert';
        }

        // Check if hostname ends with ".vip" or ".stratus", then append with ".ebay.com"
        // e.g pes.vip => pes.vip.ebay.com
        if (shortVipRegEx.test(clientConfig.hostname)) {
            const vipMapping = pipeConfig.config.lib.get('SvcVipMappingConfig:vipMapping') || {};
            clientConfig.hostname = vipMapping[clientConfig.hostname] || clientConfig.hostname.concat('.ebay.com');
        }

        let instruments = pipeConfig.instruments;
        // if config has custom set of instrument, we should make sure it has https
        if (instruments && instruments.indexOf('https') === -1) {
            // clone it and add to it with concat
            instruments = instruments.concat('https');
            pipeConfig.instruments = instruments;
        }
    }
}
