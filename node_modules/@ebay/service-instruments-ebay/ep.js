'use strict';

const Objutil = require('objutil');

const logger = require('@ebay/logging-inc').logger(
    'service-instruments-ebay/ep');

const RuntimeError = require('./lib/errors').RuntimeError;
const Utils = require('./lib/sse-utils');

module.exports = function epHandler(pipe) {
    const app = pipe.context.app;
    const ebay = app && app.request && app.request.ebay;
    let openfeature = ebay ? ebay.openfeature : undefined;

    pipe.on('request', (request, next) => {
        let options = request;
        logger.info('ep handler', pipe.context.clientId);

        if (typeof options.ep === 'boolean' && options.ep === false) {
            openfeature = undefined;
            return next();
        }

        if (openfeature && openfeature.preflightRequestHeaders) {
            options = Objutil.mixin(options, {
                headers: {},
                ep: options.ep || 'EPRESULT'
            });
            // eslint-disable-next-line no-shadow
            openfeature.preflightRequestHeaders(options, (err, options) => {
                request = options;
                next(request);
            });
            return;
        }

        const err = new RuntimeError(
            'Cannot add experimentation headers, experimentation context is not found, ' +
            'please make sure you use experimentation middleware');
        logger.warn(err);

        next();
    });

    let isChunkedResponse;

    pipe.on('response', (response, next) => {
        if (openfeature) {
            isChunkedResponse = Utils.isChunkedResponse(response);

            if (openfeature.handleResponseHeaders &&
                !isChunkedResponse && response && response.headers) {
                // only log from headers for non-chunked responses
                openfeature.handleResponseHeaders(response.headers);
            }
        }

        next();
    });

    pipe.on('response:data', (chunk, next) => {
        if (openfeature &&
            isChunkedResponse &&
            Utils.isEpResponse(chunk)) {
            // handle EP chunk
            openfeature.handleResponseHeaders(chunk.data);
            pipe.resume(); // swallow EP chunk
            return;
        }

        next();
    });
};
