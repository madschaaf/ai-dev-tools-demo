'use strict';

const ip = require('ip');
const logger = require('@ebay/logging-inc').logger('service-instruments-ebay/tracing');
const hmvUtils = require('@ebay/header-multi-value-ebay');
const RequestLocal = require('request-local');
const Cal = require('@ebay/cal');
const otelEbay = require('@ebay/opentelemetry-ebay');
const { SemanticAttributes } = require('@opentelemetry/semantic-conventions');
const { trace, context, SpanKind, SpanStatusCode, propagation } = require('@opentelemetry/api');
const utils = require('./lib/utils');
const appContext = require('@ebay/app-context-ebay');
const tryRequire = require('try-require');
const path = require('path');
const manifest = tryRequire(path.join(process.cwd(), 'manifest.json'));
const CONST = {
    X_EBAY_C_REQUEST_ID: 'X-EBAY-C-REQUEST-ID',
    REQUEST_ID: 'ri',
    CORRELATION_REQUEST_ID: 'rci',
    NODE_ID: 'node_id'
};

const MESH_HEADERS = [
    'x-ebay-mesh-gw-name',
    'x-ebay-mesh-gw-pod-ip',
    'x-ebay-mesh-gw-duration',
    'x-ebay-mesh-gw-pod-name',
    'x-ebay-mesh-server-pod-ip',
    'x-ebay-mesh-gw-start-time',
    'x-ebay-mesh-gw-upstream-duration',
    'x-ebay-mesh-server-duration'
];

module.exports = function tracing(pipe) {
    const req = pipe.context.app ? pipe.context.app.request : undefined;
    const ebay = req && req.ebay || tryRequest();
    let span;
    const clientId = pipe.context.clientId;
    pipe.once('response', (response, next) => {
        const headers = response.headers || [];
        const rlogid = headers.rlogid;
        const evt = Cal.createEvent('request', 'Forward_RLOGID')
            .addData(`rlogid=${rlogid}`);
        evt.type = evt.parent && evt.parent.name || evt.type;
        evt.complete();

        if (span) {
            MESH_HEADERS.forEach(meshHeader => {
                if (headers[meshHeader]) {
                    span.setAttribute(meshHeader, headers[meshHeader]);
                }
            });
            span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, response.statusCode);
            span.setAttribute(SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH,
                response.headers && response.headers['content-length']);
            span.setAttribute('rlogid', rlogid);
            span.setStatus({ code: SpanStatusCode.OK });
            span.end();
        }
        next();
    });

    pipe.on('error', (err, next) => {
        if (span) {
            span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, err.statusCode || 500);
            span.setAttribute(SemanticAttributes.EXCEPTION_TYPE, err.code);
            span.setAttribute(SemanticAttributes.EXCEPTION_MESSAGE, err.message);
            span.setAttribute(SemanticAttributes.EXCEPTION_STACKTRACE, err.stack);
            span.setStatus({ code: SpanStatusCode.ERROR, message: err.code });
            span.end();
        }
        next();
    });

    pipe.on('request', (request, next) => {
        logger.info('tracing handler', pipe.context.clientId);
        const options = request;
        const tracingEnabled = options.tracing === undefined ? true : options.tracing;

        if (req && tracingEnabled) {
            options.headers = options.headers || {};

            // Log Forward Tracing RLogId for CAL link.
            if (ebay && ebay.getRlogId) {
                const rlogid = ebay.getRlogId();
                if (!options.headers.rlogid) {
                    options.headers.rlogid = rlogid;
                }
            }

            // add tracing headers (RI/RCI/Node_Id)
            if (ebay && ebay.guidGenerator) {
                const ri = ebay.guidGenerator.nextPaddedGUID();

                const tracingCtx = ebay.getCorrelationRequestId();
                const rci = tracingCtx.getCorrelationRequestId();
                const nodeId = tracingCtx.getNodeId();

                const headerVal = hmvUtils.create();
                headerVal.set(CONST.REQUEST_ID, ri);
                headerVal.set(CONST.CORRELATION_REQUEST_ID, rci);
                headerVal.set(CONST.NODE_ID, nodeId);

                options.headers[CONST.X_EBAY_C_REQUEST_ID] = headerVal.toString();
                pipe.context.tracing = { rci: rci, ri: ri, node_id: nodeId };
            }

            const tracer = otelEbay.getTracer();
            if (tracer) {
                const operationOrMethod = options.operation || options.logMethod && options.method || '';
                const txSpanName = clientId + (operationOrMethod ? `.${operationOrMethod}` : '');
                // Open Telemetry Tracing
                span = tracer.startSpan(txSpanName, {
                    attributes: {
                        [SemanticAttributes.HTTP_METHOD]: request.method,
                        // I'd rather it not be there than be wrong
                        // [SemanticAttributes.HTTP_FLAVOR]: '1.1',
                        [SemanticAttributes.HTTP_URL]: utils.formatUrl(request),
                        [SemanticAttributes.NET_PEER_IP]: ip.address(),
                        'com.ebay.client.type': 'service-client-ebay',
                        'com.ebay.client.name': clientId,
                        'stackid': 'Node.js',
                        'pool': appContext.poolName,
                        'buildid': manifest && manifest.version.rpmName,
                        'application': appContext.appName,
                        'environment': process.env.NODE_ENV
                    },
                    kind: SpanKind.CLIENT
                });
                const ctx = trace.setSpan(context.active(), span);
                propagation.inject(ctx, options.headers);
                return context.with(ctx, next);
            }
        }
        next();
    });
};

function tryRequest() {
    try {
        return RequestLocal.data.request && RequestLocal.data.request.ebay;
    }
    catch (e) {
        logger.warn('tracing: request-local is not available');
    }
}
