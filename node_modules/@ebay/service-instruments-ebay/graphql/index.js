const cal = require('@ebay/cal');
const crypto = require('crypto');
const env = require('@ebay/environment-ebay');
const Client = require('./client');
const factory = require('./factory');
const parser = require('graphql/language/parser');
const utils = require('./utils');

function tryParseRequestBody({ body }) {
    try {
        if (typeof body === 'string') {
            body = JSON.parse(body);
        }

        // eslint-disable-next-line prefer-const
        let { query, variables, extensions } = body;
        if (!query && !extensions?.persistedQuery?.sha256Hash) {
            throw new Error('No query or hash provided');
        }
        if (typeof query === 'string') {
            query = parser.parse(query);
        }

        return {
            extensions,
            query,
            variables
        };
    }
    catch (error) {
        return { error };
    }
}

function tryCreateOperationData({ query, variables, extensions }, options) {
    try {
        if (!utils.isPlainObject(query) && !extensions?.persistedQuery?.sha256Hash) {
            throw new Error('Invalid query or hash provided');
        }

        const isMultipart = utils.checkMultipart(options);
        const operation = isMultipart
            ? factory.createMultipartOperation({ query, extensions, variables })
            : factory.createOperation({ query, extensions, variables });

        return operation;
    }
    catch (error) {
        return { error };
    }
}

function updateRequestBody(request, data) {
    if (data.operations) {
        request.body = Object.assign({}, data, {
            operations: JSON.stringify(data.operations),
            map: JSON.stringify(data.map)
        });
    }
    else if (request.method !== 'GET' && !data.extensions) { // don't rewrite APQ requests
        request.body = JSON.stringify(data);
    }
}

function trackOperation(operation) {
    const calEvent = cal.createEvent(
        'URL',
        'RequestPayload',
        cal.Status.SUCCESS
    );
    const apqQueryHash = operation.operations
        ? operation.operations.extensions?.persistedQuery?.sha256Hash
        : operation.extensions?.persistedQuery?.sha256Hash;

    const query = operation.operations
        ? operation.operations.query
        : operation.query;
    if (query) {
        const shasum = crypto.createHash('sha1');
        const queryHash = apqQueryHash ?? shasum.update(query).digest('base64');
        calEvent.addData('request', query);
        calEvent.addData('query-hash', queryHash);
    }
    else if (apqQueryHash) {
        calEvent.addData('query-hash', apqQueryHash);
    }
    calEvent.complete();
}

module.exports = function graphQL(pipe, config) {
    if (config && config.graphql) {
        // provide explicit graphql API
        // eslint-disable-next-line no-shadow
        pipe.set('graphql:api', pipe => new Client(pipe, config));
        pipe.context.ClientCtr = Client;

        pipe.on('request', (request, next) => {
            const body = tryParseRequestBody(request);
            if (body.error) {
                return pipe.throw(body.error);
            }

            const operation = tryCreateOperationData(
                {
                    query: body.query,
                    variables: body.variables,
                    extensions: body.extensions
                },
                request
            );
            if (operation.error) {
                return pipe.throw(operation.error);
            }

            trackOperation(operation);
            updateRequestBody(request, operation);
            next();
        });

        pipe.on('response', (response, next) => {
            if ((config && config.debug) || env.isDev()) {
                const event = cal.createEvent(
                    'URL',
                    'ResponsePayload',
                    cal.Status.SUCCESS
                );
                event.addData('response', JSON.stringify(response.body));
                event.complete();
            }
            next();
        });
    }
};
