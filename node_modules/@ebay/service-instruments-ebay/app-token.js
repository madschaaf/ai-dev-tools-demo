'use strict';

const Assert = require('assert');
const tokenProvider = require('@ebay/oauth-ebay/lib/services');
const { ExpirableCache } = require('@ebay/cache-ebay');

// we need to provide a fetcher
const tokenFetcher = async key => {
    const cacheKeyData = JSON.parse(key);
    const tokenAttrs = await tokenProvider.getApplicationToken({
        scopes: cacheKeyData.scopes,
        jwt: cacheKeyData.jwt
    });
    return {
        value: tokenAttrs.access_token,
        expiry: new Date(tokenAttrs.expires_in * 1000 + Date.now())
    };
};

let cachedTokenProvider = new ExpirableCache(tokenFetcher);

function scopeToArray(scope) {
    return Array.isArray(scope) ? scope : scope.split(/\s/);
}

module.exports = pipe => {
    pipe.on('request', async (request, next) => {
        const config = request['app-token'];
        const scopes = config?.scope || config?.scopes ||
            ['https://api.ebay.com/oauth/scope/core@application'];
        Assert.ok(Array.isArray(scopes), `app-token.scope must be an array of scopes`);
        const jwt = config?.jwt;
        const cacheKeyData = {
            scopes,
            jwt
        };
        const cacheKey = JSON.stringify(cacheKeyData);
        // use appName as a key, the scope is fixed so far
        // we will keep one token only and use cache to handle expiration
        try {
            const { value } = await cachedTokenProvider.get(cacheKey);
            request.headers = request.headers || {};
            request.headers.authorization = `Bearer ${value}`;
            next();
        }
        catch (err) {
            pipe.throw(err);
        }
    });
};

module.exports[Symbol.for('internals')] = {
    reset() {
        cachedTokenProvider = new ExpirableCache(tokenFetcher);
    },
    scopeToArray
};
