'use strict';
/* eslint-disable no-var,prefer-arrow-callback,prefer-template,no-console */
/* eslint-disable no-empty,no-use-before-define,quotes,prefer-const,guard-for-in,no-unused-vars */

function findKey(obj, val) {
    for (const n in obj) {
        if (obj[n] === val) {
            return n;
        }
    }
}

const assert = require('assert');

const Builder = function (wsdl, options) {
    options = options || {};
    this.wsdl = wsdl;
    this._initializeOptions(options);
    this._initializeServices();
};

Builder.prototype._initializeServices = function () {
    const definitions = this.wsdl.definitions,
        services = definitions.services;
    for (const name in services) {
        this[name] = this._defineService(services[name]);
    }
};

Builder.prototype._initializeOptions = function (options) {
    this.wsdl.options.attributesKey = options.attributesKey || 'attributes';
};

Builder.prototype._defineService = function (service) {
    const ports = service.ports,
        def = {};
    for (const name in ports) {
        def[name] = this._definePort(ports[name]);
    }
    return def;
};

Builder.prototype._definePort = function (port) {
    const binding = port.binding,
        methods = binding.methods,
        def = {};
    for (const name in methods) {
        def[name] = this._defineMethod(methods[name]);
        this[name] = def[name];
    }
    return def;
};

Builder.prototype._defineMethod = function (method) {
    const self = this;
    return function (args, callback) {
        if (typeof args === 'function') {
            callback = args;
            args = {};
        }

        return self._build(method, args);
    };
};

Builder.prototype._build = function (method, args) {
    let self = this,
        name = method.$name,
        input = method.input,
        output = method.output,
        style = method.style,
        defs = this.wsdl.definitions,
        ns = defs.$targetNamespace,
        encoding = '',
        message = '',
        xml = null,
        soapHeaders,
        soapAction = method.soapAction || (((ns.lastIndexOf('/') !== ns.length - 1) ? `${ns}/` : ns) + name),
        headers = {
            SOAPAction: `"${soapAction}"`
        },
        alias = findKey(defs.xmlns, ns);

    if (input.parts) {
        assert.ok(!style || style === 'rpc', 'invalid message definition for document style binding');
        message = self.wsdl.objectToRpcXML(name, args, alias, ns);
        (method.inputSoap === 'encoded') && (encoding = 'soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" ');
    }
    else if (typeof (args) === 'string') {
        message = args;
    }
    else {
        assert.ok(!style || style === 'document', 'invalid message definition for rpc style binding');
        if (method.inputSoap && method.inputSoap.children && method.inputSoap.children.length) {
            method.inputSoap.children.forEach(elem => {
                if (elem.name === 'header') {
                    const headerName = elem.$part;
                    const headerValue = args['@headers'][headerName];
                    if (headerValue) {
                        soapHeaders = soapHeaders || [];
                        soapHeaders.push(this.wsdl.objectToDocumentXML(
                            headerName, headerValue, input.targetNSAlias,
                            input.targetNamespace, elem.$message));
                    }
                }
            });
            delete args['@headers'];
        }
        // pass `input.$lookupType` if `input.$type` could not be found
        message = self.wsdl.objectToDocumentXML(
            input.$name, args, input.targetNSAlias, input.targetNamespace, (input.$type || input.$lookupType));
    }

    xml = "<soap:Envelope " +
        "xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" " +
        "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " +
        encoding +
        this.wsdl.xmlnsInEnvelope + '>' +
        "<soap:Header>" +
        (soapHeaders ? soapHeaders.join("\n") : "") +
        (self.security ? self.security.toXML() : "") +
        "</soap:Header>" +
        "<soap:Body>" +
        message +
        "</soap:Body>" +
        "</soap:Envelope>";

    self.lastMessage = message;
    self.lastRequest = xml;

    return {
        headers: {
            'Content-Type': 'text/xml; charset=utf-8',
            SOAPAction: `"${soapAction}"`
        },
        body: xml,
        output: output
    };
};

Builder.prototype.build = function build(options) {
    return this[options.operation](options.request || options.body);
};

module.exports = Builder;
