'use strict';

const Assert = require('assert');
const { promisify } = require('util');
const loadConfig = promisify(require('@ebay/module-config-inc'));
const { EventEmitter } = require('events');

const createProvider = require('trooba-bootstrap');
const { klona } = require('klona');

const { updateInstruments } = require('./config');
const { deepMerge, getClientConfigOrInjectDefault } = require('./lib/utils');

const clients = {};

// config change listeners for each client
const commonConfig = loadConfig(__dirname);

/**
 * Load config for the client.
 * @param clientId
 * @param moduleOwner is optional reference of the caller's module
 * @param onConfigChange is a callback function to let client know when to rebuild
 */
async function loadClientConfig(clientId, moduleOwner) {
    const [common, ownerConfig] = await Promise.all([
        commonConfig,
        moduleOwner && loadConfig(moduleOwner)
    ]);
    // create a merged config out of three
    const config = mergeConfigs(new EventEmitter());
    // allow to listen on changes
    common.on('change', () => updateAndNotify());
    ownerConfig && ownerConfig.on('change', () => updateAndNotify());

    return config;

    function updateAndNotify() {
        // swap, keep original object
        mergeConfigs(config);
        // notify all
        config.emit('change');
    }

    function mergeConfigs(base) {
        const clientSettings = getClientConfigOrInjectDefault((ownerConfig || common), clientId);
        Assert.ok(!!clientSettings, `Missing client configuration for '${clientId}'`);
        const commonSettings = common.get('service-instruments-ebay');
        const ownerCommonSettings = ownerConfig && ownerConfig.get('service-instruments-ebay');
        return deepMerge(base, commonSettings, ownerCommonSettings, {
            clientConfig: clientSettings
        });
    }
}

/**
 * Create client instance.
 * Should be called once per clientId, unless one wants to reset, which is useful for unit tests
 * @param ownerModule is a reference to the module that owns the client configuration.
 *      ex.: require('@ebay/service-instruments-ebay').use(__dirname).createClient('my-client-id');
 */
module.exports.use = ownerModule => ({
    clients,
    /**
         * create client
         * @param {*} clientId
         * @param {*} useAsync
         */
    async createClient(clientId, apiName = 'client:default') {
        const key = `${ownerModule && (ownerModule.path || ownerModule) || 'default'}:${clientId}:${apiName}`;
        if (clients[key]) {
            return createClientDelegate(key, clientId);
        }
        // createClient used to create first instance as well as update when config changes
        const config = await loadClientConfig(clientId, ownerModule);
        // config snapshot for detecting config updates
        let snapshot = takeConfigSnapshot(config);
        // create and register client
        createOrUpdateClient(config);
        // return delegate to easily swap a real client instance when it changes
        return createClientDelegate(key);

        // eslint-disable-next-line no-shadow
        function createOrUpdateClient(config) {
            const instrumentsMetadata = config['instruments-metadata'];
            const instruments = updateInstruments(
                config.clientConfig && config.clientConfig.instruments ||
                config['default-instruments'], config.clientConfig);
            const transportName = config.clientConfig && config.clientConfig.transport || 'generic';
            instruments.push(transportName);
            // skip config instrument as we now use trooba bootstrap
            const instrumentsList = instruments.reduce((acc, name) => {
                if (name !== 'config') {
                    acc[name] = Object.assign({}, instrumentsMetadata[name], {
                        config: config.clientConfig
                    });
                }
                return acc;
            }, {});
            // add merge config to request for backwards compatibility
            instrumentsList.merge = {
                priority: 5,
                module: (pipe, cfg) =>
                    pipe.on('request', (request, next) => {
                        // If deepMerge is true, deep merge everything
                        if (request.deepMerge === true) {
                            const mergedRequest = deepMerge({}, cfg, request);
                            return next(mergedRequest);
                        }

                        // Otherwise use the default behavior
                        return next(Object.assign(request, cfg));
                    }),
                name: 'merge',
                config: config.clientConfig
            };

            const provider = createProvider({
                default: {}
            }, {
                // resolve instruments
                [clientId]: instrumentsList
            });

            const pipe = provider.createClient(clientId, 'default:api');

            // eslint-disable-next-line no-shadow
            clients[key] = pipe;
            // listen to any updated and rebuild the client
            config.on('change', () => {
                // only trigger update when instruments' settings change
                const newSnapshot = takeConfigSnapshot(config);
                if (!compareObjects(snapshot, newSnapshot)) {
                    snapshot = newSnapshot;
                    createOrUpdateClient(config);
                }
            });
        }

        function createClientDelegate(clientKey) {
            return {
                clientKey,
                /**
                 * Inject web request as a context as it is used to fetch data by instruments attached to web request
                 * @param {*} webRequest is Request
                 * @returns client API
                 */
                webContext(webRequest) {
                    const ctx = {
                        app: {
                            request: webRequest,
                            response: webRequest.res
                        }
                    };

                    return this.context(ctx);
                },

                /**
                 * Generic context per service request
                 * @param {*} ctx is a context object with various property used by instruments
                 * @returns @returns client API
                 */
                context(ctx) {
                    if (!ctx) {
                        throw new Error('Context must be provided');
                    }

                    const pipe = clients[clientKey];
                    return pipe.create(Object.assign({
                        caller: ownerModule,
                        clientId
                    }, ctx), apiName);
                }
            };
        }
    }
});

function compareObjects(a, b) {
    try {
        Assert.deepStrictEqual(a, b);
        return true;
    }
    catch (err) {
        return false;
    }
}

function takeConfigSnapshot(config) {
    return {
        instruments: klona(config.clientConfig.instruments)
    };
}

module.exports.loadClientConfig = loadClientConfig;
module.exports.clients = clients;
module.exports.RuntimeError = require('./lib').RuntimeError;
