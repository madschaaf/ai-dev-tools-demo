'use strict';

const querystring = require('querystring');
const NodePath = require('path');
const NodeUtils = require('util');
const qs = require('querystring');
const TransportUtils = require('./transports/utils');
const cal = require('@ebay/cal');
const logger = require('@ebay/logging-inc').logger('service-instruments-ebay/cal');

const RuntimeError = require('./lib/errors').RuntimeError;

module.exports = function calHandler(pipe, config) {
    let _request;
    let _tx;
    const clientId = pipe.context.clientId;

    pipe.once('request', (request, next) => {
        const options = request;
        _request = request;
        logger.info('cal handler', clientId);
        const method = config && config.logMethod ? options.method : '';
        const txPostFix = options.operation || method;
        const txName = clientId + (txPostFix ? `.${txPostFix}` : '');

        logger.begin('Service', txName, (tx) => {
            _tx = tx;
            const url = formatUrl(options);
            cal.createEvent(clientId, 'RequestURL').addData(url).complete();

            next();
        });
    });

    pipe.once('error', (err, next) => {
        if (err.res) {
            logResponse(err.res);
        }
        // in case of error we would like to know more information about
        // request headers
        logRequest(_request);

        let errorMessage = err && err.message || 'Unknown error';
        // eslint-disable-next-line no-nested-ternary
        const port = _request.port !== undefined ? _request.port : (_request.protocol === 'http:' ? 80 : 443);
        errorMessage = `Host: ${_request.protocol || 'https:'}//${_request.hostname}:${port}, error: ${errorMessage}`;

        err = new RuntimeError(errorMessage, {
            error: err,
            code: err.code || 'Error'
        });

        const tracing = pipe.context && pipe.context.tracing || {};
        _tx.fail(err.errorMessage, err, 1, {
            corr_id_: tracing.rci || 0,
            ri: tracing.ri || 0,
            node_id: tracing.node_id || 0,
            Errors: err.errorCount || 0
        });
        next(err);
    });

    pipe.once('response', (response, next) => {
        logResponse(response);

        const tracing = pipe.context && pipe.context.tracing || {};

        _tx.addData({
            corr_id_: tracing.rci || 0,
            ri: tracing.ri || 0,
            node_id: tracing.node_id || 0,
            Errors: pipe.context.errorCount || 0
        });
        _tx.end();

        next();
    });

    function logResponse(response) {
        response.headers && cal.createEvent(clientId, 'ResponseHeaders')
            .addData(formatHeaders(response.headers)).complete();

        response.statusCode && cal.createEvent(clientId, 'HttpStatus')
            .addData(response.statusCode).complete();
    }

    function logRequest(request) {
        const debug = config && config.debug;
        if (!debug && request && request.headers) {
            let addlMaskheaders = config && config.maskHeaders;
            addlMaskheaders = addlMaskheaders || [];
            TransportUtils.generateHeadersInfo(request.headers, addlMaskheaders);
        }
    }
};

function formatUrl(options) {
    // eslint-disable-next-line no-nested-ternary
    let qString = options.qs ? (typeof options.qs === 'string' ? options.qs :
        querystring.stringify(options.qs)) : options.search || '';
    qString = qString ? `?${qString}` : '';

    let path = NodePath.join(options.basepath || '', options.path || '');
    if (!path.startsWith('/')) {
        path = `/${path}`;
    }

    return NodeUtils.format('%s//%s:%s%s%s',
        options.protocol,
        options.hostname,
        options.port || (options.protocol === 'https:' ? 443 : 80),
        path,
        qString);
}

function formatHeaders(headers) {
    return qs.stringify(headers, null, null, { encodeURIComponent: (str) => str });
}
