'use strict';

let MetricsServices;
const logger = require('@ebay/logging-inc').logger('service-instruments-ebay/metrics');
const { Metrics, Registry } = require('@ebay/prometheus-ebay');
const Enum = require('@ebay/common-types-ebay/enum');
const modConfig = require('@ebay/module-config-inc');
const otelEbay = require('@ebay/opentelemetry-ebay');
const OtelApi = require('@opentelemetry/api');
const qs = require('querystring');
let clientMetrics;

const Outcome = Enum.define({
    INFORMATIONAL: 'INFORMATIONAL',
    SUCCESS: 'SUCCESS',
    REDIRECTION: 'REDIRECTION',
    CLIENT_ERROR: 'CLIENT_ERROR',
    SERVER_ERROR: 'SERVER_ERROR',
    UNKNOWN: 'UNKNOWN'
});

const MESH_HEADERS = [
    'x-ebay-mesh-gw-name',
    'x-ebay-mesh-gw-pod-ip',
    'x-ebay-mesh-gw-duration',
    'x-ebay-mesh-gw-pod-name',
    'x-ebay-mesh-server-pod-ip',
    'x-ebay-mesh-gw-start-time',
    'x-ebay-mesh-gw-upstream-duration',
    'x-ebay-mesh-server-duration'
];

function forStatus(status) {
    if (status >= 100 && status < 200) {
        return Outcome.INFORMATIONAL.value;
    }
    else if (status >= 200 && status < 300) {
        return Outcome.SUCCESS.value;
    }
    else if (status >= 300 && status < 400) {
        return Outcome.REDIRECTION.value;
    }
    else if (status >= 400 && status < 500) {
        return Outcome.CLIENT_ERROR.value;
    }
    else if (status >= 500 && status < 600) {
        return Outcome.SERVER_ERROR.value;
    }
    return Outcome.UNKNOWN.value;
}

class ClientMetrics {
    constructor() {
        this.pendingInit = new Promise(resolve => {
            this._resolve = resolve;
        });
        modConfig(__dirname, (err, config) => {
            // it will not throw error
            this.config = config;
            config.on('change', () => {
                if (JSON.stringify(this.histogramBuckets) !==
                    JSON.stringify(this.config.get('service-instruments-ebay:prometheus:histogramBuckets'))) {
                    this.serviceClientMetric.clearMetrics(Registry.OPENMETRICS_CONTENT_TYPE);
                    this.initServiceClientMetricGauges();
                }

                if (JSON.stringify(this.histogramBuckets_platform_cloud) !==
                    // eslint-disable-next-line max-len
                    JSON.stringify(this.config.get('service-instruments-ebay:prometheus:histogramBuckets_platform_cloud'))) {
                    this.serviceClientMeshMetric.clearMetrics(Registry.OPENMETRICS_CONTENT_TYPE);
                    this.initServiceClientMeshMetricGauges();
                }
            });
            this.serviceClientMetric = new Metrics('serviceclient');
            this.serviceClientMeshMetric = new Metrics('platform-cloud');
            this.initServiceClientMetricGauges();
            this.initServiceClientMeshMetricGauges();
            this._resolve();
        });
    }

    initServiceClientMetricGauges() {
        this.histogramBuckets = this.config.get('service-instruments-ebay:prometheus:histogramBuckets');
        this.histServiceClient = this.serviceClientMetric.createHistogram(
            'http_client_requests_ms',
            'httpclient requests histogram',
            ['clientName', 'clientType', 'method', 'outcome', 'status', 'uri'],
            this.histogramBuckets,
            Registry.OPENMETRICS_CONTENT_TYPE,
            true
        );
    }

    initServiceClientMeshMetricGauges() {
        // eslint-disable-next-line max-len
        this.histogramBuckets_platform_cloud = this.config.get('service-instruments-ebay:prometheus:histogramBuckets_platform_cloud');
        this.histServiceClientMesh = this.serviceClientMeshMetric.createHistogram(
            'http_client_mesh_requests_duration_ms',
            'httpclient requests histogram for mesh',
            ['clientType', 'status', 'gwName'],
            this.histogramBuckets_platform_cloud,
            Registry.OPENMETRICS_CONTENT_TYPE,
            true
        );
    }

    start(request, clientId, options) {
        const startTime = Date.now();
        const thisRef = this;
        let basePath = 'NA';
        if (!this.config?.get('service-instruments-ebay:prometheus:enabled')) {
            return;
        }

        if (this.config?.get('service-instruments-ebay:prometheus:uriEnabled')) {
            basePath = request.basepath || '/';
        }
        return {
            complete(errOrResponse) {
                const status = forStatus(errOrResponse.statusCode);
                const duration = Date.now() - startTime;
                const labels = {
                    clientName: clientId,
                    clientType: 'serviceClient',
                    method: request.method,
                    uri: basePath,
                    status: errOrResponse.statusCode,
                    outcome: status
                };
                const labelsPlatformCloud = {
                    clientType: 'serviceClient',
                    status: errOrResponse.statusCode
                };
                const getMeshLabels = () => {
                    if (errOrResponse.headers) {
                        const headersToLog = MESH_HEADERS.map(header => ({
                            header: errOrResponse.headers[header]
                        }));
                        logger.info('Mesh Headers', qs.stringify(headersToLog));
                        const meshLabels = Object.assign({
                            gwName: errOrResponse.headers['x-ebay-mesh-gw-name'] }, labelsPlatformCloud);
                        return meshLabels;
                    }
                };

                const gwName = errOrResponse.headers?.['x-ebay-mesh-gw-name'];
                const meshUpStreamDuration = errOrResponse.headers?.['x-ebay-mesh-gw-upstream-duration'];
                const meshGWDuration = errOrResponse.headers?.['x-ebay-mesh-gw-duration'];

                const tracer = options?.tracer || otelEbay.getTracer();
                const activeCtx = OtelApi.context.active();
                const span = OtelApi.trace.getSpan(activeCtx);
                if (tracer && span) {
                    const traceId = span?.spanContext()?.traceId;
                    const spanId = span?.spanContext()?.spanId;
                    thisRef.histServiceClient.observeWithExemplar({
                        labels: labels,
                        value: duration,
                        exemplarLabels: { trace_id: traceId, span_id: spanId }
                    });

                    if (meshUpStreamDuration && gwName) { // Only record meshUpStreamDuration if it is present
                        thisRef.histServiceClientMesh.observeWithExemplar({
                            labels: getMeshLabels(),
                            value: duration - meshUpStreamDuration,
                            exemplarLabels: { trace_id: traceId, span_id: spanId }
                        });
                    }
                }
                else {
                    thisRef.histServiceClient.observeWithoutExemplar(labels, duration);
                    if (meshUpStreamDuration && gwName) { // Only record meshUpStreamDuration if it is present
                        thisRef.histServiceClientMesh.observeWithoutExemplar(
                            getMeshLabels(), duration - meshUpStreamDuration);
                    }
                }

                // Create Span for MeshServerDuration: NODE-4907
                if (meshGWDuration && meshUpStreamDuration && gwName) {
                    tracer?.startActiveSpan(`Mesh.${clientId}.${gwName}`, {
                        startTime: Date.now() - meshGWDuration
                    }, async meshSpan => {
                        tracer?.startActiveSpan(`Envoy-Server.${clientId}.${gwName}`, {
                            startTime: Date.now() - meshUpStreamDuration
                        }, async serverSpan => {
                            serverSpan.end();
                        });
                        meshSpan.end();
                    });
                }
            }
        };
    }
}

module.exports = function metrics(pipe) {
    const clientId = pipe.context.clientId;
    let updateMetrics;
    let updateClientMetrics;

    MetricsServices = MetricsServices || require('@ebay/metrics-ebay/services');
    clientMetrics = clientMetrics || new ClientMetrics();
    pipe.on('request', (request, next) => {
        logger.info('metrics handler', clientId);
        const options = request;

        pipe.context.metrics = MetricsServices.getOrCreateMonitor({
            clientId: 'REST',
            service: clientId,
            operation: pipe.context.operation || options.operation ||
                (options.basepath ? options.basepath.replace(/(^\/|\/$)/g, '').replace(/\//g, '.') : options.method) ||
                'unknown'
        });

        // start recording
        updateClientMetrics = clientMetrics.start(options, clientId);
        updateMetrics = pipe.context.metrics.start();
        next();
    });

    pipe.on('error', (err, next) => {
        // update metrics
        updateClientMetrics && updateClientMetrics.complete(err);
        updateMetrics && updateMetrics(err);
        // continue with result to the next response handler
        next();
    });

    pipe.on('response', (response, next) => {
        // update metrics
        updateClientMetrics && updateClientMetrics.complete(response);
        updateMetrics && updateMetrics(null, response);
        // continue with result to the next response handler
        next();
    });
};

module.exports.Outcome = Outcome;
module.exports.forStatus = forStatus;
module.exports.ClientMetrics = ClientMetrics;
