'use strict';

var Querystring = require('querystring');
var SojournerEventEnum = require('./sojourner-event-enums.js');
var Tags = require('../entities/tags.js');
var BitSet = require('bit-set');
var _ = require('underscore');
var utils = require('../utils.js');
var cal = require('@ebay/cal');
var nodeutil = require('util');
var logger = require('@ebay/logging-inc').logger('tracking-ebay/soj/sojourner-writer');
var pathfinder = require('@ebay/pathfinder-ebay');
var colo = require('@ebay/colo-detect-ebay').coloDetect();
var currentIP = require('ip').address();
var security = require('@ebay/security-ebay');
const utilsEbay = require('@ebay/utils-ebay');
const URL = require('url');

var SamplingEvent = function () {
    this.map = {};
};
SamplingEvent.prototype.add = function (event, key, ratio, remainder) {
    this.map[event] = {
        ratio: ratio,
        remainder: remainder,
        key: key
    };
};
SamplingEvent.prototype.get = function (event) {
    return this.map[event];
};
var _samplingEvent = new SamplingEvent();
_samplingEvent.add(SojournerEventEnum.COOKIE, Tags.G, 100, 0);

var DataBuffer = function () {
    this.buffer = [];
};
var DataElement = function (name, value, flags) {
    this.name = name;
    this.value = value;
    this.flags = flags;
};
DataElement.prototype.toString = function () {
    return this.name + '=' + this.value;
};
DataBuffer.prototype.add = function (name, value, flags) {
    var data = new DataElement(name, value, flags);
    this.buffer.push(data);
};
DataBuffer.prototype.toString = function () {
    return this.buffer.join('&');
};

var checkSamplingRatio = function (sojournerContext, eventEnum, dataEnum, ratio, remainder) {
    var value = sojournerContext.getData(eventEnum, dataEnum);
    if (!value) {
        return false;
    }
    return (Math.abs(utils.hashCode(value) % ratio) === remainder);
};
var getPrintableBitset = function (bitSet) {
    var length = bitSet._words.length * 4;
    var bytes = [];
    for (var i = 0; i < length; i++) {
        var b = 0;
        for (var j = 0; j < 8; j++) {
            b = b << 1;
            if (bitSet.get((i * 8) + j)) {
                b += 1;
            }
        }
        bytes[i] = b;
    }
    while (bytes.length > 0 && bytes[bytes.length - 1] === 0) {
        bytes.pop();
    }
    return utils.atob(bytes);
};
var flagMapToString = function (flagsMap) {
    var bitSet = new BitSet();
    _.pairs(flagsMap).forEach(function (pair) {
        var flag = pair[1];
        if (flag) {
            bitSet.set(flag.bit);
        }
    });
    return getPrintableBitset(bitSet, false);
};


var formatFlags = function (flagsMap) {
    var ret = [];
    _.pairs(flagsMap).forEach(function (pair) {
        var flag = pair[1];
        if (flag) {
            ret.push(flag.bit + ' - ' + flag.name + ':' + flag.setName);
        }
    });
    return ret.join('\n');
};
var addFlagData = function (key, flagMap, dataBuffer) {
    if (_.pairs(flagMap).length > 0) {
        dataBuffer.add(key, flagMapToString(flagMap), formatFlags(flagMap));
    }
};

function validateAndResolveTag(key, value, encode) {
    let keyStr = key.toString();
    let valueStr;
    if (_.isObject(value) && _.isFunction(value.getSafeTagName)) {
        keyStr = value.getSafeTagName(keyStr);
    }
    if (encode && !_.isObject(value)) {
        try {
            valueStr = utils.encode(value.toString());
        }
        catch (err) {
            // cannot attach data as it will fail
            // in cal logging due to the same encoding problem
            logger.error(`Failed to encode tags data (tag:${keyStr})`, err);
            return [];
        }
    } else {
        valueStr = value.toString();
    }

    const keyEnum = Tags.getTagByName(key);
    return (keyEnum && keyEnum.isValidData(valueStr)) ? [keyStr, valueStr] : [];
}

function addTagsData(appData, dataBuffer, encode) {
    const tempDataBuf = new DataBuffer();
    const keys = Object.keys(appData);
    for (let index = 0; index < keys.length; index++) {
        const key = keys[index];
        const value = appData[key];
        const resolvedTag = validateAndResolveTag(key, value, encode);
        if (resolvedTag.length === 0) {
            logger.error(`Tracking event cannot be sent due to invalid value ${value} of ${key}`);
            continue;
        }
        const [keyStr, valueStr] = resolvedTag;
        tempDataBuf.add(keyStr, valueStr);
    }
    dataBuffer.buffer.push(...tempDataBuf.buffer);
}

const MANDATORY_TAGS = ['h', 'p', 't', 'g'];

var write = function _write(sojournerContext, logFn) {
    let eventDataBuf;
    let missingTagName;
    let invalidTag;

    const detector = key => {
        const value = sojournerContext.m_contextData[key];
        if (value === undefined) {
            missingTagName = key;
            return true;
        }
        if (validateAndResolveTag(key, value).length === 0) {
            invalidTag = [key, value];
            return true;
        }
        return false;
    };

    // validate mandatory tags
    if (MANDATORY_TAGS.some(detector)) {
        logger.error(`Tracking event cannot be sent due some of mandatory tags ${
            MANDATORY_TAGS}, tag ${missingTagName || invalidTag[0]} is ${
                missingTagName ? 'missing' : `invalid, actual:${invalidTag[1]}`}`);
        return;
    }

    if (!sojournerContext.isBlockedEvent(SojournerEventEnum.APPLICATION)) {
        eventDataBuf = new DataBuffer();
        //add app event
        addTagsData(sojournerContext.m_contextData, eventDataBuf, true);
        addTagsData(sojournerContext.getAppDataMapByEvent(SojournerEventEnum.APPLICATION), eventDataBuf, true);
        addFlagData(sojournerContext.CONTEXT_FLAG_KEY, sojournerContext.m_contextFlagMap, eventDataBuf);
        addFlagData(sojournerContext.FLAG_KEY, sojournerContext.m_appFlagMap, eventDataBuf);

        if (eventDataBuf.buffer.length) {
            logFn('a', removeDuplicate(eventDataBuf));
        }
    }

    if (!sojournerContext.isBlockedEvent(SojournerEventEnum.CLICK)) {
        eventDataBuf = new DataBuffer();
        //add click event
        addTagsData(sojournerContext.getAppDataMapByEvent(SojournerEventEnum.CLICK), eventDataBuf, true);
        if (eventDataBuf.buffer.length) {
            logFn('k', removeDuplicate(eventDataBuf));
        }

    }

    if (!sojournerContext.isBlockedEvent(SojournerEventEnum.COOKIE)) {
        eventDataBuf = new DataBuffer();
        //add cookie event based on sampling
        var emitCookieEvent = checkSamplingRatio(sojournerContext, SojournerEventEnum.COOKIE, _samplingEvent.get(SojournerEventEnum.COOKIE).keyEnum, _samplingEvent.get(SojournerEventEnum.COOKIE).ratio, _samplingEvent.get(SojournerEventEnum.COOKIE).remainder);
        if (emitCookieEvent) {
            addTagsData(sojournerContext.getAppDataMapByEvent(SojournerEventEnum.COOKIE), eventDataBuf, false);
            if (eventDataBuf.buffer.length) {
                logFn('c', removeDuplicate(eventDataBuf));
            }
        }
    }

};

function writeToHeader(sojournerContext) {
    var context = '';
    write(sojournerContext, function (type, data) {
        data = data.toString();
        if (data) {
            context += nodeutil.format('<%s>%s</%s>', type, data, type);
        }
    });
    return context;
}

function writeChunk(sojournerContext, res) {
    var chunk = {};
    write(sojournerContext, function (type, data) {
        data = data.toString();
        if (data) {
            chunk[type] = data;
        }
    });
    if (res.stream) {
        const contentType = res.getHeader('content-type');
        const isSSE = /text\/event-stream/.test(contentType);
        const options = isSSE ? {
            name: 'sse-header-event',
            id: 'TRACKING_DATA'
        } : {
            name: 'HEADER',
            id: 'TRACKING_DATA'
        };
        res.stream.write(chunk, options);
    }
    else {
        logger.error(new Error('The progressive response is not enabled, ' +
        'please make sure service app has service-request-response-ebay module middleware enabled'));
    }
}

function writeToCal(sojournerContext) {

    write(sojournerContext, function (type, data) {
        var event = cal.createEvent(sojournerContext.CAL_TYPE, type);
        // find root transaction
        var parent = event.parent;
        while(parent && parent.parent) {
            parent = parent.parent;
        }
        // move event to root transaction
        event.parent = parent;
        event.addData(data.toString());
        event.complete();
    });
}


function removeDuplicate(data){

    var tempBufferObj = {};
    var newBuffer = [];

    if(!data || !data.buffer){
        return data;
    }

    data.buffer.forEach( function(record){
        var tagValue = record.toString();

        // Sample result: ["p=213123", "p", "213123"]
        var tagValueSplitted = tagValue.match(/([^=]+)=(.+)/);

        // if = was not found ignore and jump into the next one.
        if(!tagValueSplitted){
            return;
        }

        var tag = tagValueSplitted[1];
        var value = tagValueSplitted[2];

        tempBufferObj[tag] = value;

    });

    Object.keys(tempBufferObj).forEach(function(key){
        newBuffer.push(key + '=' + tempBufferObj[key]);
    });

    data.buffer = newBuffer;

    return data;
}

function writeToPageSource(sojournerContext, pageWritter) {
    var buffer = [];
    buffer.push('\n\n');
    buffer.push('<!-- SOJOURNER TRACKING DATA');
    buffer.push('\n\n');

    write(sojournerContext, function (type, data) {
            buffer.push('SOJ ' + type.toLowerCase());
            buffer.push('\n');
            buffer.push('=====');
            buffer.push('\n');
            data.buffer.forEach(function (value) {
                if (!value.flags) {
                    buffer.push('GlobalTags:' + utils.decode(value.toString()));
                } else {
                    buffer.push('\n');
                    buffer.push(value);
                    buffer.push('\n');
                    buffer.push('========');
                    buffer.push('\n');
                    buffer.push(value.flags);
                }
                buffer.push('\n');
            });
            buffer.push('\n\n');
        });
    buffer.push('-->');
    pageWritter.write(buffer.join(''));
}

function writeToPathfinder(req, res, sojournerContext, callback) {
    var sojData;

    write(sojournerContext, function (type, data) {
        // accumulate in sojData instance
        sojData = sojData || {rheosHeader: {}, sojA: {}, sojK: {}, sojC: null, clientData: populateClientData(req, res)};
        var soj = {};
        data = data || {buffer: []};
        type = type || '';

        data.buffer.forEach(function (value) {
            if (!value.flags) {
                var keyValue = value.toString().split('=');
                soj[keyValue[0]] = keyValue[1];
            }
        });
        sojData['soj'+type.toUpperCase()] = soj;
    });
    // the above block is sync and can be called more then once, hence
    // keep pathfinder outside, but we need to know if anything had been logged
    // and only then do pathfinder publishing
    if (sojData !== undefined) {
        pathfinder.logSOJEvents(sojData, req, callback);
    }
}

function populateClientData(req, res) {
    var log_id_ = req.pageStartTime ? req.pageStartTime.toString(16) : '';
    var url =  req.originalUrl || req.url || req.path;
    var headers = req.headers || {};
    var statusCode = res.statusCode;

    var ebay = req.ebay;

    var pageName = ebay.getPageNameFromRoute();
    pageName = pageName || 'DefaultPage';

    var application_name =  ebay.appContext.appName || '';
    var poolName = ebay.appContext.poolName || '';
    var rlogid = ebay.getRlogId();
    var GUID = ebay.getGuid();
    var serverName = utilsEbay.getServerName(req);    
    var scriptPath = URL.parse(url).pathname || '/';    
    var referer = headers.referer|| '';
    var agent = ebay.getUserAgent();
    var encoding = headers['accept-encoding'];
    var contentLength = parseInt(headers['content-length'] || '0');
    var remoteIP = ebay.getRemoteAddr();
    var xff = headers['x-forwarded-for'] || remoteIP || '127.0.0.1';

    let duration = req.pageStartTime ? Date.now() - req.pageStartTime : 0;
    if (/^::ffff:(\d{1,3}\.){3,3}\d{1,3}$/.test(xff)) {
      xff = xff.replace(/^::ffff:/, '');
    }

    var calStatus = '0';
    if(statusCode > 400) {
        calStatus = '1';
    }

    const corrId = req.ebay && req.ebay.getCorrelationRequestId &&
        req.ebay.getCorrelationRequestId() &&
        req.ebay.getCorrelationRequestId().getCorrelationRequestId();
        
    var payload = Querystring.stringify({
        corr_id_: corrId || 0,
        log_id_: log_id_,
        application_name: application_name,
        url: url,
        statusCode: statusCode,
        GUID: GUID,
        rlogid: rlogid,
        Encoding: encoding,
        Referer: referer
    });

    var queryString = security.getMaskPayload(req);

    var clientData = {ForwardFor: {string: xff}, Script: {string: scriptPath}, TStamp: {long: Date.now()},
                        Server: {string: serverName}, TName: {string: pageName}, TPayload: {string: payload}, TDuration: {long: duration},
                        TMachine: {string: currentIP}, colo: {string: colo}, pool: {string: poolName},
                        agent: {string: agent}, remoteIP: {string: remoteIP}, TType: {string: 'URL'}, TStatus: {string: calStatus}, corrId: {string: corrId}, contentLength: {int: contentLength},
                        requestGuid: {string: GUID}, urlQueryString: {string: queryString}, referrer: {string: referer}, rlogid: {string: rlogid}, nodeId: {string: ''}};
    return clientData;
}

module.exports = {
    flagMapToString: flagMapToString,
    writeChunk: writeChunk,
    writeToHeader: writeToHeader,
    writeToCal: writeToCal,
    writeToPageSource: writeToPageSource,
    writeToPathfinder: writeToPathfinder
};
