'use strict';

/**
 * This is a rewrite to com.ebay.kernel.presentation.sojourner.SojournerConcreteContext
 */
var NodeUtil = require('util');
var _ = require('underscore');
var SojournerVectorData = require('./SojournerVectorData.js');
var SojournerEventEnum = require('./sojourner-event-enums.js');
var eBayTags = require('../entities/tags.js');
var logger = require('@ebay/logging-inc').logger('tracking-ebay:soj-context');

var SojournerContext = module.exports = function SojournerContext() {
    this.CAL_TYPE = 'SOJ';

    /**
     * The maximum allowable bit position in the set of application flags.  We allow
     * up to 255 bits, the index is zero-based, so the max position is 254.
     */
    this.MAX_BITPOSITION = 1022;

    /**
     * The maximum allowable bit position in the set of BOT Detection flags.  We allow
     * up to 64 bits, the index is zero-based, so the max position is 63.
     */
    this.CONTEXT_MAX_BIT_POSITION = 1022;

    /**
     * The reserved name of the flag data sent with a sojourner event.
     */
    this.FLAG_KEY = 'flgs';

    /**
     * The reserved name of the flag data sent with a sojourner event for a module.
     */
    this.MOD_FLAG_KEY = 'mflags';

    /**
     * The reserved name of the flag data sent for BOT Detection.
     */
    this.CONTEXT_FLAG_KEY = 'cflgs';

    /**
     * Context data:  eBayTags->String
     */
    this.m_contextData = {};

    /**
     * Application data, map of maps
     * SojournerEventEnum -> (SojournerDataKey->String)
     */
    this.m_appData = {};

    /**
     * ROI data
     * (SojournerDataKey->String)
     */
    this.m_roiData = {};
    /**
     * SiteCatalyst data
     * (SojournerDataKey->String)
     */
    this.m_siteCatalystData = {};

    /**
     * Map of String->SojournerApplicationContext objects for application use
     */
    this.m_appContexts = {};


    /**
     * Map of Bitposition to value for application flags
     * Integer -> (TrackingFlag, Boolean)
     */
    this.m_appFlagMap = {};

    /**
     * Map of Bitposition to value for application flags
     * Integer -> (TrackingFlag, Boolean)
     */
    this.m_contextFlagMap = {};

    // original GUID set on the context by framework
    this.m_origGUID = undefined;

    this.m_isByPassROITracking = true;

};

/**
 * Add context data.  This data will be prepended to all sojourner
 * events sent by this context.
 * @param key the key for the context data
 * @param data the data to add
 */
SojournerContext.prototype.addContext = function (key, data) {
    if (!nullCheck(key) && !nullCheck(data)) {
        if (eBayTags.G.equals(key)) {
            this.m_origGUID = data;
        }
        this.m_contextData[key] = data;
    }
};

/**
 * Set the context data that indicates that this command is redirecting
 */
SojournerContext.prototype.setRedirectIndicator = function () {
    this.addContext(eBayTags.RDT, '1');
};

SojournerContext.prototype.setResponseCode = function (code) {
    this.addContext(eBayTags.HTTPRESPONSECODE, code);
};

/**
 * Set the context data that indicates a non-default sampling rule to use
 * for this event.
 * @param ruleName name for the rule.  The name must be at most 4 characters in
 * length and non null or blank.
 */
SojournerContext.prototype.setSamplingRule = function (ruleName) {
    var MAX_LENGTH = 4;
    var MIN_LENGTH = 1;

    if (nullCheck(ruleName)) {
        logger.warn('invalid rule name: %s', ruleName);
        return;
    }

    ruleName = ruleName.trim();

    if (ruleName.length < MIN_LENGTH || ruleName.length > MAX_LENGTH) {
        logger.warn('invalid rule name: %s', ruleName);
        return;
    }
    this.addContext(eBayTags.RULE, ruleName);
};

/**
 * Add data for an event internally used
 * @param event identifies the event
 * @param key identifies the data
 * @param data the data to add
 */
SojournerContext.prototype.addDataInternal = function (event, key, data) {
    // Get out immediately if event is not in map
    if (!this.isRightEvent(event)) {
        return;
    }

    if (!nullCheck(event) && !nullCheck(key) && !nullCheck(data) && !this.isBlockedData(event, key)) {

        this.addOtherDestinations(key, data);

        var eventDataMap = this.getAppDataMapByEvent(event);
        // for compatibility, no escape, add as string
        eventDataMap[key] = data;
    }
};
/**
 * Add data for an event based on runtime destinations
 * @param event identifies the event
 * @param key identifies the data
 * @param data the data to add
 */
SojournerContext.prototype.addData = function (event, key, data, destOverride) {
    if (!nullCheck(destOverride)) {
        if (nullCheck(event) && nullCheck(key) && nullCheck(data)) {
            this.addOtherDestinations(key, data, destOverride);
            if (destOverride.isSOJ) {
                this.addDataInternal(event, key, data);
            }
        }
    } else {
        this.addDataInternal(event, key, data);
    }
};

/**
 * Add data for an event to the end of the vector
 * @param event identifies the event
 * @param key identifies the data
 * @param data the data to add
 */
SojournerContext.prototype.addVectorData = function (event, key, data, vectorTypeEnum) {
    // Get out immediately if event is not in map or blocked
    if (!this.isRightEvent(event) && this.isBlockedEvent(event)) {
        return;
    }

    if (!nullCheck(event) && !nullCheck(key) && !nullCheck(data)) {
        var eventDataMap = this.getAppDataMapByEvent(event);
        var vectorData = eventDataMap[key];
        if (vectorData) {
            if (vectorTypeEnum && vectorTypeEnum !== vectorData.type) {
                logger.warn('inconsistent vector type is used for tag %s,%s:%s', key, vectorTypeEnum, vectorData.type);
            }
            if (!vectorData.appendData) {
                var msg = NodeUtil.format('Inconsistent vector is used for event "%s" tag "%s,%s:%s", ' +
                        'skipping soj logging for given data', event, key, vectorTypeEnum, vectorData.type);
                logger.error(new Error(msg));
                return;
            }
            vectorData.appendData(data);
        } else {
            vectorData = new SojournerVectorData(vectorTypeEnum);
            vectorData.appendData(data);
        }
        // for compatibility, no escape, add as string
        eventDataMap[key] = vectorData;
    }
};

/**
 * Return true if data for the event and key has been added already
 * @param event identifies the event
 * @param key identifies the data
 * @return true if data for the given event and key has already been added
 */
SojournerContext.prototype.hasData = function (event, key) {
    var appEvtData = this.m_appData[event];
    return !nullCheck(appEvtData) && !_.isUndefined(appEvtData[key]);
};

/**
 * Get the data value associated for the given event and key
 * @param event identifies the event
 * @param key identifies the data
 * @return the data value associated for the given event and key
 */
SojournerContext.prototype.getData = function (event, key) {
    var appEvtData = this.m_appData[event];
    return appEvtData ? appEvtData[key] : null;
};

SojournerContext.prototype.blockData = function blockData(event, key) {

    this.blockEvtData = this.blockEvtData || {};
    var evtData = this.blockEvtData[event] || (this.blockEvtData[event] = {});
    evtData[key] = true;
    return this.deleteData(event, key);
};

SojournerContext.prototype.blockEvent = function blockData(event) {
    this.blockEvtData = this.blockEvtData || {};
    this.blockEvtData[event] = true;
    return this.deleteEvent(event);
};

SojournerContext.prototype.isBlockedData = function isBlockedData(event, key) {
    return this.blockEvtData && this.blockEvtData[event] &&
        (this.blockEvtData[event] === true || this.blockEvtData[event][key]);
};

SojournerContext.prototype.isBlockedEvent = function isBlockedEvent(event) {
    return this.blockEvtData && this.blockEvtData[event] &&
        this.blockEvtData[event] === true;
};

SojournerContext.prototype.deleteEvent = function deleteData(event) {
    var appEvtData = this.m_appData[event];
    delete this.m_appData[event];
    return appEvtData;
};

SojournerContext.prototype.deleteData = function deleteData(event, key) {
    var appEvtData = this.m_appData[event];
    var current = appEvtData ? appEvtData[key] : undefined;
    if (current) {
        delete appEvtData[key];
        if (Object.keys(appEvtData).length === 0) {
            delete this.m_appData[event];
        }
    }
    return current;
};

/**
 * Get the data value associated for the given event and key as String
 * @param event identifies the event
 * @param key identifies the data
 * @return the data value associated for the given event and key
 */
SojournerContext.prototype.getDataAsString = function (event, key) {
    var appEvtData = this.m_appData[event];
    var value = appEvtData ? appEvtData[key] : null;
    if (!nullCheck(value)) {
        return value.toString();
    } else {
        return null;
    }
};

/**
 * Get type of the data associated for the given event and key
 * @param event identifies the event
 * @param key identifies the data
 */
SojournerContext.prototype.getVectorType = function ( /*event,key*/ ) {
    return null;
};
/**
 * Return true if context data for the key has been added already
 * @param key identifies the context data
 * @return true if data for the given key has already been added
 */
SojournerContext.prototype.hasContext = function (key) {
    return !_.isUndefined(this.m_contextData[key]);
};
/**
 * Set a bit in the flags for the application message if the flag is active or emitting
 * of inactive flags is enabled.
 * @param bitpos an instance of an enum that used to obtain the bit position
 * that the value is used to set.  The leftmost bit is position 0.  The enum must
 * be non-negative.
 * @param value true means the bit is truned on, false implies off
 */
SojournerContext.prototype.setAppFlag = function (flag, value) {
    setFlag(this.m_appFlagMap, this.MAX_BITPOSITION, flag, value);
};

/**
 * Set a bit in the flags for BOT Detection
 * @param bitpos an instance of an enum that used to obtain the bit position
 * that the value is used to set.  The leftmost bit is position 0.  The enum must
 * be non-negative.
 * @param value true means the bit is truned on, false implies off
 */
SojournerContext.prototype.setContextFlag = function (flag, value) {
    setFlag(this.m_contextFlagMap, this.CONTEXT_MAX_BIT_POSITION, flag, value);
};

/**
 * Test if a flag is set.
 * @param bitpos the flag to check.
 * @return true if the flag is set, false otherwise.
 */
SojournerContext.prototype.isAppFlagSet = function (flag) {
    return !nullCheck(this.m_appFlagMap[flag.bit]);
};
SojournerContext.prototype.isContextFlagSet = function (flag) {
    return !nullCheck(this.m_contextFlagMap[flag.bit]);
};


/**
 * Save an application context by the given name that can be retrieve later.
 * It's contents will be included in the Sojourner application event message.
 */
SojournerContext.prototype.setAppDataContext = function (name, sojAppCtx) {
    this.m_appContexts[name] = sojAppCtx;
};

/**
 * Get the SojournerApplicationContext object stored under a particular name, or
 * null if it has not been set yet.
 */
SojournerContext.prototype.getAppDataContext = function (name) {
    return this.m_appContexts[name];
};

/**
 * Get GUID in current context, or null if does not exist
 */
SojournerContext.prototype.getGuid = function () {
    return this.getSojournerContextData(eBayTags.G);
};

/**
 * Get SojournerContextData value in current context, or null if does not exist
 */
SojournerContext.prototype.getSojournerContextData = function (key) {
    return this.m_contextData[key];
};

SojournerContext.prototype.getROIDataMap = function () {
    return this.m_roiData;
};
SojournerContext.prototype.getSiteCatalystDataMap = function () {
    return this.m_siteCatalystData;
};

SojournerContext.prototype.isRightEvent = function (event) {
    return (SojournerEventEnum.APPLICATION === event || SojournerEventEnum.CLICK === event ||
        SojournerEventEnum.COOKIE === event);
};

SojournerContext.prototype.addOtherDestinations = function (key, data) {
    if (key.isROI) {
        this.addROIData(key, data);
    }
    if (key.isSiteCatalyst) {
        this.addSiteCatalystData(key, data);
    }
};
SojournerContext.prototype.getAppDataMapByEvent = function (event) {
    var eventDataMap = this.m_appData[event];
    if (nullCheck(eventDataMap)) {
        eventDataMap = {};
        this.m_appData[event] = eventDataMap;
    }
    return eventDataMap;
};
SojournerContext.prototype.addROIData = function (key, data) {
    if (key.isActive) {
        var trkKey = key.roiRef;
        if (nullCheck(trkKey)) {
            this.m_roiData[key.name] = data;
        } else {
            this.m_roiData[trkKey.name] = data;
        }
    }
};
SojournerContext.prototype.addSiteCatalystData = function (key, data) {
    if (key.isActive) {
        this.m_siteCatalystData[key] = data;
    }
};

SojournerContext.prototype.getCurrentImpression = function getCurrentImpression(event) {
    return this.getData(event, eBayTags.CURRENT_IMPRESSION_ID);
};

SojournerContext.prototype.blockCurrentImpression = function blockCurrentImpression(event) {
    return this.blockData(event, eBayTags.CURRENT_IMPRESSION_ID);
};

function nullCheck(obj) {
    return _.isNull(obj) || _.isUndefined(obj);
}

function setFlag(flagSet, maxBitPostion, flag, value) {
    var bitpos = flag.bit;
    if (bitpos < 0 || bitpos > maxBitPostion) {
        logger.error('bitpos cannot be less than 0 or more than max:', bitpos);
        return;
    }
    if (value === true) {
        flagSet[bitpos] = flag;
    } else {
        flagSet[bitpos] = null;
    }
}
