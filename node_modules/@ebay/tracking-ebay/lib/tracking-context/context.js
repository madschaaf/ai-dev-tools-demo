'use strict';

/**
 * Request and Response headers work
*/

var assert = require('assert');
var logger = require('@ebay/logging-inc').logger('tracking-ebay:helper');

const utils = require('../utils');

const Tags = require('../entities/tags.js');
const Flags = require('../entities/flags.js');
const Modules = require('../entities/modules.js');

const SojournerContext = require('../soj/SojournerContext');
const SojournerEventEnum = require('../soj/sojourner-event-enums.js');

const CorrelationSession = require('../cos/correlation-session');
const PulsarContextManager = require('../tracking2/pulsar-context-manager');
const PulsarDataDelegator = require('../tracking2/pulsar-header-data-delegator');
const CIIDGenerator = require('../taas/ciid-generator.js');
const X_CDN = 'x-cdn';
const X_REQUEST_CATEGORY = 'x-request-category';

class Context{
    constructor(req, res) {
        this.req = req;
        this.res = res;
        this.sojournerContext = new SojournerContext();
        this.ciid = null;

        // lazy load of pulsar, i.e. only when it is really used
        // TODO: completely remove it from tracking 1.0
        this.pulsarContextManager = undefined;

        const routeConfig = req.route && req.route.config && req.route.config.tracking;
        if (routeConfig) {
            this.flagsEnabled = routeConfig.flagsEnabled;
            this.siteCatalystPageName = routeConfig.siteCatalystPageName;
            this.isLowVolume = routeConfig.isLowVolume;
            this.applicationId = routeConfig.applicationId;
            this.generateCiid = routeConfig.generateCiid;

            if (this.generateCiid && this.generateCiid === true) {
                this.ciid = CIIDGenerator.nextId();
            }
        }

        const ebayRequestContext = req.ebay;
        this.isExpSvc = ebayRequestContext && ebayRequestContext.expSvc && ebayRequestContext.expSvc.operationId;

        if (ebayRequestContext && ebayRequestContext.getPageId) {
            this.pageId = ebayRequestContext.getPageId();
            this.pageName = ebayRequestContext.getPageName();
        } else {
            this.pageId = null;
            this.pageName = null;
        }

        this.enabled = this.pageId != null &&
            (routeConfig == null || routeConfig.enabled !== false);
    }

    getCorrelationSession(clientSide) {
        const key = `_correlationSessionHeader${clientSide ? '_clientside' : ''}`;
        this[key] = this[key] || CorrelationSession.create(this.req, clientSide);
        return this[key];
    }

    _getPulsarContextManager() {
        this.pulsarContextManager = this.pulsarContextManager || PulsarContextManager.getInstance(this.req, this.res);
        return this.pulsarContextManager;
    }

    updateSojournerBookKeeping() {
        // noop
    }

    getRequestScopeTracker(options) {
        return this._getPulsarContextManager().getRequestScopeTracker(options);
    }

    getPulsarEventTracker(options) {
        return this._getPulsarContextManager().getPulsarEventTracker(options);
    }

    _trackFlagsFromSvc(value, fn) {
        var bytes = utils.btoa(value);
        var bit = 0;
        var _this = this;

        function byteToBit(m) {
            var i = 1 << 7;
            while (i > 0) {
                if ((i & m) > 0) {
                    fn.call(_this, bit);
                }
                bit++;
                i = i >> 1;
            }
        }
        bytes.forEach(function (x) {
            byteToBit(x.toString(10));
        });
    }

    _trackTagInternal(eventEnum, tag, value, append, vectorTypeEnum) {
        var sojournerContext = this.sojournerContext;

        var tagObj = tag && Tags.getTagByName(tag.toString());
        if (!tagObj) {
            logger.warn('not valid sojourner tag being logged:', tag);
            return;
        }
        if (value === null || value === undefined || (!append && Array.isArray(value))) {
            logger.warn('not valid sojourner value being logged:', value, 'for key:', tag);
            return;
        }
        if (append) {
            sojournerContext.addVectorData(eventEnum, tagObj, value, vectorTypeEnum);
        } else {
            sojournerContext.addData(eventEnum, tagObj, value.toString());
        }
    }

    trackTag(tag, value) {
        if (this.enabled === false) {
            return;
        }

        this._trackTagInternal(SojournerEventEnum.APPLICATION, tag, value, false);
    }

    getCiid() {
        return this.ciid;
    }

    trackVectorTag(tag, value, vectorTypeEnum) {
        if (this.enabled === false) {
            return;
        }

        var values = [];
        if (!Array.isArray(value)) {
            values.push(value);
        } else {
            values = value;
        }
        values.forEach(function (val) {
            this._trackTagInternal(SojournerEventEnum.APPLICATION, tag, val, true, vectorTypeEnum);
        }, this);
    }

    trackContextFlag(bit, value) {
        if (this.enabled === false) {
            return;
        }

        var sojournerContext = this.sojournerContext;

        var flag = Flags.getContextFlag(bit);
        if (!flag) {
            logger.error(new Error('not valid sojourner context flag being logged, flag:' + flag + ', bit: ' + bit));
            return;
        }

        sojournerContext.setContextFlag(flag, (value === undefined || value === true) ? true : false);
    }

    trackFlag(bit, value) {
        if (this.enabled === false) {
            return;
        }

        var sojournerContext = this.sojournerContext;
        if (this.flagsEnabled === undefined || this.flagsEnabled !== true) {
            logger.error(new Error('please set flagsEnabled for tracking middleware!'));
            return;
        }

        bit = bit.bit || bit; //backward compatible to use flag enum.
        var flag = Flags.getAppFlag(bit, this.pageId);
        if (!flag) {
            logger.error('not valid sojourner flag being logged:', bit, new Error('not valid sojourner flag being logged'));
            logger.error('Make sure page id:', this.pageId,
                'has associated flagset and flag bit:', bit, 'is in flagset');
            return;
        }
        sojournerContext.setAppFlag(flag, (value === undefined || value === true) ? true : false);
    }

    //service return the raw sojourner name/value, need to merge it to sojournerContext
    trackSojournerFromSvc(eventEnum, sojournerFromSvc) {
        if (this.enabled === false || !sojournerFromSvc) {
            return;
        }

        logger.debug(sojournerFromSvc);

        sojournerFromSvc.split('&').forEach(function (nv) {
            var nvArray = nv.split('=');
            if (nvArray.length !== 2) {
                logger.error('invalid service tracking data trying to log:' + nv);
                return;
            }
            var tag = nvArray[0];
            if (utils.isVector(tag)) {
                var values = utils.vectorValueFromStr(nvArray[1]) || [];

                values.forEach(function (v) {
                    this._trackTagInternal(eventEnum, utils.getVectorName(tag), v, true);
                }, this);
            } else if (utils.isAppFlag(tag)) {
                this._trackFlagsFromSvc(nvArray[1], this.trackFlag);
            } else if (utils.isContextFlag(tag)) {
                this._trackFlagsFromSvc(nvArray[1], this.trackContextFlag);
            } else {
                var value = utils.decode(nvArray[1]);
                this._trackTagInternal(eventEnum, tag, value, false);
            }

        }, this);

    }

    isTrackingEnabled() {
        return this.enabled;
    }

    trackModuleImpression(moduleId) {
        if (this.enabled === false) {
            return;
        }

        assert.ok(moduleId, 'moduleId is required');
        assert.ok(typeof moduleId === 'string' || typeof moduleId === 'number', 'moduleId should be a number or string');

        var module = Modules.getModuleById(moduleId);
        if (!module) {
            logger.warn('Module id not found in the tracking modules.json,  invalid module id trying to log:', moduleId);
            // return;
        }
        this._trackTagInternal(SojournerEventEnum.APPLICATION, Tags.MODULE_IMPRESSION_TO, moduleId, true);
    }

    getSPTagValue(moduleId, linkId) {
        return utils.generateSPTagValue(this.pageId, moduleId, linkId);
    }

    track() {
        if (this.enabled === false) {
            return;
        }

        this.instrumentResponse();
    }

    buildTrackingHeadersForRequest() {
        var headers = {};
        return this.addTrackingHeadersForRequest(headers);
    }

    addTrackingHeadersForRequest(headers) {
        headers = headers || {};
        if (this.enabled === false) {
            return headers;
        }

        assert.ok(headers, 'Headers should not be null');

        const req = this.req;
        const ebay = req.ebay;
        const sojournerContext = this.sojournerContext;

        let headerValue = ebay.getCorrelationTracking().buildHeader(ebay) || '' ;

        if (req.headers && req.headers[X_CDN] && req.headers[X_CDN].length < 10) {
            if (headerValue) {
                headerValue += `,cdn=${req.headers[X_CDN]}`;
            } else {
                headerValue += `cdn=${req.headers[X_CDN]}`;
            }
        }

        if (req.headers && req.headers[X_REQUEST_CATEGORY] && req.headers[X_REQUEST_CATEGORY].length < 40) {
            if (headerValue) {
                headerValue += `,bottype=${req.headers[X_REQUEST_CATEGORY]}`;
            } else {
                headerValue += `bottype=${req.headers[X_REQUEST_CATEGORY]}`;
            }
        }

        logger.debug('tracking header:', headerValue);
        headers['X-EBAY-C-TRACKING'] = headerValue;


        if (Flags.GlobalFlags && Flags.GlobalFlags.DETECTED_BOT) {
            var isBot = sojournerContext.isContextFlagSet(Flags.GlobalFlags.DETECTED_BOT);
            if (isBot) {
                headers['X-EBAY-BOT'] = 'true';
            }
        }

        // set tracking 2.0 C-session-id header
        headers['X-EBAY-C-SESSION-ID'] = sojournerContext.getGuid();
        const correlationSession = this.getCorrelationSession();
        /** Need to increment the UAID counter if UAID is present and the service is a COS or REST servivce not Experience Service
         * Check com.ebay.pulsar.client.raptor.RaptorPulsarDataPropagator.modifyRequest
         */
        headers['X-EBAY-C-CORRELATION-SESSION'] = correlationSession.buildHeader();
        return headers;
    }

    handleResponse(serviceResponse) {
        this.handleResponseHeaders(serviceResponse.headers);
        this.sojournerContext.setResponseCode(serviceResponse.statusCode);
    }

    generateCorrelationSessionHeader(clientSide) {
        var pulsarHeader = PulsarDataDelegator.create(this.req).getCorrelationSessionHeader(clientSide);
        if (pulsarHeader) {
            return pulsarHeader.buildHeader();
        }
    }

    handleResponseHeaders(headers) {
        if (this.enabled === false || !headers) {
            return;
        }

        const trackingData = headers['x-ebay-svc-tracking-data'] || headers['X-EBAY-SVC-TRACKING-DATA'];

        logger.debug('trackingData:', trackingData);

        if (trackingData && trackingData.length > 0) {
            const aMatch = /(<a>(.+)<\/a>)/.exec(trackingData);
            const aEvent = aMatch ? aMatch[2] : null;
            if (aEvent) {
                if (this.isExpSvc) {
                    const expSvcImpression = utils.getSOJEventPart(aEvent, 'ciid');
                    const operationId = utils.getSOJEventPart(aEvent, 'operationId') || utils.getSOJEventPart(aEvent, 'operationid');
                    if (expSvcImpression && operationId !== undefined) {
                        // set the expSvcImpression/ciid only if operationId is provided.
                        this.expSvcImpression = expSvcImpression;
                        this.sojournerContext.blockEvent(SojournerEventEnum.CLICK);
                        this.sojournerContext.blockEvent(SojournerEventEnum.APPLICATION);
                        logger.info('Skipping soj tracking as experience service has done it already:', aEvent);
                        return;
                    }
                }

                this.trackSojournerFromSvc(SojournerEventEnum.APPLICATION, aEvent);
            }

            const kMatch = /(<k>(.+)<\/k>)/.exec(trackingData);
            const kEvent = kMatch ? kMatch[2] : null;
            if (kEvent) {
                this.trackSojournerFromSvc(SojournerEventEnum.CLICK, kEvent);
            }

            const cMatch = /(<c>(.+)<\/c>)/.exec(trackingData);
            const cEvent = cMatch ? cMatch[2] : null;
            if (cEvent) {
                this.trackSojournerFromSvc(SojournerEventEnum.COOKIE, cEvent);
            }
        }
    }
  
    isCacheRequest() {
        const req = this.req;
        return req.headers && req.headers['ufes-nonuser-context'] === 'true';
    }

    setUserActionId(userActionId) {
        this.userActionId = userActionId;
        this.getCorrelationSession().setUAID(userActionId);
    }
}

module.exports = Context;
