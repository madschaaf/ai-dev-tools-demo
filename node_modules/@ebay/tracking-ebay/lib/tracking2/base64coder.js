'use strict';

const KernelBase64 = {
    //////////////////////license & copyright header///////////////////////
    //                                                                   //
    //                Copyright (c) 1998 by Kevin Kelley                 //
    //                                                                   //
    // This program is free software; you can redistribute it and/or     //
    // modify it under the terms of the GNU General Public License as    //
    // published by the Free Software Foundation; either version 2 of    //
    // the License, or (at your option) any later version.               //
    //                                                                   //
    // This program is distributed in the hope that it will be useful,   //
    // but WITHOUT ANY WARRANTY; without even the implied warranty of    //
    // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     //
    // GNU General Public License for more details.                      //
    //                                                                   //
    // You should have received a copy of the GNU General Public License //
    // along with this program in the file 'gpl.html'; if not, write to  //
    // the Free Software Foundation, Inc., 59 Temple Place - Suite 330,  //
    // Boston, MA 02111-1307, USA, or contact the author:                //
    //                                                                   //
    //                       Kevin Kelley  <kelley@iguana.ruralnet.net>  //
    //                                                                   //
    ////////////////////end license & copyright header/////////////////////


    /**
     * Encode arbitrary binary into printable ASCII using BASE64 encoding.
     * Base64 is a way of encoding 8-bit characters using only ASCII printable
     * characters.  The spec is described in RFC 2045.  Base64 is a scheme where
     * 3 bytes are concatenated, then split to form 4 groups of 6-bits each; and
     * each 6-bits gets translated to an encoded printable ASCII character, via a
     * table lookup.  An encoded string is therefore longer than the original by
     * about 1/3.  The "=" character is used to pad the end.
     */

	 //TODO test Base64.encode(new Int8Array([-125, 122, 69, 58, 32])) encodes to g3pFOiA* and viceversa

	 codes: ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
	 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
	 '0','1','2','3','4','5','6','7','8','9',
	 '+','/', '-1'],


    alphabet1: ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
				'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
				'0','1','2','3','4','5','6','7','8','9',
				'+','/','='],

    alphabet2: ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
				'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
				'0','1','2','3','4','5','6','7','8','9',
				'+','/','*'],

    /**
	* returns a String of base64-encoded characters to represent the
	* passed data array.
	*
	* @param byte[] data - the array of bytes to encode
	* @param boolean isStandard, true means to use standard ending char '=', false to
	*        use eBay ending character '*'. For eBay cookie, use false instead.
	* @return base64-coded String.
    */

    encode(data, isStandard)
	{
		let out = new Array(((data.length + 2) / 3) * 4 | 0);
		let alphabet = isStandard ? this.alphabet1 : this.alphabet2;

		//
		// 3 bytes encode to 4 chars.  Output is always an even
		// multiple of 4 characters.
		//
		for(let i = 0, index = 0; i < data.length; i += 3, index += 4)
		{
			let quad = false;
			let trip = false;
			let val = 0xFF & data[i];

			val <<= 8;
			if((i + 1) < data.length)
			{
				val |= (0xFF & data[i + 1]);
				trip = true;
			}

            val <<= 8;
			if((i + 2) < data.length)
			{
				val |= (0xFF & data[i + 2]);
				quad = true;
			}

			out[index + 3] = alphabet[(quad ? (val & 0x3F) : 64)];
			val >>= 6;
			out[index + 2] = alphabet[(trip ? (val & 0x3F) : 64)];
			val >>= 6;
			out[index + 1] = alphabet[val & 0x3F];
			val >>= 6;
			out[index + 0] = alphabet[val & 0x3F];
		}

		return  out.join('');
	},

	/**
	 * return decoded array of bytes
	 *
	 * @param String strData a base64-encoded string
	 * @param boolean isStandard - indicating whether the string was encoded
	 *        with standard ending character("=").
	 * @return decoded byte array
	 */
	decode(strData, isStandard) {
		let data = strData.split();
		let len = ((data.length + 3) / 4) * 3;
		const endingChar = isStandard ? '=' : '*';

		if (data.length > 0 && data[data.length - 1] === endingChar) {
			--len;
		}

        if (data.length > 1 && data[data.length - 2] === endingChar) {
		    --len;
		}

		let out = new Int8Array(len);
		let shift = 0; // # of excess bits stored in accum
		let accum = 0; // excess bits
		let index = 0;
		for(let ix = 0; ix < data.length; ix++)
		{
			let value = this.codes[data[ix] & 0xFF]; // ignore high byte of char
			if (value >= 0)	// skip over non-code
			{
				accum = accum << 6;		// bits shift up by 6 each time thru
				shift = shift + 6;		// loop, with new bits being put in
				accum = accum | value;	// at the bottom.
				if(shift >= 8)          // whenever there are 8 or more shifted in,
				{
					shift = shift - 8;         // write them out (from the top, leaving any excess at the bottom for next iteration.
					out[index++] = (accum >> shift) & 0xff;
				}
			}
		}

		return out;
	}
};

/**
 *  Custom base64 encoder/decoder used bytracking to encode/decode 32 bit integers
 */

const TrakingBase64 = {
    BASE:  ['0','1','2','3','4','5','6','7','8','9',
            'A','B','C','D','E','F','G','H','I','J','K','L',
            'M','N','O','P','Q','R','S','T','U','V','W','X',
            'Y','Z','a','b','c','d','e','f','g','h','i','j',
            'k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','-','_','!'],

    decode(value) {
        var intValue = 0;

        for (var idx = 0; idx < value.length; idx++) {
            var num = this.BASE.indexOf(value.charAt(idx));
            if (num === -1) {
                return undefined; // bad format
            }
            intValue += Math.pow(this.BASE.length, value.length - idx - 1) * num;
        }

        return intValue;
    },

    encode(num) {
        var encoded = '';
        for (encoded = ''; num >= 64; num = num/64 | 0) {
            encoded = this.BASE[num % 64] + encoded;
            console.log('encoded: ', encoded);
        }
        encoded = (num >= 0 ? this.BASE[num] : '') + encoded;
        return encoded;
    }
};

module.exports = {
    KernelBase64,
    TrakingBase64
};