'use strict';

const dateFormat = require('dateformat');
const assert = require('assert');
const provider = require('@ebay/service-client-ebay');
const Utils = require('../utils');

function getSiteInfo(url, siteoverride, callback) {
    var args = [].slice.call(arguments);
    url = args.shift();
    callback = args.pop();
    siteoverride = args.shift();

    var query = {
        url: encodeURIComponent(url)
    };

    if (siteoverride || siteoverride === 0) {
        query.siteoverride = siteoverride;
    }

    provider.context({}).getClient('kernelSvc')
    .get(query)
    .path('/site-info')
    .end(function(err, response) {
        if (err) {
            return callback(err, null);
        }
        return callback(null, response.body);
    });
}

function getCurrencyList(callback) {
    provider.context({}).getClient('kernelSvc')
    .get()
    .path('/currency-list')
    .end(function(err, response) {
        return callback(err, response && response.body && response.body.list);
    });
}

function getSignInLink(options, callback) {
    assert(options);
    assert(options.returnUrl);
    assert(options.pageId);

    provider.context({}).getClient('kernelSvc')
    .get({
        returnUrl: encodeURIComponent(options.returnUrl),
        pageId: options.pageId,
        needsConfirmSignIn: !!options.needsConfirmSignIn,
        isL2Auth: !!options.isL2Auth,
        radarHighRisk: !!options.radarHighRisk
    })
    .path('/sign-in-link')
    .end(function(err, response) {
        if (err) {
            return callback(err);
        }

        // patch mini-sites
        let link = response &&
            response.body && response.body['sign-in-link'];
        if (!link) {
            return callback(new Error(`Failed to detect sign-in-link in response from kernel service`));
        }

        try {
            const returnUrlOptions = Utils.parseUrl(options.returnUrl);
            const mini = returnUrlOptions.hostOptions && returnUrlOptions.hostOptions.mini;
            if (mini) {
                const linkOptions = Utils.parseUrl(link);
                linkOptions.hostOptions.mini = mini;
                linkOptions.hostOptions.country = returnUrlOptions.hostOptions.country;
                link = Utils.formatUrl(linkOptions);
            }            
        } catch (err) {
            return callback(err);
        }

        return callback(err, link);
    });
}

function getExchangeRate(fromCurrency, toCurrency, whenTime) {
    if (!fromCurrency) {
        throw new Error(`Invalid fromCurrency "${fromCurrency}", should be valid currency code`);
    }
    if (!toCurrency) {
        throw new Error(`Invalid toCurrency "${toCurrency}", should be valid currency code`);
    }
    if (!whenTime || !(whenTime instanceof Date)) {
        throw new Error(`whenTime parameter must be provided as a Date object, actual:${whenTime}`);
    }

    return new Promise((resolve, reject) => {
        const when = dateFormat(whenTime.getTime(), 'yyyy-mm-dd hh:MM:ss');
        provider.context({}).getClient('kernelSvc')
        .get({
            from: fromCurrency,
            to: toCurrency,
            when
        })
        .path('/exchange-rate')
        .end(function(err, response) {
            if (err) {
                return reject(err);
            }

            const body = response.body;
            if (body.error) {
                const message = body.error &&
                    body.error.message ||
                    'Unknown error during exchange rate call';
                return reject(new Error(message));
            }

            if (!body.rate) {
                return reject(new Error('Missing exchange rate in the response'));
            }
            return resolve(body.rate);
        });
    });
}

module.exports = {
    getSiteInfo: getSiteInfo,
    getCurrencyList: getCurrencyList,
    getSignInLink: getSignInLink,
    getExchangeRate: getExchangeRate
};
