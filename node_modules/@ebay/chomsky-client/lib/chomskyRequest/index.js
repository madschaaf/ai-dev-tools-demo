'use strict';
const { fetch: ebayFetch } = require('@ebay/ebay-fetch');

/**
 * @typedef {('_openai_embedding'|'_openai_chat_completion'|'_openai_completion'|'_openai_dalle')} ServiceName
 * @typedef {('POST'|'GET'|'PUT'|'DELETE')} RequestType
 */

/**
 * Creates Open AI Request
 * 
 * @param {ServiceName} serviceName  service name from config possible 
 * @param {any} body JSON object of keys
 * @param {RequestType} requestType  request type. Default: POST
 * @param {any} context  context object
 * @returns {Promise<any>}
 */
function openaiRequest(serviceName, body, options = { headers: {} }, requestType = 'POST') {
    const { headers, path, ...otherOptions } = options;
    const operationPath = path || (body.stream === true ? '/stream/genai' : '/genai');
    if (body.stream === true) {
        otherOptions['stream-response'] = true;
    }
    const chomskyGatewayHeaders = {...headers, 'X-EBAY-CHOMSKY-MODEL-NAME': body.model};
    delete body.model;
    if (body.tracingEntityId) {
        chomskyGatewayHeaders['X-EBAY-TRACING-ENTITY-ID'] = body.tracingEntityId;
        delete body.tracingEntityId;
    }
    if (body.tracingEntityType) {
        chomskyGatewayHeaders['X-EBAY-TRACING-ENTITY-TYPE'] = body.tracingEntityType;
        delete body.tracingEntityType;
    }
    serviceName = options.serviceName || serviceName;

    return ebayFetch(serviceName, { moduleRef: module, isContext: true }, {
        headers: {
            'content-type': 'application/json',
            ...chomskyGatewayHeaders
        },
        method: 'POST',
        body: JSON.stringify(body),        
        options: {
            path: operationPath,
            ...otherOptions
        }
    }).then(res => {
        if (res.status >= 400) {
            throw new Error(res.statusText);
        }
        // fetch needs to provide raw body if requested,
        // for now piggyback on json that still returns body object
        return res.json();
    }).then(res => {
        if (res.error) {
            throw createError(res.error);
        } else if (res.errors) {
            throw createError(res.errors[0]);
        }
        else return res;
    });
}

function createError(error) {
    if (typeof error === 'string') {
        return new Error(error);
    }
    return Object.assign(new Error(error.message || 'Unknown error'), {
        type: error.type,
        code: error.code
    });
}

module.exports = {
    openaiRequest
}