/*global escape: true */
'use strict';

const LRUCache = require('lru-backup-cache'),
    moduleConfig = require('@ebay/module-config-inc'),
    debug = require('debug')('@ebay/device-detection-ebay'),
    logger = require('@ebay/logging-inc').logger('device-detection-ebay'),
    deviceInfo = require('./DeviceInfo'),
    deviceDetectionService = require('./service'),
    appContext = require('@ebay/app-context-ebay');

const clientHints = require('@ebay/client-hints-ebay');

/* Device Info LRUCache */
let cache;

let ddconfig;
initDDConfig();

function initDDConfig() {
    moduleConfig(module, function (err, config) {
        if (err) {
            return;
        }
        ddconfig = config;
        ddconfig.on('change', function cleanDDCache() {
            cache && cache.reset();
        });
    });
}


function addToCache(cacheKey, value) {
    if (cache) {
        cache.set(cacheKey, value);
        return;
    }

    moduleConfig(module, function (err, config) {
        if (err) {
            return;
        }

        cache = cache || new LRUCache(config.get('device-detection-ebay').cache);
        cache.set(cacheKey, value);
        return;
    });
}


// We check if v3 api is enabled or not based on 3 steps:
// 1. Check forceDdsVersion in module config, if it is NOT_SET, keep checking next step, otherwise return the value
// 2. check application properties configured in the app
// 3. check global config app allow list
function isV3ApiEnable() {
    if(!ddconfig){
        return false;
    }
    var forceDdsVersion = ddconfig.get('device-detection-ebay:forceDdsVersion');

    if (forceDdsVersion !== 'NOT_SET') {
        return forceDdsVersion === 'v3';
    }

    var ddsVersion = ddconfig.get('device-detection-ebay:ddsVersion');
    if (ddsVersion === 'v3') {
        return true;
    }

    var v3ApiApps = ddconfig.get('device-detection-ebay:v3ApiApps');
    const appName = appContext.appName;
    if (v3ApiApps && v3ApiApps.length > 0) {
        if (v3ApiApps.indexOf(appName) !== -1) {
            return true;
        }
    }

    return false;
}

function getDeviceInfoFromService(params, hasClientHints, cacheKey, callback) {
    const serviceName = hasClientHints ? 'getCHDeviceInfo' : 'getDeviceInfo';
    // Call method isV3ApiEnable to check if v3 api is enabled or not
    const ddsVersion = isV3ApiEnable() ? 'v3' : 'v2';
    debug('Using the Device Detection Service Version : ' + ddsVersion);
    deviceDetectionService[serviceName](ddsVersion, params, function (error, body) {
        if (!error && body) {
            /* Cache only when service responded successfully not the result provided by the fallback logic */

            if (body.status) {
                delete body.status;
            }
            addToCache(cacheKey, body);
        } else {
            debug('Using the express-useragent Fall back to get the Device Info');
            body = deviceInfo.fromUserAgent(params.userAgent);
        }

        callback && callback(error, body);
    });
}

// Added for backward compatible
//getDeviceInfo(params, hasClientHints, callback)
function getDeviceInfo(...args) {
    let params = args[0];
    if(typeof params === 'string') {
        params = { userAgent:  params};
    }

    let callback, hasClientHints;

    if(args.length === 3) {
        hasClientHints = args[1];
        callback = args[2];
    } else {
        hasClientHints = false;
        callback = args[1];
    }
    
    const cacheKey = createCacheKey(params);

    if (debug.enabled) {
        debug('cache key : ' + cacheKey);
        debug('user agent param : ' + JSON.stringify(params));
    }

    let deviceInfo = cache && cache.get(cacheKey);

    if (!deviceInfo) {
        /* Get it from backup cache */
        deviceInfo = cache && cache.getBackup(cacheKey);

        /* Re-Cache it in memory until refresh succeed. */
        deviceInfo && addToCache(cacheKey, deviceInfo);

        if (deviceInfo) {
            /* Schedule Refresh */
            setImmediate(() => {
                getDeviceInfoFromService(params, hasClientHints, cacheKey);
            });
        }
    }

    if(deviceInfo) {
        /* Clone device Info */
        callback(null, Object.assign({}, deviceInfo));
    } else {
        getDeviceInfoFromService(params, hasClientHints, cacheKey, (err, body) => {
            callback(err, Object.assign({}, body));
        });
    }
}


function middleware() {
    return function detectDevice(req, res, next) { 
        
        var routeConfig = req.route && req.route.config && req.route.config.dds;
        if (routeConfig && routeConfig.enabled === false) {
            logger.info('Device Detection is disabled for this route');
            return next();
        }

        clientHints.getClientHintConfig()
        .then((cfg) => {            
            // Call only if CH is enabled
            if(cfg && cfg.isEnabled() === true) {
                // Request Headers
                const chReqHeaders = cfg.getCHRequestHeaders() || [];                
                const reqClientHintsMap = {};
                for(let elem of chReqHeaders) {
                    if(req.headers[elem]) {
                        reqClientHintsMap[elem] = req.headers[elem];
                    }
                }                
                return chDeviceInfo(req, reqClientHintsMap, next);
            } else {
                return uaDeviceInfo(req, next);                
            }
        });
    };
}

function uaDeviceInfo(req, next) {
    const params = { userAgent:  getUserAgent(req)};
    getDeviceInfo(params, false, (error, deviceInfo) => {
        req.deviceInfo = deviceInfo;
        req.deviceInfo.isFSOM = getIsFSOM(req);
        req.deviceInfo.isNative = getIsNative(req);
        req.deviceInfo.requestIsWebView = req.query && req.query.trackingApp === 'webview';
        return next();
    });
}

function chDeviceInfo(req, reqClientHintsMap, next) {
    let body = {
        headers: {
            'user-agent': getUserAgent(req)
        }
    };
    Object.assign(body.headers, reqClientHintsMap);

    getDeviceInfo(body, true, (error, deviceInfo) => {        
        req.deviceInfo = deviceInfo || {};
        req.deviceInfo.isFSOM = getIsFSOM(req);
        req.deviceInfo.isNative = getIsNative(req);
        req.deviceInfo.requestIsWebView = req.query && req.query.trackingApp === 'webview';
        return next();
    });
}

function getUserAgent(req) {
    return (req && req.ebay && req.ebay.getUserAgent()) || '';
}

function getIsFSOM(req) {
    return req && req.ebay && req.ebay.getEndUserContext() && req.ebay.getEndUserContext().userPrefersDesktopExperience();
}

function getIsNative(req) {
    return req && req.ebay && req.ebay.getUserAgent && /^ebay/i.test(req.ebay.getUserAgent());
}

function createCacheKey(params) {
    return 'ua_' + JSON.stringify(params);
}

module.exports = {
    middleware: middleware,
    getDeviceInfo: getDeviceInfo,
    $internals$:  {
        undefineCache() {
            cache = undefined;
        },

        clearCache() {
            cache && cache.reset();
        },

        getDDConfig() {
            return ddconfig;
        },

        getCache() {
            return cache;
        },

        expireFromCache(ua) {
            const params = { userAgent: ua };
            const cacheKey = createCacheKey(params);
            const deviceInfo = cache && cache.get(cacheKey);

            addToCache(cacheKey, undefined);
            cache._mainCacheDispose(cacheKey, deviceInfo);
        }
    }
};
