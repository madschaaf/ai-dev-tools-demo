'use strict';
var util = require('util');

var cal = require('@ebay/cal'),
    moduleconfig = require('@ebay/module-config-inc');

/**
 * Middleware Factory
 */
module.exports = function middleware() {
    return xssMiddleware;
};

var fullExemptionsCache = {};
var partialExemptionsCache =  {};

const exemptContentTypes = ['text/html', 'text/plain;charset=UTF-8'];

/**
 * 1. When UrlCheck is false should not sanitize URL path
 * 2. When UrlCheck is true should sanitize URL path and update it
 * 3. When UrlCheck is not specified should log violation but NOT update it
 * 4. When requestParameterCheck is false should not sanitize req.query, req.params, req.body
 * 5. When requestParameterCheck is true/unspecified should sanitize req.query, req.params, req.body
 */

function xssMiddleware(req, res, next) {
    moduleconfig(module, function(err, config) {
        if (err) {
            return next();
        }

        const validator = new XssValidator(config, createLogger(res));

        validator.sanitizeAll(req);

        next();
    });
}

class XssValidator {
    constructor(config, log) {
        this.log = log;
        this.config = config;
    }

    sanitizeAll(req) {
        const meta = this.getPageMeta(req);
        this.sanitizeUrlPath(req, meta);
        this.sanitizeParameters(req, meta);
    }
    /**
     * Returns true of the applicatin + page is allowed to disable 
     * xss checks on req.body object. Few applications that accepts 
     * octect-stream/html/text payloads needs the ability to disable 
     * these checks to improve performance. 
     * 
     * Platform team conciously evaluates the requirements of the app and 
     * whitelists it. 
     * 
     * @param {*} req Current request
     * @param {*} pageMeta Meta data associated with current page request
     */
    isBodyCheckDisabled(req, pageMeta){
        let isDisabled = false;
        //
        const appName = (req ? req.appName: undefined);
        const pageName = (pageMeta ? pageMeta.pageName: undefined);
        const isContentTypeEligibleToWhitelist = req.get && exemptContentTypes.includes(req.get('content-type'));
        //
        if(appName && pageName && isContentTypeEligibleToWhitelist){ // If app Name & Page Name are availabel
            const whitelistConfig = this.config.get(`security-ebay:xss-body-check-whitelist:${appName}`);
            if(whitelistConfig){
                const whitelistedPages = whitelistConfig.split(",").map(item => item.trim());
                if(whitelistedPages.indexOf(pageName) !== -1){
                    isDisabled =  true;
                }
            }  
        }
    
        return isDisabled;
    }
    /**
     * When page meta data is not found should return following default values
     *      strictMode: true
     *
     *      fullExemptions: ''
     *      partialExemptions: ''
     *
     *      sanitizeUrlPath: false
     *      sanitizeParameters: false
     *
     * When page meta data overrides application config (xss-security-ebay)
     */
    getPageMeta(req) {
        const config = this.config;
        var sanitizeUrlPath = config.get('xss-security-ebay:xss.UrlCheck');
        var sanitizeParameters = config.get('xss-security-ebay:xss.requestParameterCheck');

        var strictMode = config.get('xss-security-ebay:xss.strictMode');
        var fullExemptions = config.get('xss-security-ebay:xss.fullExemptions');
        var partialExemptions = config.get('xss-security-ebay:xss.partialExemptions');
        var partialExemptionPlainTextBody;

        var pageMeta = req.route && req.route.config;

        if (pageMeta) {
            if (pageMeta['xss.UrlCheck'] !== undefined) {
                sanitizeUrlPath =  pageMeta['xss.UrlCheck'];
            }

            if (pageMeta['xss.requestParameterCheck'] !== undefined) {
                sanitizeParameters = pageMeta['xss.requestParameterCheck'];
            }

            if (pageMeta['xss.strictMode'] !== undefined) {
                strictMode = pageMeta['xss.strictMode'];
            }

            if (pageMeta['xss.fullExemptions'] !== undefined) {
                fullExemptions = pageMeta['xss.fullExemptions'];
            }

            if (pageMeta['xss.partialExemptions'] !== undefined) {
                partialExemptions = pageMeta['xss.partialExemptions'];
            }

            if (pageMeta['xss.partialExemptionPlainTextBody'] !== undefined) {
                partialExemptionPlainTextBody = pageMeta['xss.partialExemptionPlainTextBody'];
            }
        }

        if (fullExemptions) {
            if (!fullExemptionsCache[fullExemptions]) {
                fullExemptionsCache[fullExemptions] = fullExemptions.split(',').reduce((acc, val) => {
                    val = val && val.trim && val.trim();
                    acc[val] = val;
                    return acc;
                }, {});
            }

            fullExemptions = fullExemptionsCache[fullExemptions];
        }

        if (partialExemptions) {
            if (!partialExemptionsCache[partialExemptions]) {
                partialExemptionsCache[partialExemptions] = partialExemptions.split(',').reduce((acc, val) => {
                    val = val && val.trim && val.trim();
                    acc[val] = val;
                    return acc;
                }, {});
            }

            partialExemptions = partialExemptionsCache[partialExemptions];
        }
        const disableBodyCheck = this.isBodyCheckDisabled(req, pageMeta);
        return {
            fullExemptions: fullExemptions,
            partialExemptions: partialExemptions,
            strictMode : strictMode === 'true' || strictMode === true,
            sanitizeUrlPath: sanitizeUrlPath === 'true' || sanitizeUrlPath === true,
            sanitizeParameters: sanitizeParameters === 'true' || sanitizeParameters === true,
            disableBodyCheck: disableBodyCheck,
            partialExemptionPlainTextBody: partialExemptionPlainTextBody === 'true' || partialExemptionPlainTextBody === true
        };
    }

    /**
     * 1. Should sanitize URL path and set req.__sanitizedPath
     * 2. When pageMeta.sanitizeUrlPath is true
     *      set req.path <= req.__sanitizedPath
     *      set req.__unsanitizedPath <= req.path
     */
    sanitizeUrlPath(req, pageMeta) {
        var path = req && req.path;

        if (!path) {
            return;
        }

        var sanitized = path.replace(urlVectors, '');

        if (path === sanitized) {
            return;
        }

        this.log(urlViolationMessage, path, sanitized);

        if (!pageMeta.sanitizeUrlPath) {
            return;
        }

        req.__unsanitizedPath = path;
        req.__sanitizedPath = sanitized;

        Object.defineProperty(req, 'path', {
            configurable: true,
            enumerable: true,
            get: function() { return sanitized; }
        });

        if (req.route && req.route.path) {
            req.route.path = req.path;
        }
    }

    /**
     * 1. Should sanitize req.quey, req.params and req.body while adhering to exemptions
     */

    sanitizeParameters(req, pageMeta) {
        var result, sanitized = false;

        result = this.sanitize(req.query, pageMeta);

        if (result.sanitized) {
            sanitized = sanitized || result.sanitized;
            req.__unsanitizedQuery = req.query;
            req.__sanitizedQuery = result.value;
            req.query = req.__sanitizedQuery;
        }

        result = this.sanitize(req.route && req.route.params, pageMeta);

        if (result.sanitized) {
            sanitized = sanitized || result.sanitized;
            req.__unsanitizedParams = req.route.params;
            req.__sanitizedParams = result.value;
            req.params = req.__sanitizedParams;

            if (req.route && req.route.params) {
                req.route.params = req.__sanitizedParams;
            }
        }
        if(!pageMeta.disableBodyCheck){
            result = this.sanitize(req.body, pageMeta, true);

            if (result.sanitized) {
                sanitized = sanitized || result.sanitized;
                req.__unsanitizedBody = req.body;
                req.__sanitizedBody = result.value;
                req.body = req.__sanitizedBody;
            }
        }
    }

    /**
     * Sanitizes parameter keys using the same rules as values but respecting exemptions
     */
    sanitizeKey(key, pageMeta) {
        // Check if this key is fully exempted (exact match or starts with exempted prefix)
        if (pageMeta.fullExemptions) {
            for (let exemptedKey in pageMeta.fullExemptions) {
                if (key === exemptedKey || key.startsWith(exemptedKey)) {
                    return {
                        original: key,
                        sanitized: key,
                        wasModified: false
                    };
                }
            }
        }

        let sanitized;
        
        // Apply sanitization rules similar to values
        if (isURL(key)) {
            // Keys that look like URLs (rare but possible)
            sanitized = key.replace(urlParameterVectors, '');
        } else {
            // Check if key starts with a partially exempted prefix
            let isPartiallyExempted = false;
            if (pageMeta.partialExemptions) {
                for (let exemptedKey in pageMeta.partialExemptions) {
                    if (key.startsWith(exemptedKey)) {
                        isPartiallyExempted = true;
                        break;
                    }
                }
            }
            
            if (!pageMeta.strictMode || isPartiallyExempted) {
                // Non-strict mode for keys OR key is in partial exemptions - preserve quotes
                sanitized = key.replace(stringParameterVectorsQuotesAllowed, '');
            } else {
                // Strict mode for keys (default) - remove XSS vectors including quotes
                sanitized = key.replace(stringParameterVectors, '');
            }
        }

        return {
            original: key,
            sanitized: sanitized,
            wasModified: key !== sanitized
        };
    }

    sanitize(obj, pageMeta, isBody) {
        var rval = { sanitized: false, value: obj };

        if (!obj) {
            return rval;
        }

        const partialExemptionPlainTextBody = pageMeta ? pageMeta.partialExemptionPlainTextBody : false;
        if (typeof obj === 'string' && partialExemptionPlainTextBody && isBody) {
            // Sanitize Non-Json Request Body
            rval.value = obj.replace(stringParameterVectorsQuotesAllowed, ' ');
            rval.sanitized = obj !== rval.value;
            if (rval.sanitized) {
                this.log(paramViolationMessage, obj, rval, undefined);
            }
            return rval;
        }

        rval.value = Object.keys(obj).reduce((acc, key) => {
            let finalKey = key;
            
            // NEW: Sanitize key if enabled
            const sanitizeParameterKeys = this.config.get(`security-ebay:sanitizeParameterKeys`);
            if (sanitizeParameterKeys) {
                const keyResult = this.sanitizeKey(key, pageMeta);
                if (keyResult.wasModified) {
                    this.log(keyViolationMessage, keyResult.original, keyResult.sanitized, key);
                    finalKey = keyResult.sanitized;
                    rval.sanitized = true;
                }
            }
            
            // Existing value sanitization (unchanged)
            acc[finalKey] = this.rsanitize(key, obj[key], pageMeta);
            rval.sanitized = rval.sanitized || pageMeta.sanitized;
            pageMeta.sanitized = false;
            return acc;
        },{});

        delete pageMeta.sanitized;
        return rval;
    }

    rsanitize(key, val, pageMeta) {
        var rval;

        if (pageMeta.fullExemptions[key] !== undefined) {
            return val;
        }

        if (typeof val === 'string' || val instanceof String) {
            if (isURL(val)) {
                rval = val.replace(urlParameterVectors, '');
            } else if (!pageMeta.strictMode || pageMeta.partialExemptions[key] !== undefined) {
                rval = val.replace(stringParameterVectorsQuotesAllowed, ' ');
            } else {
                rval = val.replace(stringParameterVectors, ' ');
            }

            if (val === rval) {
                return val;
            }

            this.log(paramViolationMessage, val, rval, key);

            if (!pageMeta.sanitizeParameters) {
                return val;
            }

            pageMeta.sanitized = true;
            return rval;
        }

        if (val instanceof Array) {
            return val.map(e => {
                return this.rsanitize(key, e, pageMeta);
            });
        }

        if (val instanceof Object) {
            return Object.keys(val).reduce((acc, k) => {
                acc[k] = this.rsanitize(key + '.' + k, val[k], pageMeta);
                return acc;
            }, {});
        }

        return val;
    }
}

function createLogger(res) {
    const tasks = [];
    const _end = res.end;
    // delay logging till the end to let cal middleware to create a context
    res.end = function interceptEndBySecurityEbay() {
        // log events
        tasks.forEach(task => {
            setImmediate(task);
        });
        _end.apply(res, arguments);
    };

    return function log(message, unsanitized, sanitized, key) {
        tasks.push(() => {
            var event;

            if (key) {
                event = cal.createEvent('warning', 'XSS-ParameterViolationDetected', 'log');
                event.addData('msg', util.format('XSSParameterCheck - ' + message, key, unsanitized, sanitized));
            }
            else {
                event = cal.createEvent('XSSUrlCheck', 'UrlViolationDetected', '0', util.format(message, unsanitized, sanitized));
            }

            event.complete();
        });
    };
}

function isURL(parameter) {
    return HTTP.test(parameter);
}

var urlViolationMessage = 'XSS violation detected: request url check; original value [%s]; sanitized value [%s]';
var paramViolationMessage = 'XSS violation detected: parameter name [%s]; original value [%s]; sanitized value [%s]';
var keyViolationMessage = 'XSS violation detected: parameter key [%s]; original value [%s]; sanitized value [%s]';

var HTTP = new RegExp([
    'http://',
    'https://',
    'http%3A//',
    'https%3A//'
].reduce(function(acc, val) {
    return acc + '|^' + val;
}).substr(2), 'i');

var urlVectors =  new RegExp([
    '<',
    '>',
    '\'',
    '"',
    '%3C',
    '%3E',
    '%27',
    '%22',
    'data:',
    'data%3A'
].reduce(function(acc, val) {
    return acc  + '|' + val;
}, '').substr(1), 'ig');

var urlParameterVectors = new RegExp([
    '<script',
    '%3Cscript',
    'Q3cscript',
    '<applet',
    '<object',
    '<iframe',
    '<embed',
    '<!\\[CDATA\\[',
    '<\\[\\[',
    '</script>',
    'script%3E',
    'scriptQ3e',
    '</applet>',
    '</object>',
    '</iframe>',
    '</embed>',
    '\\]\\]>',
    '<',
    '%3C',
    '>',
    '%3E',
    '\\[',
    '%5B',
    '\\]',
    '%5D',
    'javascript%3A',
    'data%3A'
].reduce(function (acc, val) {
     return acc + '|' + val;
}, '').substr(1), 'ig');

var stringParameterVectorsQuotesAllowed = [
    '<script',
    '<applet',
    '<object',
    '<iframe',
    '<embed',
    '<!\\[CDATA\\[',
    '<\\[\\[',
    '</script>',
    '</applet>',
    '</object>',
    '</iframe>',
    '</embed>',
    '\\]\\]>',
    '<',
    '>',
    '//',
    'javascript:', // jshint ignore:line
    'Javascrip%09t',
    'data:'
].reduce(function (acc, val) {
     return acc + '|' + val;
}, '').substr(1);

var  stringParameterVectors = new RegExp([
    '\'',
    '"'
].reduce(function (acc, val) {
     return acc + '|' + val;
}, stringParameterVectorsQuotesAllowed), 'ig');

stringParameterVectorsQuotesAllowed = new RegExp(stringParameterVectorsQuotesAllowed, 'ig');
