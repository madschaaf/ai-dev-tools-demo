'use strict';

var fs = require('fs');
var path = require('path');
var _ = require('underscore');
var async = require('async');
var assert = require('assert');
var mailer = require('./mailer');
var modConfig = require('@ebay/module-config-inc');
var getPm2Id = require('@ebay/instance-detect-ebay').getInstanceId;
var shell = require('shelljs');

var DEFAULTS = {
    restarts: 0,
    reason: 'unknown',
    emailSent: false
};

module.exports.instance = undefined; // for testing purposes

function Restart() {
    this._restartLog = readRestartLog();
    this._restartLog = _.defaults(this._restartLog, DEFAULTS);
    this._emailOptions = {};
    this._sendEmail = false;
}

Restart.prototype.getRestarts = function getRestarts() {
    return this._restartLog.restarts;
};

Restart.prototype.setRestarts = function setRestarts(restartCounter) {
    this._restartLog.restarts = restartCounter;
    return this;
};

Restart.prototype.incrementRestarts = function incrementRestarts() {
    this._restartLog.restarts = this._restartLog.restarts + 1;
    return this;
};

Restart.prototype.getReason = function getReason() {
    return this._restartLog.reason;
};

Restart.prototype.setReason = function setReason(reason) {
    this._restartLog.reason = reason;
    return this;
};

Restart.prototype.sendEmail = function sendEmail(emailOptions) {
    this._emailOptions = emailOptions || {};
    this._restartLog.reason = this._emailOptions.text ? this._emailOptions.text : this._restartLog.reason;
    this._sendEmail = true;
    return this;
};

Restart.prototype.getEmailStatus = function getEmailStatus() {
    return this._restartLog.emailSent;
};

Restart.prototype.setEmailStatus = function setEmailStatus(status) {
    this._restartLog.emailSent = status;
    return this;
};

Restart.prototype.reset = function reset() {
    this._restartLog.emailSent = false;
    this._restartLog.reason = 'unknown';
    this._sendEmail = false;
    return this;
};

Restart.prototype.execute = function execute(callback) {
    assert.ok(callback, 'callback is required');
    var _parent = this;

    if(this._sendEmail && (this._restartLog.reason === 'unknown' || this._restartLog.reason === 'No information provided')) {
        this._restartLog.reason = readLogTail();
    }

    this._emailOptions.text = this._restartLog.reason;

    async.waterfall([
        function(cb) {
            modConfig(module, function(err, config) {
                cb(null, config);
            });
        },
        //Send email
        function(config, cb) {
            var maxEmails = config.get('errors-ebay:email:maxCount') || 25;
            var restartCount = _parent.getRestarts();
            var subjectTail =  restartCount === maxEmails ? ' Exceeded report limit of ' + maxEmails + '. No more report emails will be sent' : ' for time ' + restartCount;
            _parent._emailOptions.subjectTail = subjectTail;
            //DO NOT Send email if restarts is > 25
            if(_parent._sendEmail && _parent.getRestarts()<=maxEmails) {
                mailer.sendEmail(_parent._emailOptions, function(err, info){
                    var status = (err ? false : true);
                    _parent.setEmailStatus(status);
                    cb(null, err, info);
                });
            } else {
                _parent.setEmailStatus(false);
                cb(null, null, null);
            }
        },
        //Sync data to file system
        function(emailError, emailInfo, cb) {
            writeRestartLog(_parent._restartLog);
            _parent._sendEmail = false;
            cb(emailError, emailInfo);
        }
    ], callback);

};

function readRestartLog() {
    var pm2id = getPm2Id();

    const logsFolder = process.env.LOG_HOME || './logs';
    var restartsFile = path.resolve(logsFolder + '/restarts_' + pm2id);
    var restartErrData = {};
    if (fs.existsSync(restartsFile)) {
        try {
            restartErrData = fs.readFileSync(restartsFile, 'utf8');
            restartErrData = JSON.parse(restartErrData);
        }catch(e){
            //noop
            console.log('Error parsing JSON data: ', restartErrData);
            restartErrData = {};
        }
    }
    return restartErrData;
}

function writeRestartLog(thingsToLog) {
    var pm2id = getPm2Id();

    try {
        const logsFolder = process.env.LOG_HOME || './logs';
        // If folder not exists, create
        if(!fs.existsSync(logsFolder)){
            fs.mkdirSync(logsFolder,{ recursive: true });
        }
        var restartsFile = path.resolve(logsFolder + '/restarts_' + pm2id);
        fs.writeFileSync(restartsFile, JSON.stringify(thingsToLog));
        return true;
    }catch(e){
        //noop
        console.log('Write failed to restarts file');
        return false;
    }
}

function readLogTail() {

    var errFilePath = getLogPath('err');
    var outFilePath = getLogPath('out');

    var loginfo = 'ErrorLog File Tail: \n===================\n\n';
    loginfo += shell.exec('/usr/bin/tail -50 ' + errFilePath, {silent: true}).output;
    loginfo += '\n\n OutLog File Tail: \n==================\n\n';
    loginfo += shell.exec('/usr/bin/tail -50 ' + outFilePath, {silent: true}).output;
    return loginfo;
}

function getLogPath(fileType) {
    var logfile = path.resolve(process.cwd(), 'logs', fileType +'.log');
    if (!fs.existsSync(logfile)) {
        logfile = path.resolve(process.cwd(), 'logs', fileType+'-' + (getPm2Id()) + '.log');
    }
    return logfile;
}

module.exports.log = function getRestartLog() {
    // only ever need one instance of the class to prevent inconsistencies
    if (!module.exports.instance) {
        module.exports.instance = new Restart();
    }
    return module.exports.instance;
};
