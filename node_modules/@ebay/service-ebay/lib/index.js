'use strict';
// Start Patching console to log to startup log file
require('@ebay/bootstrap-ebay/startuplog')();
const Path = require('path');
const startTime = Date.now();

// ========================================================================//
// ====== this code should be the first to execute before any require =====//
// this function should not be replaced with 3rd party, as we do not want to load anything before this.
function tryRequire(name) {
    try {
        return require(name);
    }
    catch (err) {
        // skip
    }
}

// validation should be disabled for the first phase 2023-09> then we will validate else we will not validate
// Load the bootstrap function from the bootstrap-ebay module
const bootstrapOptions = {
    consumerBaseDir: Path.resolve(__dirname, '..'),
    validate: false
};
const bootstrap = tryRequire('@ebay/bootstrap-ebay/lib/index').bootstrap;

const bootstrapModules = bootstrap(bootstrapOptions);
// === the code above should be the first to execute before any require ===//
// ========================================================================//

// this should be the first to load
require('request-local');
require('./body-parser-patch');

const Assert = require('assert');
const Fs = require('fs');
const Url = require('url');
const express = require('express');
const dnscache = require('dnscache');
const configure = require('./configure');
const caller = require('./callermodule');
const vi = require('@ebay/validate-internals-ebay');
const openapi = require('@ebay/openapi-ebay');
const refResolver = openapi.createModuleResolver(require('@ebay/openapi-ref-resolver-ebay'));
const Yaml = require('js-yaml');
const events = require('./events');
const kernelServices = require('@ebay/kernel-services-ebay');
const commonTypes = require('@ebay/common-types-ebay/money');
commonTypes.setMoneyExchange({
    getExchangeRate: (when, from, to) =>
        kernelServices.getExchangeRate(from.value.code, to.value.code, when)
});

const { platformMetrics } = require('@ebay/prometheus-ebay');

// hook certs for non-service-client https calls
const https = require('https');

if (process.env.ENABLE_STATIC_CA_CERTS === 'true') {
    // No Op, Do not set any certs
}
else {
    const ebayRootCerts = require('@ebay/service-instruments-ebay/ebay-root-certs');
    https.globalAgent.options.ca = ebayRootCerts;
}

const debug = require('debug')('@ebay/service-ebay/server');

// prevent any exposure of internals via JSON
require('domain').Domain.prototype.toJSON = () => undefined;

module.exports = async function serviceEbay(options = {}) {
    const basedir = options.basedir = options.basedir || Path.dirname(caller().location);

    const configs = await configure(options);
    if (!configs || configs.length === 0) {
        throw new Error('Service configuration not found or bad, make sure your options.onconfig returns them');
    }

    const dnsOptions = options.dnscache || {};
    dnscache({
        enable: dnsOptions.enable !== undefined ? dnsOptions.enable : true,
        ttl: process.env.NETWORK_ADDRESS_TTL_VALUE || dnsOptions.ttl || 300,
        cachesize: dnsOptions.cachesize || 1000
    });

    const app = express();
    // hook life cycle event handlers
    events(app);
    // hook VI
    vi.middleware(app);

    const expressConfig = configs[0].get('express');
    Object.keys(expressConfig).forEach(key =>
        app.set(key, expressConfig[key]));

    // hook our service instances
    const serviceApps = await Promise.all(configs.map(config =>
        createServiceApp(config, Path.resolve(basedir, 'config'))
    ));
    serviceApps.forEach(sapp => app.use(sapp));

    Object.defineProperty(app, 'configs', {
        enumerable: true,
        value: configs
    });

    Object.defineProperty(app, 'services', {
        enumerable: true,
        value: serviceApps
    });

    // Set platform metrics app_startup_time_ms
    generateAppStartupGauge();

    // signal validate internals and the rest that we are ready
    // this is not for consumption by external actors as when app instance is returned
    // it can be considered as started
    app.emit('start');

    return app;
};

module.exports.bootstrapModules = bootstrapModules;

/*
"api": {
    "schema": "require:./config/swagger.json",
    "handlers": "path:handlers",
    "security-providers": "path:security-providers"
}
*/
async function createServiceApp(config, basedir) {
    const api = config.get('api');
    const middleware = config.get('middleware');

    // order middleware by priority
    // find the place of controller
    // and divide middleware before or after the controller
    const mwOrderedList = Object.keys(middleware)
        .map(name => {
            const cfg = middleware[name];
            return {
                name,
                config: cfg
            };
        })
        .filter(handler => handler.config.enabled !== undefined &&
            handler.config.enabled)
        .sort((a, b) => {
            assertHandlerSpec(a);
            assertHandlerSpec(b);
            return a.config.priority - b.config.priority;
        });

    const pipes = {};
    for (const mw of mwOrderedList) {
        // searching controller placeholder to divide pipe into pre and post middleware
        if (mw.name === 'controller') {
            pipes.controllerPoint = mw;
        }
        else {
            const phase = mw.config.phase || 'route';
            const fn = await resolve(mw.config.module);
            pipes[phase] = pipes[phase] || [];
            pipes[phase].push({
                name: mw.name,
                fn,
                spec: mw.config
            });
        }
    }

    const servicePipeline = express();

    debug(`\npipe:${config.get('name')}\n--------------------`);
    if (pipes.preRoute) {
        debug('Pre route pipeline:\n');
        pipes.preRoute.forEach(handler => {
            debug(handler.name);

            if (handler.spec.route) {
                servicePipeline.use(handler.spec.route, handler.fn);
            }
            else {
                servicePipeline.use(handler.fn);
            }
        });
        debug('--------------------\n\n');
    }

    // this middleware goes into preMiddleware for openapi-ebay configure
    if (pipes.route) {
        debug('Route pipeline:\n');
        pipes.route = pipes.route.map(handler => {
            debug(handler.name);
            return handler.fn;
        });
        debug('--------------------\n\n');
    }

    if (pipes.controller) {
        debug('Controller pipeline:\n');
        pipes.controller = pipes.controller.map(handler => {
            debug(handler.name);
            return handler.fn;
        });
        debug('--------------------\n\n');
    }

    const schema = api.schema = loadSchema(api.schema);
    if (!schema) {
        throw new Error(`Cannot find schema at this location ${api.schema}`);
    }

    const openApiConfig = {
        schema,
        basedir,
        handlers: api.handlers,
        securityProviders: api['security-providers'],
        preControllerMiddleware: pipes.route,
        controllerMiddleware: pipes.controller,
        postControllerMiddleware: [
            // block any fallback to the next route
            (req, res, next) => {
                const err = new Error(`No route found or called next without an error, name:${req.route.name ||
                    req.route.pageName}`);
                err.domain = 'app';
                err.statusCode = 404;
                next(err);
            }
        ],
        refResolver
    };

    if (config.get('runtime-context') !== undefined) {
        const createRuntime = require('./runtime');
        openApiConfig.handlerRuntimeFactory = await createRuntime({
            config
        });
    }

    const routesPipeline = await openapi.configure(openApiConfig);

    servicePipeline.use(routesPipeline);

    if (pipes.postRoute) {
        debug('Post route pipeline:\n');
        pipes.postRoute.forEach(handler => {
            debug(handler.name);
            if (handler.spec.route) {
                servicePipeline.use(handler.spec.route, handler.fn);
            }
            else {
                servicePipeline.use(handler.fn);
            }
        });
        debug('--------------------\n\n');
    }

    // we use this container to map it to service app at base path
    const container = express();

    const basePath = getBasePath(api.schema, config.get('name'));
    console.info(`Hooking service at ${basePath}`);
    container.use(basePath, servicePipeline);

    Object.defineProperty(container, 'api', {
        value: routesPipeline.api
    });

    return container;
}

function getBasePath(schema, serviceName) {
    try {
        return Url.parse(schema.servers[0].url).pathname;
    }
    catch (err) {
        throw new Error(`Cannot find servers definition service:'${serviceName
        }' openapi contract ${schema.info && JSON.stringify(schema.info) || 'missing contract info'}`);
    }
}

function tryResolveSchema(modulePath, schemaFile) {
    const schemaPath = Path.join(modulePath, schemaFile);
    if (Fs.existsSync(schemaPath)) {
        return schemaPath;
    }
    try {
        return Path.join(require.resolve(Path.join(modulePath, 'package.json')), '..', schemaFile);
    }
    catch (err) {
        // skip
    }
}

function findSchema(apiPath) {
    const basePath = apiPath.split('/');
    const schemaFile = [];
    while (basePath.length > 0) {
        schemaFile.unshift(basePath.pop());
        const schemaPath = tryResolveSchema(basePath.join('/'), schemaFile.join('/'));
        if (schemaPath) {
            return schemaPath;
        }
    }
}

function loadSchema(apiPath) {
    const schemaPath = findSchema(apiPath);
    if (!schemaPath) {
        throw new Error(`Failed to find openapi schema at this path:${apiPath}`);
    }

    if (/\.yaml$/.test(schemaPath)) {
        const yamlSchema = Yaml.load(Fs.readFileSync(schemaPath).toString());
        return yamlSchema;
    }
    return require(apiPath);
}

function assertHandlerSpec(handler) {
    Assert.ok(handler.config !== undefined && handler.config.priority !== undefined,
        `middleware handler "${handler.name}" does not have priority assigned`);
}

function generateAppStartupGauge() {
    const appStartUpGauge = platformMetrics?.registry?._metrics?.app_startup_time_ms;
    if (appStartUpGauge) {
        const metricValue = Date.now() - startTime;
        appStartUpGauge.set(metricValue);
    }
    else {
        // eslint-disable-next-line no-console
        console.log('app_startup_time_ms gauge not found in platformMetrics registry');
    }
}

function resolve(config) {
    if (typeof config === 'function') {
        return config();
    }

    if (typeof config === 'string') {
        return resolve({ name: config });
    }

    if (!config || !config.name) {
        throw new TypeError('Module not defined.');
    }

    debug('loading module', config.name);

    // If modulePath was not resolved lookup with config.name for meaningful error message.
    const mod = require(config.name);

    // First, look for a factory method
    let factory = mod[config.method];
    if (typeof factory !== 'function') {
        // Then, check if the module itself is a factory
        factory = mod;
        if (typeof factory !== 'function') {
            throw new Error(`Unable to locate middleware in ${config.name}`);
        }
    }

    const args = Array.isArray(config.arguments) ? config.arguments : [];
    return factory(...args);
}
