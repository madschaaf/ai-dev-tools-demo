#!/usr/bin/env node

'use strict';

module.exports.generate = function generateDescriptor(schema, options) {
    const serviceName = options['app-name'];
    const restricted = options.restricted || true;
    const internal = options.internal || true;

    const version = schema.info.version;
    const majorVersion = version.split('.').shift();
    const id = `${serviceName}:v${majorVersion}`;
    const basePath = schema.basePath;
    // find cosContext if any
    // there are two forms, with cosContext (/cosContext/appName/version/resource)
    // and without cosContext (/appName/version/resource)
    let cosContext;
    const match = basePath.match(/(\/\w+)(\/\w+)\/v\d+/);
    if (match) {
        cosContext = match[1];
    }

    const sdd = keepClean({
        'name': serviceName,
        'version': version,
        'description': schema.info.description || `Default description for ${serviceName}`,
        '@context': {
            'api': `service:${serviceName}-${version}`
        },
        'models': {
        }
    });

    sdd.models[id] = {
        'kind': 'eBayDescriptor#restDescription',
        'descriptorVersion': 'v1',
        'id': id,
        'name': serviceName,
        'version': '1',
        'title': 'PLEASE UPDATE THIS',
        'description': 'PLEASE UPDATE THIS',
        'icons': { },
        'labels': [], // TODO: add labels
        'documentationLink': 'PLEASE UPDATE THIS',
        'protocol': 'rest',
        'cosContext': cosContext,
        'servicePath': schema.basePath || '/',
        'batchPath': 'batch',
        'internal': internal,
        'restricted': restricted,
        'headers': {}, // TODO: do we need this for request?, response is supported
        'errors': {}, // TODO: implement errors if needed
        'auth': getScopeDefinitions(schema.securityDefinitions),
        'features': [
            // TODO: do we need this???
        ],
        'schemas': getDefinitions(schema.definitions),
        'methods': {
            // TODO: can generate this base on methods tag
        },
        'parameters': {

        },
        'resources': createObject({}, serviceName, {
            'methods': Object.keys(schema.paths).reduce((memo, path) => {
                const httpMethods = schema.paths[path];

                return Object.keys(httpMethods).reduce((memo, httpMethodName) => {
                    const httpMethod = httpMethods[httpMethodName];
                    const operationId = httpMethod.operationId;

                    memo[operationId] = {
                        'path': path,
                        'httpMethod': httpMethodName,
                        'parameters': getParameters(httpMethod.parameters.filter(parameter =>
                            parameter.in !== 'body'
                        )),
                        'response': getResponse(httpMethod.responses['200']),
                        'request': getRequest((httpMethod.parameters || []).filter(parameter =>
                            parameter.in === 'body'
                        )),
                        'scopes': getScopes(httpMethod.security),
                        'internal': true, // TODO: use one from swagger x-internal
                        'userCreds': false,
                        'parameterOrder': []
                    };

                    return memo;
                }, memo);
            }, {})
        }),
        'documentationProcess': 'swagger 2.0'
    };

    return sdd;
};

function getDefinitions(definitions) {
    return Object.keys(definitions).reduce((memo, name) => {
        const definition = definitions[name];
        const key = `api:${name}`;
        const typeDef = defineType(definition);
        typeDef.id = key;
        memo[key] = typeDef;
        return memo;
    }, {});
}

function getRequest(params) {
    const request = params && params[0] || undefined;
    return request && request.schema ? defineType(request.schema) : {};
}

function getResponse(response) {
    return response && response.schema ? defineType(response.schema) : {};
}

function formatType(type, source = 'api') {
    return type.replace(/#\/definitions\//, `${source}:`);
}

function defineType(spec) {
    if (!spec) {
        return;
    }

    let definition;
    if (spec.$ref) {
        definition = {
            type: 'object',
            '$ref': formatType(spec.$ref)
        };
    }
    else {
        definition = {
            type: spec.type
        };
    }

    definition.description = spec.description;
    definition.default = spec.default;
    definition.required = spec.required;
    definition.format = spec.format;
    definition.pattern = spec.pattern;
    definition.minimum = spec.minimum;
    definition.maximum = spec.maximum;
    definition.enum = spec.enum;
    // definition.enumDescriptions  TODO: not sure what this means
    // definition.repeated  TODO: not sure what this means
    definition.location = spec.in;
    definition.properties = defineType(spec.properties);
    definition.additionalProperties = defineType(spec.additionalProperties);
    definition.items = defineType(spec.items);
    // definition.annotations - No annotations exists in nodejs
    return keepClean(definition);
}

function getParameters(parameters) {
    return (parameters || []).reduce((memo, parameterDef) => {
        memo[parameterDef.name] = defineType(parameterDef);
        return memo;
    }, {});
}

function getScopeDefinitions(securityDefinitions) {
    const cosAuth = securityDefinitions && securityDefinitions.oauth2;
    if (cosAuth) {
        const def = {};
        const scopes = cosAuth.scopes;
        return createObject(def, cosAuth.type, {
            scopes: Object.keys(scopes).reduce((memo, name) => {
                memo[`https://api.ebay.com/oauth/scope/${name}`] = scopes[name];
                return memo;
            }, {})
        });
    }
}

function getScopes(security) {
    const scopes = security && security[0] && security[0].oauth2;
    if (scopes) {
        return scopes.map(scope =>
            `https://api.ebay.com/oauth/scope/${scope}`
        );
    }
    return [];
}

function createObject(parent, name, value) {
    parent[name] = value;
    return parent;
}

function keepClean(obj) {
    return Object.keys(obj).reduce((memo, key) => {
        const value = obj[key];
        if (value !== undefined && value !== null) {
            memo[key] = value;
        }
        return memo;
    }, {});
}
