'use strict';

const TokenValidator = require('./lib/TokenValidator');
const modConfig = require('@ebay/module-config-inc');
const utilsEbay = require('@ebay/utils-ebay');
const URL = require('url');
const env = require('@ebay/environment-ebay');
const logger = require('./lib/logger');
const appContext = require('@ebay/app-context-ebay');

const modes = {
    'disabled': noop,
    'enforcement': validateToken,
    'monitoring': validateToken
};

module.exports = function tfMiddlware() {
    return function validateTFHeader(req, res, next) {
        modConfig(module, (_, cfg) => {
            const isEnabled = cfg && cfg.get('trust-fabric-ebay:interceptHeaders:enabled') || false;
            const mode = cfg && cfg.get('trust-fabric-ebay:interceptHeaders:mode') || 'disabled';

            const isTfIpCheckEnabled = cfg ? !cfg.get('trust-fabric-ebay:trf-ip-check:disabled') : true;
            const isTfIpFallbackAllowed = cfg ? cfg.get('trust-fabric-ebay:trf-ip-check:fallback') : true;
            const config = { isTfIpCheckEnabled, isTfIpFallbackAllowed };
            if (!isEnabled) {
                return next();
            }

            return modes[mode.toLowerCase()](req, res, next, mode, config);
        });
    };
};

function noop(req, res, next) {
    return next();
}

function validateToken(req, res, next, mode, config) {
    const tfHeader = req.headers['x-ebay-tf-authorization'];
    const tfToken = /^bearer /i.test(tfHeader) ? tfHeader.substring('bearer '.length) : undefined;
    const failOnError = (mode.toLowerCase() === 'enforcement');
    if (!tfToken) {
        const msg = 'TrustFabric Authorization header is missing';
        return handleFailResponse(req, res, msg, failOnError, next);
    }
    new TokenValidator(req, config)
        .validate(tfToken, (err, decodedToken) => {
            if (err) {
                return handleFailResponse(req, res, err.message, failOnError, next);
            }
            req.ebay.trustfabric = createContext(decodedToken);
            next();

            // Audit log success only for monitoring mode
            if (mode.toLowerCase() === 'monitoring') {
                auditLog(req, res, 'Token validated successfully', true);
            }
        });
}

function createContext(decodedToken) {
    const payload = decodedToken.payload;
    const subject = payload.sub;
    const sub = subject.split(',').reduce((accum, elem) => {
        const data = elem.split('=');
        accum[data[0].toLowerCase()] = data[1];
        return accum;
    }, {});

    const ctx = {
        getName() {
            return sub.o || subject;
        },

        getRealm() {
            return payload.realm || 'dev';
        },

        getClaims() {
            return payload;
        }
    };

    return ctx;
}

function handleFailResponse(req, res, msg, failOnError, next) {
    if (failOnError) {
        // for services and FE it should use default handler
        next(Object.assign(new Error(msg), {
            statusCode: 401
        }));
    } else {
        next();
    }
    auditLog(req, res, msg, false);
}

function auditLog(req, res, msg, authStatus) {
    if (env.isDev() || env.isTest() || !process.env.BASE_DIR) {
        // no op in DEV/Test
        return;
    }
    const ctx = req.ebay && req.ebay.trustfabric;
    const data = {};
    data.eventTime = new Date().toISOString();
    data.serverName = appContext.appName;
    data.method = req.method;
    data.realm = ctx && ctx.getRealm() || 'null';
    data.userAgent = req.headers['user-agent'] || 'null';
    data.callerName = ctx && ctx.getName() || 'null';
    data.callerIp = utilsEbay.getRemoteAddrFromTrustedHeader(req);
    data.remoteIp = utilsEbay.getClientIP(req);
    data.url = URL.parse(req.url).pathname;
    data.authStatus = authStatus;
    data.status = res.statusCode;
    data.message = msg?.message || msg;
    logger.log(data);
}

module.exports._validateToken = validateToken;
module.exports._createContext = createContext;
module.exports._handleFailResponse = handleFailResponse;
module.exports._auditLog = auditLog;
module.exports._logger = logger;
module.exports.modes = modes;
