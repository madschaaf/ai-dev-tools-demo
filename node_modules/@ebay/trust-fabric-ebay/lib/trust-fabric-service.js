'use strict';
const provider = require('@ebay/service-client-ebay');
const { getClientId, getTfVersion } = require('./utils');
const qs = require('qs');
const logger = require('@ebay/logging-inc').logger('trust-fabric-ebay/trust-fabric-service');
let clientId;

function invokeService(grantType, prevToken, scopes, version, callback) {
    const client = provider.context({}).getClient('trust-fabric-service');
    const VERSION = version || getTfVersion();
    logger.info(`Using TrustFabric service version: ${VERSION}`);
    clientId = clientId || getClientId(VERSION);

    if (!clientId) {
        return callback(new Error('Failed to generate clientId .metadata.json doesnt exists or corrupted'), null);
    }

    const body = {
        grant_type: grantType,
        client_id: clientId
    };

    if (grantType === 'authorization_code') {
        body.code = prevToken;
    } else {
        body.refresh_token = prevToken;
    }

    if (scopes) {
        body.scope = scopes;
    }

    client.post({
        body: qs.stringify(body),
        basepath: `/${VERSION}/token`
    })
        .end((err, response) => {
            if (err) {
                return callback(new Error(`Failed to fetch token from TrustFabric service, ${err.stack}`), null);
            }
            callback(null, response.body);
        });
}

function getTokenUsingGrant(options, callback) {
    const { token, scopes, version } = options;
    invokeService('authorization_code', token, scopes, version, (err, res) => {
        callback(err, res);
    });
}

function getTokenUsingRefreshToken(options, callback) {
    const { token, scopes, version } = options;
    invokeService('refresh_token', token, scopes, version, (err, res) => {
        callback(err, res);
    });
}

function reset() {
    clientId = undefined;
}

module.exports = {
    getTokenUsingGrant: getTokenUsingGrant,
    getTokenUsingRefreshToken: getTokenUsingRefreshToken,
    reset: reset
};
