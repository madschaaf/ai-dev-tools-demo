'use strict';
const appContext = require('@ebay/app-context-ebay');
const provider = require('@ebay/service-client-ebay');
const configbean = require('@ebay/config-bean-ebay');
const { promisify } = require('util');
const modConfig = require('@ebay/module-config-inc');
const loadConfig = promisify(modConfig);
const logger = require('@ebay/logging-inc').logger('trust-fabric-ebay:TFHeader');

const DEFAULT_INTERVAL = 6 * 60 * 60; // 6hrs refresh

class TFHeader {
    constructor() {
        this.isRunning = false;
        this.startTimer();
        this.timer = undefined;
        this.logger = logger;
        this.cfg = undefined;
        this.forceRefresh = false;
    }

    startTimer(refreshInterval) {
        let tfConfig;
        // eslint-disable-next-line
        const fetchAndUpdate = async () => {
            // clean up context to avoid memory leak
            while (process.domain) {
                process.domain.exit();
            }
            try {
                this.cfg = await loadConfig(module);
                this.cfg.on('change', () => {
                    if (!this.forceRefresh && this.cfg.get('trust-fabric-ebay:forceRefresh') === true) {
                        this.clearTimer();
                        this.startTimer();
                        this.forceRefresh = true;
                    } else {
                        this.forceRefresh = this.cfg.get('trust-fabric-ebay:forceRefresh');
                    }
                });

                tfConfig = this.cfg.get('trust-fabric-ebay:propagateHeaders');
                const data = await this.fetchWhitelistConfig();
                this.persistToBeans(data);
            } catch (err) {
                logger.error('Failed to fetch trust-fabric config list', err);
            } finally {
                const interval = refreshInterval || (tfConfig && tfConfig.refreshInterval) || DEFAULT_INTERVAL;
                this.timer = setTimeout(fetchAndUpdate, interval * 1000).unref();
            }
        };

        if (!this.isRunning) {
            this.isRunning = true;
            setImmediate(fetchAndUpdate);
        }
    }

    clearTimer() {
        this.timer && clearTimeout(this.timer);
        this.timer = undefined;
        this.isRunning = false;
    }

    fetchWhitelistConfig() {
        return new Promise((resolve, reject) => {
            const client = provider.context({}).getClient('trust-fabric-whitelist');
            const appName = appContext.appName;

            client.get()
                .path(`${appName}/trustfabric-config`)
                .end((err, res) => {
                    if (err || !res || !res.body) {
                        return reject(err || new Error('Invalid Body'));
                    }

                    return resolve(res.body);
                });
        });
    }

    persistToBeans(config) {
        const bean = configbean.getBeanById('nodejs.config.trust-fabric-ebay.common');
        if (bean && config) {
            bean.setPersist('trust-fabric-ebay:propagateHeaders:enabled', config.trfTokenHeaderEnabled);
            bean.setPersist('trust-fabric-ebay:interceptHeaders:mode', config.trfTokenValidationMode);
            bean.setPersist('trust-fabric-ebay:trf-ip-check:disabled', config.trfTokenLegacyIPValidationMode);
            bean.setPersist('trust-fabric-ebay:trf-ip-check:fallback', config.trfTokenDegradedIPValidationMode);
        }
    }

    isAppWiredOn(callback) {
        modConfig(module, (_, cfg) => {
            callback(cfg && cfg.get('trust-fabric-ebay:propagateHeaders:enabled'));
        });
    }
}

module.exports = new TFHeader();