'use strict';

const jwt = require('jsonwebtoken');
const fs = require('fs');
const path = require('path');
const appContext = require('@ebay/app-context-ebay');
const env = require('@ebay/environment-ebay');
const logger = require('@ebay/logging-inc').logger('trust-fabric-ebay/TokenGenerator');
const trustFabricSvc = require('./trust-fabric-service');
const { getGrantFromFile, isTokenExpired, getTfVersion,
    getJwkFromKeychain, signWithKeychainPrivateKey, getDPoPGrantFromFile } = require('./utils');
const audiences = ['fidelius', 'patronus'];
const cert = fs.readFileSync(path.join(__dirname, '..', 'resources/private.pem'));
const modConfig = require('@ebay/module-config-inc');
const cmpaasService = require('./cmpaas-service');
const crypto = require('crypto');
const RaptorCache = require('raptor-cache');
const SECRET_SIGN_PERIOD = 8639999990;
const algorithm = 'aes-192-cbc';
const iv = Buffer.alloc(16, 0);
const colo = require('@ebay/colo-detect-ebay');
const ip = require('ip').address();
const tfHeader = require('./tfHeader');
const assert = require('assert');

let tfTokenGenInstances = 0;
class TokenGenerator {
    constructor(options) {
        assert.ok(tfTokenGenInstances < 5, 'TokenGenerator instances exceeded the limit');
        tfTokenGenInstances++;
        // options version is used for testing purposes to override the default TF version
        this.version = options?.version || getTfVersion();
        this.createDiskCache();
        this.salt = `${colo.getHostName()}-${this.version}`;
        this.MAX_REFRESH_RETRIES = 1440; // 12 hr retry with 30 sec interval
        this.failedRefreshCount = 0;
        this.tfHeader = tfHeader;
        this.devTokenExpiry = 1 * 24 * 60 * 60 * 1000;
        this.devSubject = null;
        // DPoP is valid only for V4 in Development environment
        this.useDPoP = this.version === 'v4' && env.isDev();
        if (options?.scopes) {
            assert.ok(Array.isArray(options.scopes), 'scopes should be an array');
            this.scopes = options.scopes.join(' ');
        }
        this.htm = options?.htm;
        this.htu = options?.htu;
    }

    overrideDevSubject(subject) {
        this._clear();
        this.devSubject = subject;
        this.forceRefresh(() => {});
    }

    getTfHeader() {
        return this.tfHeader;
    }

    _clear() {
        trustFabricSvc.reset();
        this.devSubject = null;
        this.timerInProgress && clearTimeout(this.timerInProgress);
        this.stop = true;
    }

    getTokenUsingGrant(callback) {
        const grant = this.useDPoP ? getDPoPGrantFromFile() : getGrantFromFile();
        // For V4 this returns Wrapped Token
        // For V3 this returns Grant Token(UnWrapped Token)
        this.convertToDPoP({ token: grant, type: 'grant' }, (err, wrappedToken) => {
            if (err) {
                logger.error('Failed to generate DPoP wrapped token', err);
                return callback(err);
            }
            const options = {
                token: wrappedToken,
                scopes: this.scopes,
                version: this.version
            };
            trustFabricSvc.getTokenUsingGrant(options, (err, res) => {
                let token;
                if (!err) {
                    token = this.update(res);
                } else {
                    logger.error('Failed to generate token using GRANT file', err);
                }

                if (callback) {
                    callback(err, token);
                }
            });
        });
    }

    getTokenUsingRefreshToken(callback) {
        this.convertToDPoP({ token: this.refreshToken, type: 'refresh' }, (err, wrappedToken) => {
            if (err) {
                logger.error('Failed to generate DPoP wrapped token', err);
                return callback(err);
            }
            const options = {
                token: wrappedToken,
                scopes: this.scopes,
                version: this.version
            };
            trustFabricSvc.getTokenUsingRefreshToken(options, (err, res) => {
                let token;
                if (!err) {
                    token = this.update(res);
                } else {
                    this.failedRefreshCount++;
                    logger.error('Failed to generate token using REFRESH token', err);
                }
                if (callback) {
                    callback(err, token);
                }
            });
        });
    }

    update(res) {
        const token = this.accessToken = res.access_token;
        this.refreshToken = res.refresh_token || this.refreshToken;
        this.expiresIn = res.expires_in * 1000; // expires_in comes in seconds, convert to millisec
        this.timestamp = Date.now();
        const refreshTimeout = this.expiresIn / 2; // Trigger Refresh at half the expiry timeout
        this.refreshAfter(refreshTimeout);
        this.encryptAndCacheToken(this.refreshToken);
        return token;
    }

    encryptAndCacheToken(token, callback) {
        const secretKey = this.getSecretKey();
        crypto.scrypt(secretKey, this.salt, 24, (err, key) => {
            if (err) {
                return callback && callback(err);
            }
            try {
                const cipher = crypto.createCipheriv(algorithm, key, iv);
                let encrypted = cipher.update(token, 'utf8', 'hex');
                encrypted += cipher.final('hex');
                this.coldCache.put('TFRefreshToken', encrypted);
                callback && callback(null);
            } catch (e) {
                return callback && callback(e);
            }
        });
    }

    async decryptCachedToken(callback) {
        try {
            const secretKey = this.getSecretKey();

            const encryptedToken = await this.coldCache.get('TFRefreshToken');
            if (!encryptedToken) {
                return callback(new Error('Token is empty'));
            }

            crypto.scrypt(secretKey, this.salt, 24, (err, key) => {
                if (err) {
                    return callback(err);
                }
                try {
                    const decipher = crypto.createDecipheriv(algorithm, key, iv);
                    let token = decipher.update(encryptedToken, 'hex', 'utf8');
                    token += decipher.final('utf8');
                    callback(null, token);
                } catch (e) {
                    return callback(e);
                }
            });
        } catch (err) {
            callback(err);
        }
    }

    getSecretKey() {
        return (parseInt(Date.now() / SECRET_SIGN_PERIOD, 10) * SECRET_SIGN_PERIOD).toString();
    }

    createDiskCache() {
        const nodeEnv = (process.env.NODE_ENV || 'development').toLowerCase();

        this.coldCache = RaptorCache.createDiskCache({
            store: 'disk',
            dir: `.cache/trust-fabric-ebay-${nodeEnv}`,
            flushDelay: 1000,
            serialize: this.serialize,
            deserialize: this.deserialize
        });
    }

    serialize(data) {
        return data;
    }

    deserialize(reader) {
        return new Promise((resolve, reject) => {
            let json = '';
            reader()
                .on('data', (data) => {
                    json += data;
                })
                .on('end', () => resolve(json))
                .on('error', reject);
        });
    }

    refreshAfter(timeout) {
        if (this.stop) {
            return;
        }
        if (this.timerInProgress === undefined) {
            this.timerInProgress = setTimeout(() => {
                // clean up context to avoid memory leak
                while (process.domain) {
                    process.domain.exit();
                }

                this.timerInProgress = undefined;
                const isExpired = isTokenExpired(this.refreshToken);
                logger.info(`Refresh Timer called after ${timeout}ms, failedRefreshCount=${this.failedRefreshCount}, tokenExists=${!!this.refreshToken}, isRFExpired=${isExpired}`); // eslint-disable-line
                if (!this.refreshToken || isExpired || this.failedRefreshCount > this.MAX_REFRESH_RETRIES) { // eslint-disable-line
                    this.generateGrantAndGetToken((err) => {
                        if (err) {
                            logger.error('Failed to get using grant.', err);
                        } else {
                            logger.info('Token generated successfully after refresh using grant.');
                            this.failedRefreshCount = 0;
                        }
                    });
                } else {
                    this.getTokenUsingRefreshToken((err) => {
                        if (err) {
                            modConfig(module, (err, config) => {
                                logger.error('Failed to get token using refresh, setting refresh timer after 30sec.');
                                this.refreshAfter(config.get('refreshFailRetry'));
                            });
                        } else {
                            logger.info('Token generated successfully after refresh using refreshtoken.');
                            this.failedRefreshCount = 0;
                        }
                    });
                }
            }, timeout).unref();
        }
    }

    forceRefresh(callback) {
        // For TF V4, generate DPoP Wrapped Token and call TF Service to get TF Token
        if (!this.useDPoP && (env.isDev() || env.isTest() || env.isLocalDebug())) {
            // Generate Dummy Token for DEV
            this.generateDevToken((err, token) => {
                // Refresh DEV token in background
                setInterval(() => {
                    this.generateDevToken(() => {});
                }, this.devTokenExpiry / 2).unref(); // DEV Refresh in 12hrs

                callback(err, token);
            });
        } else if (!this.refreshToken) {
            // When Refresh Token is expired, do the following
            // 1) Check if Grant Expired, if not, generate token using grant
            // eslint-disable-next-line max-len
            // 2) If grant expired, check if encrypted cached refresh token exists & valid. If so, use refresh token to generate token
            // 3) If Refresh token expired, the call CMPaaS API to generate grant file.
            const codeGrant = this.useDPoP ? getDPoPGrantFromFile() : getGrantFromFile();
            if (isTokenExpired(codeGrant)) {
                logger.info('In ForceRefresh, GrantFile Token expired. Fetching from cache.');
                this.decryptCachedToken((err, cachedRFtoken) => {
                    if (err || isTokenExpired(cachedRFtoken)) {
                        logger.error('Decryption failed or Refresh TokenExpired, generating new grant file', err);
                        this.generateGrantAndGetToken(callback);
                    } else {
                        this.refreshToken = cachedRFtoken;
                        this.getTokenUsingRefreshToken(callback);
                    }
                });
            } else {
                logger.info('In ForceRefresh, Grant File token is valid. calling getTokenUsingGrant()');
                this.getTokenUsingGrant(callback);
            }
        } else if (isTokenExpired(this.refreshToken)) {
            logger.info('In ForceRefresh, Refresh Token expired. calling generateGrantAndGetToken()');
            this.generateGrantAndGetToken(callback);
        } else {
            logger.info('In ForceRefresh, Refresh Token is Valid. calling getTokenUsingRefreshToken()');
            this.getTokenUsingRefreshToken(callback);
        }
    }

    generateGrantAndGetToken(callback) {
        cmpaasService.generateGrantFile((err) => {
            if (err) {
                logger.error('GrantFile generation failed', err);
                return callback(err);
            }
            this.getTokenUsingGrant(callback);
        });
    }

    // If options provided, use it to wrap the token to DPoP and call TF Service to get TF Token
    getToken(options, callback) {
        if (typeof options === 'function') {
            // eslint-disable-next-line no-param-reassign
            callback = options;
        }

        // eslint-disable-next-line no-param-reassign
        options = {
            type: 'access',
            ...options
        };

        // If Access Token is present, wrap it to DPoP and return
        if (this.accessToken) {
            // eslint-disable-next-line max-len
            this.convertToDPoP({ token: this.accessToken, ...options }, (err, wrappedToken) => {
                callback(err, wrappedToken);
            });
        } else {
            // When Access Token is not present, generate a new token using refresh token
            // Wrap token to DPoP and call TF Service to get TF Token
            this.forceRefresh((err, token) => {
                if (err) {
                    return callback(err);
                }
                // eslint-disable-next-line max-len
                this.convertToDPoP({ token: token, ...options }, (err, wrappedToken) => {
                    callback(err, wrappedToken);
                });
            });
        }
    }

    generateDevToken(callback) {
        const currentTime = Date.now();

        const payload = {
            realm: 'dev',
            aud: audiences,
            instances: [ip]
        };

        const appName = appContext.appName;
        const options = {
            // eslint-disable-next-line max-len
            subject: this.devSubject || `cn=${appName}-app-ENVxxxxxxxx.xxx.ebay.com,ou=${appName}-app:ENVxxxxxxxx+l=dev,o=${appName},dc=ebay,dc=com`,
            issuer: 'trustfabric',
            algorithm: 'RS256',
            expiresIn: '1 days',
            notBefore: '1ms',
            header: {
                'kid': 'devkid',
                'typ': 'JWT',
                'x5u': 'internal://devcert'
            }
        };

        jwt.sign(payload, cert, options, (err, token) => {
            if (!err) {
                this.expiresIn = currentTime + this.devTokenExpiry;
                this.timestamp = currentTime;
                this.accessToken = token;
            } else {
                logger.error('Failed to generate token in dev', err);
            }
            if (callback) {
                callback(err, token);
            }
        });
    }

    convertToDPoP(options, callback) {
        // DPoP is valid only for V4, for V3 return the token as is
        if (!this.useDPoP) {
            return callback(null, options.token);
        }

        let jwk;
        try {
            jwk = getJwkFromKeychain();
        } catch (err) {
            logger.error('Failed to get JWK from keychain', err);
            return callback(err);
        }

        // To TF Server Token exchange
        const payload = {
            htu: options.htu || 'https://trustfabric.vip.ebay.com/v4/token',
            htm: options.htm || 'POST',
            iat: Math.floor(Date.now() / 1000),
            jti: crypto.randomUUID(),
            exp: Math.floor(Date.now() / 1000) + 10 * 60 // 10 minutes
        };

        if (options.type === 'grant') {
            payload.code = options.token;
        } else if (options.type === 'refresh') {
            payload.refreshtoken = options.token;
        } else if (options.type === 'access') {
            payload.accesstoken = options.token;
        }

        const header = {
            'alg': 'RS256',
            'typ': 'dpop+jwt',
            'jwk': jwk
        };

        // Base64URL encode the header and payload
        const base64url = (obj) => Buffer.from(JSON.stringify(obj))
            .toString('base64')
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');

        const headerEncoded = base64url(header);
        const payloadEncoded = base64url(payload);
        const dataToSign = `${headerEncoded}.${payloadEncoded}`;

        signWithKeychainPrivateKey(dataToSign, (err, signature) => {
            if (err) {
                logger.error('Failed to sign JWT token', err);
                return callback(err);
            }
            callback(null, `${dataToSign}.${signature}`);
        });
    }
}

module.exports = new TokenGenerator();
module.exports.TokenGenerator = TokenGenerator;
