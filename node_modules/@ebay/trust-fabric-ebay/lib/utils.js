'use strict';
const assert = require('assert');
const jwt = require('jsonwebtoken');
const path = require('path');
const tryRequire = require('try-require');
const fs = require('fs');
const logger = require('@ebay/logging-inc').logger('trust-fabric-ebay/Utils');
const appContext = require('@ebay/app-context-ebay');
const env = require('@ebay/environment-ebay');
const { execFileSync } = require('child_process');
const crypto = require('crypto');
const os = require('os');
const properties = require('properties');

let appServiceId;
let jwk;
let resourceId;

function getClientId(VERSION = 'v3') {
    if (VERSION === 'v2' || VERSION === 'v3' || VERSION === 'v4') {
        const appInstanceName = process.env.APP_INSTANCE_NAME || appContext.appName;
        const appName = process.env.APP_NAME || appContext.appName;
        const poolType = process.env.NODE_ENV || 'development';
        return `ou=${appInstanceName}+l=${appName},o=${poolType},dc=tess,dc=ebay,dc=com`;
    }
    assert.ok(process.env.CRONUSAPP_HOME, 'process.env.CRONUSAPP_HOME should exists');
    const metadata = tryRequire(path.join(process.env.CRONUSAPP_HOME, '.metadata.json'));
    let id;
    if (metadata) {
        const nugget = metadata['svc.nugget'];
        const odbMoName = metadata.odbMoName;
        id = `urn:cms:application/${nugget}/applicationservice/${nugget}-app:${odbMoName}`;
    }
    return id;
}

function getAppServiceId() {
    if (appServiceId) {
        return appServiceId;
    }

    const metadata = tryRequire(path.join(process.env.CRONUSAPP_HOME, '.metadata.json'));
    if (metadata) {
        const nugget = metadata['svc.nugget'];
        const odbMoName = metadata.odbMoName;
        appServiceId = `${nugget}-app:${odbMoName}`;
        return appServiceId;
    }
}

function getResourceId() {
    if (resourceId) {
        return resourceId;
    }
    const annotationsPath = '/mnt/annotations';
    try {
        if (!fs.existsSync(annotationsPath)) {
            return null;
        }
        const content = fs.readFileSync(annotationsPath, 'utf8');
        const parsed = properties.parse(content);
        let value = parsed['applicationservice.cms.tess.io/resource-id'] || null;
        // Remove surrounding double quotes if present
        if (value && typeof value === 'string') {
            value = value.replace(/^"(.*)"$/, '$1');
        }
        resourceId = value;
        return resourceId;
    } catch (err) {
        logger.error('Failed to get resource ID from annotations file', err);
        return null;
    }
}

function getGrantFromFile(asyncRead = false, callback) {
    let grantPath;
    if (process.env.TRF_ENABLE_V2 === 'true') {
        assert.ok(process.env.TRF_GRANT_FILE, 'process.env.TRF_GRANT_FILE should exists');
        grantPath = process.env.TRF_GRANT_FILE;
    } else {
        assert.ok(process.env.CRONUSAPP_HOME, 'process.env.CRONUSAPP_HOME should exists');
        grantPath = path.join(process.env.CRONUSAPP_HOME, '.data', '.appgrant');
    }
    let grant;
    if (asyncRead) {
        fs.readFile(grantPath, (err, data) => {
            if (err) {
                return callback(err);
            }

            return callback(null, data);
        });
    } else {
        try {
            grant = fs.readFileSync(grantPath);
            return grant;
        } catch (error) {
            logger.error(`Failed to read Grant file at ${ grantPath}`, error);
        }
        return grant;
    }
}

function getDPoPGrantFromFile() {
    // eslint-disable-next-line max-len
    const grantPath = process.env.TRF_GRANT_FILE_V4 || path.join(process.env.HOME, '.appdata', '.cloudsec', 'trustfabric', appContext.appName, 'authorization_code.json');
    const grantfile = tryRequire(grantPath);
    if (!grantfile) {
        logger.error(`Failed to read DPoP Grant file at ${ grantPath}`);
        return null;
    }
    return grantfile?.metadata?.authorization_code || null;
}

function isTokenExpired(grant) {
    let decodedGrant = jwt.decode(grant);
    decodedGrant = decodedGrant || {};
    const expiration = decodedGrant.exp;
    if (expiration > Date.now() / 1000) {
        return false;
    }
    return true;
}

function getTfVersion() {
    let VERSION = 'v3';
    // For CPDLC, use v3
    // For TRF_ENABLE_V2, use v3
    // Default to v3 instead of v1

    // If in dev zone and TRF_VERSION is set, use the version specified in TRF_VERSION i.e V4
    if (env.isDevZone() && process.env.TRF_VERSION) {
        VERSION = process.env.TRF_VERSION?.toLowerCase();
    } else if (process.env.CONTAINER_PDLC && process.env.CONTAINER_PDLC === 'true') {
        VERSION = 'v3';
    } else if (process.env.TRF_ENABLE_V2 === 'true') {
        VERSION = 'v3';
    } else {
        VERSION = 'v3'; // Changed from v1 to v3 as default
    }
    return VERSION;
}

function getJwkFromKeychain() {
    if (jwk) {
        return jwk;
    }
    try {
        const CN = `${os.hostname()}.corp.ebay.com`;
        const pem = execFileSync('security', ['find-certificate', '-c', CN, '-p']).toString('utf8');
        const pubKey = crypto.createPublicKey(pem);
        jwk = pubKey.export({ format: 'jwk' });
        return jwk;
    } catch (err) {
        logger.error('Failed to get JWK from keychain', err);
        throw err;
    }
}

/**
 * Sign data using the private key from keychain via cloudsec
 * Uses cloudsec crypto sign --jwt command for JWT token signing
 *
 * @param {String|Buffer} payload - The data to sign
 * @param {Function} callback - Callback function (err, signature)
 */
function signWithKeychainPrivateKey(payload, callback) {
    // Run only in macOS
    if (process.platform !== 'darwin') {
        return callback(new Error('signWithKeychainPrivateKey is only supported on macOS'));
    }

    if (!payload) {
        return callback(new Error('payload is required'));
    }

    try {
        // Use cloudsec crypto sign --jwt command for signing
        // eslint-disable-next-line max-len
        const signature = execFileSync('cloudsec', ['crypto', 'sign', '--jwt', payload.toString()]);
        // Remove trailing newline
        callback(null, signature.toString().replace(/\n$/, ''));
    } catch (err) {
        logger.error('Failed to sign with cloudsec:', err);
        callback(err);
    }
}

module.exports = {
    getClientId: getClientId,
    getGrantFromFile: getGrantFromFile,
    getAppServiceId: getAppServiceId,
    isTokenExpired: isTokenExpired,
    getTfVersion: getTfVersion,
    getJwkFromKeychain: getJwkFromKeychain,
    signWithKeychainPrivateKey: signWithKeychainPrivateKey,
    getDPoPGrantFromFile: getDPoPGrantFromFile,
    getResourceId: getResourceId
};
