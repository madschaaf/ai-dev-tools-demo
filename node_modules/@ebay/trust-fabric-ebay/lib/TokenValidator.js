/* eslint-disable no-param-reassign */
'use strict';

const assert = require('assert');
const jwt = require('jsonwebtoken');
const jose = require('jose');
const appContext = require('@ebay/app-context-ebay');
const env = require('@ebay/environment-ebay');
const LRU = require('lru-cache');
const fs = require('fs');
const path = require('path');
const utilsEbay = require('@ebay/utils-ebay');
const Provider = require('@ebay/service-client-ebay');
const cert = fs.readFileSync(path.join(__dirname, '..', 'resources/private.pem'));
const tokenGenerator = require('./TokenGenerator');
const utils = require('./utils');

let cachedClaims;

// Cache for public key for signature verification
const cachedPublicKey = new LRU(20);

class TokenValidator {
    constructor(req, config = {}) {
        assert.ok(req, 'Request is missing in constructor');
        this.req = req;
        this.config = config;
    }

    _clearCache() {
        cachedClaims = null;
    }

    // DPoP wrapped token is unwrapped and validated, if not a DPoP wrapped token, the token is returned as is
    // If it is a DPoP wrapped token, the access token is returned
    async unwrapAndValidateDPoP(token) {
        const dpopHeader = jose.decodeProtectedHeader(token);

        // Validate the token is a valid JWT
        if (!dpopHeader) {
            throw new Error('Invalid JWT token - header is missing');
        }

        // If not a DPoP wrapped token, return the token as is
        if (!dpopHeader.typ?.includes('dpop+jwt')) {
            return token;
        }

        // Import the public key and verify the signature
        const publicKey = await jose.importJWK(dpopHeader.jwk, dpopHeader.alg);

        // Verify the signature of the DPoP wrapped token from jwk provided in the header
        const { payload: dpopPayload } = await jose.jwtVerify(token, publicKey);

        // Verify htu and htm are not *
        if (dpopPayload.htu === '*' || dpopPayload.htm === '*') {
            throw new Error('Invalid DPoP wrapped token - htu and htm are not allowed to be *');
        }

        // Decode the access token to check if it is a V4 token
        // Verify cnf from the access token
        const accessTokenPayload = jose.decodeJwt(dpopPayload.accesstoken);
        if (accessTokenPayload.ver !== '4') {
            throw new Error('Invalid DPoP wrapped token - access token is not a V4 token');
        }

        // Verify cnf.jkt with the jwk provided in the header
        const cnfJkt = accessTokenPayload.cnf.jkt;
        // Compute the thumbprint of the jwk provided in the header
        const thumbprint = await jose.calculateJwkThumbprint(dpopHeader.jwk);
        if (thumbprint !== cnfJkt) {
            throw new Error('Invalid DPoP wrapped token - cnf.jkt does not match the thumbprint of the jwk');
        }

        return dpopPayload.accesstoken;
    }

    validate(token, options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {
                // Moved audience check to verify method due to DEV token
            };
        }

        options = Object.assign({
            algorithms: ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'],
            complete: true
        }, options);

        this.unwrapAndValidateDPoP(token)
            .then((unWrappedToken) => {
                // Validate the unwrapped token or v3 token if not DPoP wrapped
                jwt.verify(unWrappedToken, this.getKey, options, async (err, decoded) => {
                    if (err) {
                        return callback(err);
                    }

                    // If Not Dev Token, verify the audience
                    if (!decoded.header.x5u.includes('internal')) {
                        if (!decoded.payload.aud?.includes(appContext.appName)) {
                            return callback(new Error(`jwt audience invalid. expected: ${appContext.appName}`));
                        }
                    }

                    const ver = decoded.payload.ver;
                    const instances = decoded.payload.instances;
                    // In case of V3 tokens, get all the granular access policies for the app, if it exists.
                    const s2sAccessList = await this.getMatchingS2SPolicies(decoded);
                    try {
                        if (s2sAccessList.length > 0) {
                            // Validate if the granular access policies in token, match the app's claims.
                            this.validateAccessClaims(s2sAccessList, decoded);
                        } else {
                            // Validate Non prod Tokens are not used in Production
                            this.validateRealm(decoded.payload.realm);
                        }
                    } catch (err) {
                        return callback(err);
                    }

                    // For V3 tokens, validate the instances
                    // For v4 tokens, skip IP check
                    if (ver !== '4' && instances && instances.length > 0) {
                        if (!(Array.isArray(instances) || typeof instances === 'string')) {
                            return callback(new Error('instances should be array or string'));
                        }
                        const clientIP = utilsEbay.getRemoteAddrFromTrustedHeader(this.req);

                        // If the IP check is enabled, and the IP from token does not match the caller IP
                        // then check if fallback is allowed
                        // If fallback is allowed, then check if the Legacy IP is in the list of instances
                        const tfRealIp = this.req.headers && this.req.headers['x-ebay-tf-real-ip'];
                        if (this.config.isTfIpCheckEnabled && tfRealIp) {
                            if (!this.isIpValid(tfRealIp, instances)) {
                                if (this.config.isTfIpFallbackAllowed) {
                                    if (!this.isIpValid(clientIP, instances)) {
                                        // eslint-disable-next-line max-len
                                        return callback(new Error(`IP from token ${instances} does not match the caller IP for both realip=${tfRealIp} and  ClientIp=${clientIP}, fallback is enabled`));
                                    }
                                } else {
                                    // eslint-disable-next-line max-len
                                    return callback(new Error(`IP from token ${instances} does not match the caller IP realip=${tfRealIp}, fallback is disabled`));
                                }
                            }
                        } else if (!this.isIpValid(clientIP, instances)) {
                            // eslint-disable-next-line max-len
                            return callback(new Error(`IP from token ${instances} does not match the caller IP ${clientIP}, TF IP check is disabled`));
                        }
                    }

                    return callback(null, decoded);
                });
            }).catch(callback);
    }

    isIpValid(clientIP, instances) {
        if ((Array.isArray(instances) && !instances.includes(clientIP)) ||
        (typeof instances === 'string' && instances !== clientIP)) {
            return false;
        }
        return true;
    }

    getKey(header, callback) {
        const pubKeyUrl = header.x5u;
        if (!pubKeyUrl) {
            return callback(new Error('public key url(x5u) header is missing'));
        }

        if (pubKeyUrl.includes('internal')) {
            // Dev token is valid only in Non-prod env
            if (env.isNotProd() && env.isNotPreProd() && env.isNotSandbox()) {
                return callback(null, cert);
            }
            return callback(new Error('Dev Token Cannot be used in Production env'));
        }
        // Return cached pubic key
        if (cachedPublicKey.get(pubKeyUrl)) {
            return callback(null, cachedPublicKey.get(pubKeyUrl));
        }

        // Check if the cert URL is eBay trustfabric and not external
        const url = new URL(pubKeyUrl);
        if (!/^trustfabric(qa)?\.vip\.ebay\.com$/.test(url.host)) {
            return callback(new Error(`Invalid public key host URL for x5u ${pubKeyUrl}`));
        }
        // eslint-disable-next-line max-len
        const id = (url.host === 'trustfabric.vip.ebay.com') ? 'trust-fabric-service-getkey' : 'trust-fabric-service-qa-getkey';
        const client = Provider.context({}).getClient(id);

        client.get().path(url.pathname)
            .end((err, res) => {
                if (err) {
                    return callback(new Error(`Error while fetching public key from ${pubKeyUrl} : ${err.message}`));
                }
                const pubKey = res.body;
                cachedPublicKey.set(pubKeyUrl, pubKey);
                return callback(null, pubKey);
            });
    }

    async getMatchingS2SPolicies(decoded) {
        const entitlements = decoded.payload.entitlements;
        if (decoded.payload.ver !== '3' ||
            !entitlements ||
            !Array.isArray(entitlements.s2saccess) ||
            entitlements.s2saccess.length === 0) {
            return [];
        }
        if (!cachedClaims) {
            // Get the claims from client's own trust-fabric token and cache it
            await this.setCachedClaim();
        }
        // Only retrieve the granular access policies , which match the app name.
        return cachedClaims ? entitlements.s2saccess.filter(policy => cachedClaims.app === policy.app) : [];
    }

    validateAccessClaims(s2sAccessList, decoded) {
        const pubKeyUrl = decoded.header.x5u;
        if (pubKeyUrl.includes('internal')) {
            throw new Error(`Invalid realm dev in token for s2s access policy validation`);
        }
        /* Validate that for any access policy defined in the token,
         all the claims' listed in policy match the current app's claims.
         selfVal refers to claims from app's own claim ,
         while the value is from the granualr policy provided in token to be validated. */
        const isValid = !s2sAccessList.some(map => (
            !Object.entries(map).every(([key, value]) => {
                const selfVal = cachedClaims[key];
                return selfVal && (!value || selfVal === value);
            })
        ));
        if (!isValid) {
            throw new Error(`Service token validation failed - no matching s2s access policy exist`);
        }
    }

    validateRealm(realm) {
        const nonProdRealms = ['dev', 'qa', 'feature', 'staging', 'lnp'];
        if (realm && nonProdRealms.includes(realm)) {
            if (env.isProd() || env.isPreProd() || env.isSandbox()) {
                throw new Error(`Jwt token realm ${realm} is not allowed`);
            }
        }
    }

    async setCachedClaim() {
        return new Promise((resolve, reject) => {
            // Cache all the claims from app's own self token
            tokenGenerator.getToken((err, selfToken) => {
                if (err) {
                    return reject(Error(`Unable to generate token for self`));
                }
                const options = {
                    complete: false
                };
                cachedClaims = jwt.decode(selfToken, options);

                if (cachedClaims && !cachedClaims.pool) {
                    cachedClaims.pool = process.env.APP_INSTANCE_NAME || appContext.appName;
                }
                if (cachedClaims && !cachedClaims.app) {
                    cachedClaims.app = process.env.APP_NAME || appContext.appName;
                }
                if (cachedClaims && !cachedClaims.svc) {
                    cachedClaims.svc = utils.getResourceId();
                }
                resolve();
            });
        });
    }
}

module.exports = TokenValidator;