'use strict';
const provider = require('@ebay/service-client-ebay');
const { getAppServiceId, getGrantFromFile, isTokenExpired } = require('./utils');
const modConfig = require('@ebay/module-config-inc');
const utilsEbay = require('@ebay/utils-ebay');
const ip = utilsEbay.getIpAddress() || '127.0.0.1';
const crypto = require('crypto');
let sha256hmac;

class CmPaaS {
    constructor() {
        this.isRequestPending = false;
    }

    generateGrantFile(callback) {
        if (this.isRequestPending) {
            return callback(new Error('Existing CMPaaS request pending to generate grant file.'));
        }

        this.isRequestPending = true;

        modConfig(module, (err, config) => {
            if (err) {
                this.isRequestPending = false;
                return callback(err);
            }

            const MAX_RETRY = config.get('maxGrantRetry');
            const GRANT_FILE_TIMEOUT = config.get('grantFileStatusTimeout');

            const client = provider.context({}).getClient('cmpaas-grantfile-service');
            const appServiceId = getAppServiceId();
            client.request({
                body: '',
                method: 'POST',
                qs: {
                    'appServiceId': appServiceId
                }
            })
                .set('x-forwarded-for', ip)
                .set('authorization', `HMAC-SHA256 ${this.generateSha256Hmac()}`)
                .end((err, response) => {
                    if (err) {
                        this.isRequestPending = false;
                        return callback(new Error(`Failed to generate Grant file via CmPaaS API, ${err.stack}`));
                    }

                    const status = response.body.status || {};
                    if (status.statusCode !== 200) {
                        this.isRequestPending = false;
                        // eslint-disable-next-line max-len
                        return callback(new Error(`Failed to generate Grant file via CmPaaS API, status code=${status.statusCode}, message=${status.message}`));
                    }

                    this.checkStatus(MAX_RETRY, 1, GRANT_FILE_TIMEOUT, callback);
                });
        });
    }

    isGrantTokenExpired(callback) {
        getGrantFromFile(true, (grant) => {
            callback(isTokenExpired(grant));
        });
    }

    checkStatus(maxRetry, currRetry, timeout, callback) {
        this.isGrantTokenExpired((isExpired) => {
            if (isExpired) {
                if (currRetry >= maxRetry) {
                    this.isRequestPending = false;
                    return callback(new Error('Max retry check for grant check expired'));
                }
                setTimeout(() => {
                    // eslint-disable-next-line no-param-reassign
                    this.checkStatus(maxRetry, ++currRetry, timeout, callback);
                }, timeout);
            } else {
                this.isRequestPending = false;
                return callback();
            }
        });
    }

    generateSha256Hmac() {
        if (sha256hmac) {
            return sha256hmac;
        }

        const appServiceId = getAppServiceId();
        const hmac = crypto.createHmac('sha256', ip);
        hmac.update(appServiceId);
        sha256hmac = hmac.digest('hex');
        return sha256hmac;
    }
}

module.exports = new CmPaaS();
