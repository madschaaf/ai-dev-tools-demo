'use strict';

var crypto = require('crypto'),
    async = require('async'),
    sessionKeyService = require('./session-key-svc');

var debug = require('debug')('cookies:session');

var sessionKeyCache = {};

var SECRET_SIGN_PERIOD = 8639999990;
var HMAC_CHECKSUM_SIZE = 20;


function populateCache(keys) {
    for (var id in keys) {
        if (keys[id].id && keys[id].secretValue) {
            sessionKeyCache[id] = keys[id];
        }
    }
}

function getSessionKeySync(activeSecretId) {
    if (!activeSecretId) {
        activeSecretId = parseInt(Date.now() / SECRET_SIGN_PERIOD, 10) * SECRET_SIGN_PERIOD;
    }
    debug('getSessionKeySync for id: ' + activeSecretId);
    return sessionKeyCache[activeSecretId];
}

function _findByIdService(activeSecretId, callback) {
    var sessionKey;
    sessionKeyService.findById(activeSecretId, function (err, result) {
        if (err) {
            return callback(err);
        }
        sessionKey = result.body;
        //if session key doesn't exist , generate a new one.
        if (!sessionKey || !sessionKey.secretValue) {
            return callback(null);
        }

        sessionKeyCache[sessionKey.id] = sessionKey;
        return callback(null, sessionKey);
    });
}

function getSessionKeyAsync(activeSecretId, callback) {
    if (!activeSecretId) {
        activeSecretId = parseInt(Date.now() / SECRET_SIGN_PERIOD, 10) * SECRET_SIGN_PERIOD;
    }
    debug('getSessionKeyAsync for id ' + activeSecretId);
    var sessionKey = sessionKeyCache[activeSecretId];

    if (sessionKey) {
        debug('loading session key from cache ...');
        return callback(null, sessionKey);
    }

    debug('loading session key from remote service ...');
    _findByIdService(activeSecretId, callback);
}

function getOrGenSessionKeyAsync(activeSecretId, callback) {
    if (!activeSecretId) {
        activeSecretId = parseInt(Date.now() / SECRET_SIGN_PERIOD, 10) * SECRET_SIGN_PERIOD;
    }

    getSessionKeyAsync(activeSecretId, function (error, sessionKey) {
        if (error && error.statusCode !== 404) {
            return callback(error);
        }

        if (sessionKey) {
            return callback(null, sessionKey);
        } else {
            var newValue = crypto.randomBytes(HMAC_CHECKSUM_SIZE).toString('base64');
            sessionKey = {
                id: activeSecretId,
                secretValue: newValue
            };
            debug('SessionKey is not there, inserting new keys: ', sessionKey);

            sessionKeyService.tryInsert(sessionKey, function (err, result) {
                if (result.body === true) {
                    if (sessionKey) {
                        sessionKeyCache[sessionKey.id] = sessionKey;
                    }
                    return callback(null, sessionKey);
                } else {
                    // If sessionKey cannot be inserted , try to get it again -- maybe someone else inserted it meanwhile
                    debug('Failed to insert new key, try to get the key again!');
                    _findByIdService(activeSecretId, callback);
                }
            });

        }
    });
}

function warmUpSessionKeyCache(num, callback) {
    if (!num || num < 1) {
        num = 1;
    }

    var secretIds1 = [], secretIds2 = [];
    var activeSecretId = parseInt(Date.now() / SECRET_SIGN_PERIOD, 10) * SECRET_SIGN_PERIOD;
    secretIds1.push(activeSecretId);

    for (var i = 1; i <= num; i++) {
        secretIds1.push(activeSecretId + i * SECRET_SIGN_PERIOD);
        secretIds2.push(activeSecretId - i * SECRET_SIGN_PERIOD);
    }

    async.parallel([
        function (cb) {
            async.map(secretIds1, getOrGenSessionKeyAsync, function (error, results) {
                cb(error, results);
            });
        },
        function (cb) {
            async.map(secretIds2, getSessionKeyAsync, function (error, results) {
                cb(error, results);
            });
        }
    ], function (error, results) {
        callback(error, sessionKeyCache);
    });
}

module.exports = {
    populateCache: populateCache,
    getSessionKeySync: getSessionKeySync,
    getSessionKeyAsync: getSessionKeyAsync,
    SECRET_SIGN_PERIOD: SECRET_SIGN_PERIOD,
    warmUpSessionKeyCache: warmUpSessionKeyCache,
    getOrGenSessionKeyAsync: getOrGenSessionKeyAsync
};
