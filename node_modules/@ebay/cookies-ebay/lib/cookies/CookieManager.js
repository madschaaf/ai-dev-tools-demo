'use strict';

var _ = require('underscore');
var assert = require('assert');
var Cookie = require('./Cookie');
var nodeCookie = require('cookie');
var calUtil = require('../utils/calUtils');
var utils = require('../utils/utils');
var logger = require('@ebay/logging-inc').logger('cookies-ebay/CookieManager');
var CookieAuditInstrumentation = require('./../CookieAuditInstrumentation');
var cookieAuditInstrumentation = new CookieAuditInstrumentation();

var beginningOfTime = new Date(0).toUTCString();
var parseOpts = {
        decode: function (str) {
            return str;
        }
    };

function CookieManager(req, res) {
    this._req = req;
    this._res = res;
    this._cookies = {};
    this._cookiesLoaded = false;
    this._saveEnabled = true;
}

CookieManager.prototype = {
    _isCookieSecureEnabled(name) {
        if (!this.config) {
            return false;
        }
        if (this.config.phase1SecureCookies &&
        this.config.phase1SecureCookies.indexOf(name) > -1) {    
            return this.config.secureCookieEnabled;
        }
        return this.config.secureCookiePhase2Enabled;
    },
    _commitCookie: function (name, value, domain, path, maxAge, secure, httpOnly, sameSite, partitioned) {
        if (value && utils.checkInvalidHeaderChar(value)) {
            logger.error(new Error(`Detected invalid character in set-cookie header, skipping the header (${name}) value`));
            return;
        }

        var headerValueParts = [name + '=' + value];
        if (domain) {
            headerValueParts.push('Domain=' + domain);
        }
        if (path) {
            headerValueParts.push('Path=' + path);
        }
        if (maxAge >= 0) {
            // Instead of using the MaxAge cookie property, we use
            // Expires since it is supported by all web browsers (including IE)
            headerValueParts.push('Expires=' + this._expires(maxAge));
        }
        if (httpOnly) {
            headerValueParts.push('HttpOnly');
        }
        if(sameSite) {
            headerValueParts.push('SameSite=' + sameSite);
        }        
        if (secure && this._isCookieSecureEnabled(name)) {
            headerValueParts.push('Secure');
        }
        if (partitioned) {
            headerValueParts.push('Partitioned');
        }

        var cookiesCommited = this._res.getHeader('Set-Cookie') || [];

        if (!Array.isArray(cookiesCommited)) {
            cookiesCommited = [cookiesCommited];
        }

        cookiesCommited.push(headerValueParts.join('; '));
        this._res.setHeader('Set-Cookie', cookiesCommited);
    },
    _doLoadCookies: function () {
        var cookiesHeader = this._req.headers.cookie;
        if (cookiesHeader) {
            var cookies = nodeCookie.parse(cookiesHeader, parseOpts);
            if (cookies) {
                // Convert all of the cookies to ebayCookie
                // objects and add them to the internal collection
                _.each(_.keys(cookies), function (name) {
                    var value = cookies[name];
                    // Add the Cookie object to the internal collection
                    this._addCookieInternal(name, value);

                    //Cookie Audit Instrumentation, cookie => received
                    cookieAuditInstrumentation.updateMetrics(name, 'read');

                }.bind(this));
            }
        }
    },
    _expires: function (maxAge) {
        var expires;
        if (maxAge >= 0) {
            // Instead of using the MaxAge cookie property, we use
            // Expires since it is supported by all web browsers (including IE)
            if (maxAge === 0) {
                expires = beginningOfTime;
            } else {
                expires = new Date(Date.now() + maxAge * 1000).toUTCString();
            }
            return expires;
        }
        return expires;
    },
    _loadCookies: function () {
        if (this._cookiesLoaded === false) {
            this._doLoadCookies();
            this._cookiesLoaded = true;
        }
    },
    _addCookieInternal: function (name, value) {
        this._cookies[name] = new Cookie(name, value);
        return this._cookies[name];
    },
    createCookie: function (name, value) {
        // Read in the initial cookies so that we can make sure the
        // newly created cookie overrides any existing cookie with the same
        // name that might already exist
        this._loadCookies();
        var cookie = this._cookies[name] = new Cookie(name, value);
        cookie.setModified(true);
        return cookie;
    },
    getCookie: function (name, type) {
        this._loadCookies();
        var cookie = this._cookies[name];
        return cookie && !cookie.isDeleted() ? cookie : null;
    },
    getOrCreateCookie: function (name) {
        return this.getCookie(name) || this.createCookie(name);
    },
    forEachCookie: function (callback, thisObj) {
        this._loadCookies();
        var cookies = this._cookies;
        _.each(_.keys(cookies), function (name) {
            var cookie = cookies[name];
            if (!cookie.isDeleted()) {
                callback.call(thisObj, cookie);
            }
        });
    },
    getCookiesByName: function () {
        this._loadCookies();
        var cookies = this._cookies || {};
        _.each(_.keys(cookies), function (name) {
            var cookie = cookies[name];
            if (!cookie.isDeleted()) {
                cookies[name] = cookie;
            }
        });
        return cookies;
    },
    deleteCookie: function (name) {
        this._loadCookies();
        var cookie = this._cookies[name];
        if (cookie) {
            //Mark the cookie as deleted if it exists
            cookie.setDeleted(true);
        }
    },
    getCookieValue: function (name, defaultValue) {
        var cookie = this.getCookie(name);
        return cookie === null || cookie === undefined ? defaultValue : cookie.getValue();
    },
    setCookieValue: function (name, value) {
        var cookie = this.getOrCreateCookie(name);
        cookie.setValue(value);
    },
    commitCookies: function () {
        var cookies = this._cookies;
        var keys = _.keys(cookies);
        _.each(keys, function (name) {
            var cookie = cookies[name];
            
            //Cookie Audit Instrumentation
            if (cookie.isDeleted()) {
                //cookie => deleted
                cookieAuditInstrumentation.updateMetrics(name, 'delete');
            }else if (cookie.isModified()){
                //cookie => sent
                cookieAuditInstrumentation.updateMetrics(name, 'send');
            }

            if (cookie.isModified()) {
                var value;
                var maxAge;
                var domain = cookie.getDomain();
                var path = cookie.getPath();
                var secure = cookie.isSecure();
                const sameSite = cookie.getSameSite();
                var httpOnly = cookie.isHttpOnly();
                var partitioned = cookie.isPartitioned();
                if (cookie.isDeleted()) {
                    value = '';
                    maxAge = 0;
                } else {
                    value = cookie.serialize ? cookie.serialize() : cookie.getValue();
                    maxAge = cookie.getMaxAge();
                }
                if ((value === null || value === undefined) && cookie.serialize) {
                    // We got back a null value after serializing
                    // the cookie value which means that we shouldn't
                    // write out a new cookie. However, if the cookie
                    // was previously committed then we need to now
                    // delete it
                    if (cookie.hasValue()) {
                        value = '';
                        maxAge = 0;
                    } else {
                        // Cookie was not previously commited
                        return;
                    }
                }
                cookie.setValue(value);
                cookie.setModified(false);
                this._commitCookie(name, value, domain, path, maxAge, secure, httpOnly, sameSite, partitioned);
            }
        }, this);
    },
    getBrowserCommitCode: function () {
        var parts = [];
        var cookies = this._cookies;
        var keys = _.keys(cookies);
        _.each(keys, function (name) {
            var cookie = cookies[name];
            if (this._res.headersSent && cookie.isModified()) {
                if (cookie.isHttpOnly() || cookie.isSecure()) {
                    calUtil.createInfoEvent('HttpOnly or non-secure cookie is allowed, cookie name: ' + name);
                    return;
                }
                var value;
                var maxAge;
                var domain = cookie.getDomain();
                var path = cookie.getPath();
                var secure = cookie.isSecure();
                var httpOnly = cookie.isHttpOnly();
                if (cookie.isDeleted()) {
                    value = '';
                    maxAge = 0;
                } else {
                    value = cookie.serialize ? cookie.serialize() : cookie.getValue();
                    maxAge = cookie.getMaxAge();
                }
                if ((value === null || value === undefined) && cookie.serialize) {
                    // We got back a null value after serializing
                    // the cookie value which means that we shouldn't
                    // write out a new cookie. However, if the cookie
                    // was previously committed then we need to now
                    // delete it
                    if (cookie.hasValue()) {
                        value = '';
                        maxAge = 0;
                    } else {
                        // Cookie was not previously commited
                        return;
                    }
                }
                cookie.setValue(value);
                cookie.setModified(false);
                parts.push('document.cookie="' + this.getBrowserCookieCode(name, value, domain, path, maxAge, secure, httpOnly) + '";');
            }
        }, this);
        return parts.length ? parts.join('') : null;
    },
    getBrowserCookieCode: function (name, value, domain, path, maxAge, secure, httpOnly) {
        if (httpOnly) {
            throw new Error('HttpOnly cookie not allowed, cookie name: ' + name);
        }
        var cookie = [];
        cookie.push(name + '=' + value);
        if (path) {
            cookie.push(';path=' + path);
        }
        if (domain) {
            cookie.push(';domain=' + domain);
        }
        if (maxAge >= 0) {
            // Instead of using the MaxAge cookie property, we use
            // Expires since it is supported by all web browsers (including IE)
            cookie.push(';expires=' + this._expires(maxAge));
        }
        if (secure) {
            cookie.push(';secure');
        }
        return cookie.join('');
    }
};

module.exports = {
    getCookieManager: function (req, res) {
        assert.ok(req, '"req" is a required argument');
        assert.ok(res, '"res" is a required argument');
        return new CookieManager(req, res);
    }
};
