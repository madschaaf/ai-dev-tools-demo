'use strict';

const cal = require('@ebay/cal');
const metadata = require('./ebay-cookies/metadata');
const EMIT_METRICS_INTERVAL = 10 * 60 * 1000; // 10 mins

const acceptedMetricsMethods = new Set(['read', 'send', 'delete']);
const cookieToProperty = new Map();
const cookieletToProperty = new Map();

for (const cookie of Object.values(metadata.Cookies)) {
    if (!cookie.parent) {
        cookieToProperty.set(cookie.name, {
            id: cookie.id,
            idName: cookie.idName ? cookie.idName : 'N/A',
            name: cookie.name ? cookie.name : 'N/A'
        });
    }else{
        cookieletToProperty.set(cookie.idName, {
            id: cookie.id,
            idName: cookie.idName ? cookie.idName : 'N/A',
            name: cookie.name ? cookie.name : 'N/A'
        });
    }
}
//add total status to be used in VI page
const totalCookieStats = new Map();
const totalCookieletStats = new Map();

let cookieStats = new Map();
let cookieletStats = new Map();


class CookieAuditInstrumentation {
    constructor(options = {}) {        

        options.emit_metrics_interval = options.emit_metrics_interval || EMIT_METRICS_INTERVAL;
        const intervalId = setInterval(this.emitMetrics, options.emit_metrics_interval);
        intervalId.unref();
    }
    updateMetrics(cookieId, method) {
        //only 'read', 'send', 'delete' metrics are available
        if(!acceptedMetricsMethods.has(method)){
            return;
        }
        const cookieType = this.isCookieOrCookielet(cookieId);

        if(cookieType === 'cookielet'){
            this.updateCookieletMetrics(cookieId, method);
        }
        if(cookieType === 'cookie'){
            this.updateCookieMetrics(cookieId, method);
        }
    }
    updateCookieletMetrics(cookieId, method){
        if(!cookieletStats.has(cookieId)){
            cookieletStats.set(cookieId, {
                read: 0,
                send: 0,
                delete: 0
            });
        }
        if(!totalCookieletStats.has(cookieId)){
            totalCookieletStats.set(cookieId, {
                id: cookieletToProperty.get(cookieId).id,
                idName: cookieletToProperty.get(cookieId).idName,
                name: cookieletToProperty.get(cookieId).name,
                read: 0,
                send: 0,
                delete: 0
            });
        }
        cookieletStats.get(cookieId)[method]++;
        totalCookieletStats.get(cookieId)[method]++;
    }
    updateCookieMetrics(cookieId, method){
        if(!cookieStats.has(cookieId)){
            cookieStats.set(cookieId, {
                read: 0,
                send: 0,
                delete: 0
            });
        }
        if(!totalCookieStats.has(cookieId)){
            totalCookieStats.set(cookieId, {
                id: cookieToProperty.get(cookieId).id,
                idName: cookieToProperty.get(cookieId).idName,
                name: cookieToProperty.get(cookieId).name,
                read: 0,
                send: 0,
                delete: 0
            });
        }
        totalCookieStats.get(cookieId)[method]++;
        cookieStats.get(cookieId)[method]++;
    }
    emitMetrics() {
        //for cookie
        for(const [key, value] of cookieStats){
            const hb = cal.createHeartbeat('CookieAudit', 'cookie');
            hb.addData('m:resSecs', 600);
            hb.addData('t:name', key);
            Object.keys(value).forEach((method) => {
                if (value[method] && value[method] > 0) {
                    if(method === 'read'){
                        hb.addData('g:received', value[method]);
                    }
                    if(method === 'send'){
                        hb.addData('g:sent', value[method]);
                    }
                    if(method === 'delete'){
                        hb.addData('g:deleted', value[method]);
                    }
                }
            });
            hb.complete();
        }

        //for cookielet
        for(const [key, value] of cookieletStats){
            const hb = cal.createHeartbeat('CookieAudit', 'cookielet');
            hb.addData('m:resSecs', 600);
            hb.addData('t:name', key);
            Object.keys(value).forEach((method) => {
                if (value[method] && value[method] > 0) {
                    if(method === 'read'){
                        hb.addData('g:read', value[method]);
                    }
                    if(method === 'send'){
                        hb.addData('g:written', value[method]);
                    }
                    if(method === 'delete'){
                        hb.addData('g:removed', value[method]);
                    }
                }
            });
            hb.complete();
        }
        
        // Reset cookieletStats and cookieStats
        cookieletStats = new Map();
        cookieStats = new Map();
    }
    getCookieStats(){
        return cookieStats;
    }
    getCookieletStats(){
        return cookieletStats;
    }
    getTotalCookieStats(){
        return totalCookieStats;
    }
    getTotalCookieletStats(){
        return totalCookieletStats;
    }
    isCookieOrCookielet(cookieId){
        if(cookieletToProperty.has(cookieId)){
            return 'cookielet';
        }else if(cookieToProperty.has(cookieId)){
            return 'cookie';
        }else{
            return 'N/A';
        }   
    }
}

module.exports = CookieAuditInstrumentation;
