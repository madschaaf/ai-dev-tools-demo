'use strict';

var async = require('async');
var metadata = require('./metadata');
var Cookies = metadata.Cookies;
var CookieManager = require('../cookies/CookieManager');
var EbayCookiePacked = require('./EbayCookiePacked');
var EbayCookieUnpacked = require('./EbayCookieUnpacked');
var EbayCookielet = require('./EbayCookielet');
var cookieUtils = require('../utils/utils');
var debug = require('debug')('cookies:manager');
var logger = require('@ebay/logging-inc').logger('cookies-ebay/EbayCookieManager');
var utils = require('../utils/utils');

function getCookieMeta(cookieId) {
    if (!cookieId) {
        throw new Error('cookieId argument is required');
    }
    if (typeof cookieId !== 'object') {
        var meta = Cookies[cookieId];
        if (!meta) {
            debug('Invalid cookie ID: ' + cookieId);
        }
        return meta;
    } else {
        return cookieId;
    }
}

var createEbayCookie = utils.tryCatch(function createEbayCookie(cookieManager, cookie, cookieMeta) {
    var EbayCookieConstructor = cookieMeta.unpacked ? EbayCookieUnpacked : EbayCookiePacked;
    var ebayCookie = cookieManager._getEbayCookies()[cookieMeta.id] = new EbayCookieConstructor(cookieMeta, cookie);
    cookie.setDomain(cookieManager.getDomain());
    cookie.setHttpOnly(cookieManager.isCookieHttpOnly(cookieMeta));
    if (cookieMeta.partitioned !== undefined && cookieMeta.partitioned !== false) {
        cookie.setPartitioned(cookieMeta.partitioned);
    }
    return ebayCookie;
}, function log(err) {
    logger.warn('Cookie parse error: ', err);
});

function getEbayCookie(cookieManager, cookieMeta, create) {
    var id = cookieMeta.id;
    var ebayCookie = cookieManager._getEbayCookies()[id];
    if (!ebayCookie && create) {
        var cookie = cookieManager.getRawCookieManager().createCookie(cookieMeta.name);
        // Wrap the raw Cookie as an EbayCookie
        ebayCookie = createEbayCookie(cookieManager, cookie, cookieMeta);
    }
    return ebayCookie;
}

function containingCookie(cookieManager, meta, create) {
    var parentCookie;
    if (meta.cookielet) {
        var parentCookieMeta = meta.parent;
        if (!parentCookieMeta) {
            throw new Error('Invalid parent for cookielet: ' + meta.idName);
        }
        // Retrieve the parent cookie for the cookielet
        parentCookie = getEbayCookie(cookieManager, parentCookieMeta, create);
    } else {
        parentCookie = getEbayCookie(cookieManager, meta, create);
    }
    return parentCookie;
}

function EbayCookieManager(req, res) {
    this._request = req;
    this._response = res;
    this._ebayCookies = null;
    this._rawCookieManager = null;
    this._config = null;
    this._context = {
        request: req,
        response: res
    };

}

//append additional digits in front of the number - usage for binary strings
function prependDigits(string, digitChar, repeat){
    string = string ? string : '';
    repeat = repeat ? repeat : 0;

    if(digitChar && repeat){
        for(var i=0;i<repeat;i=i+1){
            string = digitChar + string;
        }
    }

    return string;
}

function getFlagBitObject(cookieStr, cookieFlag){
    //parse by new format, it seems all/most are new format from cookie manager
    if (cookieStr && cookieStr.indexOf('#') === 0) {
        cookieStr = cookieStr.substring(1);

        var bitIndex = cookieFlag.bitindex;
        var length = cookieStr.length;
        var charBitPosition = bitIndex % 4; //bit index starts from 0
        var charPosition = Math.floor(bitIndex / 4) + 1;
        var absCharPosition = length - charPosition;
        var expandedCookieStr;

        //the cookie size is smaller than what we are looking for
        //append additional digits('0')
        if(absCharPosition < 0) {
            var additionalBitsToAdd = Math.ceil(absCharPosition  * -1);
            expandedCookieStr = prependDigits(cookieStr, '0', additionalBitsToAdd);

            cookieStr = expandedCookieStr;
            length = cookieStr.length;
            absCharPosition = length - charPosition;
        }


        var subCookie = cookieStr.substring(absCharPosition, absCharPosition + 1);

        return {
            subCookie: subCookie,
            charBitPosition: charBitPosition,
            absCharPosition: absCharPosition + 1,
            expandedCookieStr: expandedCookieStr ? '#'+expandedCookieStr : undefined
        };
    } else {
        //parse by OLD format
        //NEED TO DO
    }
}

EbayCookieManager.prototype = {
    _getEbayCookies: function () {
        var _cookies = this._ebayCookies;
        if (_cookies) {
            return _cookies;
        }
        this._ebayCookies = {};
        // trigger loading of cookies
        this.getRawCookieManager();
        return this._ebayCookies;
    },
    setConfig(config) {
        this._config = config;
    },
    getRawCookieManager: function () {
        if (!this._rawCookieManager) {
            this._rawCookieManager = CookieManager.getCookieManager(this._request, this._response);
            this._rawCookieManager.config = this._config || {};
            this._rawCookieManager.forEachCookie(this._loadInitialCookie, this);
        }
        return this._rawCookieManager;
    },
    getDomain: function () {
        if (!this._domain) {
            this._domain = cookieUtils.extractDomainName(this.getServerName());
        }
        return this._domain;
    },
    getAllCookies: function () {
        return cookieUtils.values(this._getEbayCookies());
    },
    commitCookies: function () {
        this.getRawCookieManager().commitCookies();
    },
    validateAllCookies: function (callback) {
        debug('validating all cookies ...');
        const results = [];
        async.map(this.getAllCookies(),
            // the errors are suppressed, we are interested in results here
            function (ebayCookie, cb) {
                if (!ebayCookie.isValidated()) {
                    debug('cookie %s hasn\'t been validated!', ebayCookie.meta.name);
                    ebayCookie.validate(function (error, isValid) {
                        results.push(isValid);
                        return cb();
                    });
                } else {
                    debug('cookie %s has already been validated!', ebayCookie.meta.name);
                    return cb();
                }
            },
            function () {
                return callback(null, results);
            });
    },
    _loadInitialCookie: function (cookie) {
        const cookieMeta = metadata.getCookieMetaByName(cookie.getName());
        if (cookieMeta) {
            if (this.isBlackListedCookie(cookieMeta)) {
                logger.warn(`Request cookie ${cookieMeta.name} is blacklisted`);
                return;
            }
            const ebayCookie = createEbayCookie(this, cookie, cookieMeta);
            if (ebayCookie) {
                ebayCookie.deserialize(this);
                if (!cookieMeta.unpacked) {
                    if (ebayCookie.isValid()) {
                        for (let id in ebayCookie._cookieletsMap) {
                            const cookielet = ebayCookie._cookieletsMap[id];
                            if (cookielet.isDeleted()) {
                                // skip deleted cookielets
                                continue;
                            }
                            if (this.isBlackListedCookie(cookielet.meta)) {
                                cookielet.setDeleted(true);
                                logger.warn(`Request cookielet ${cookielet.meta.name} is blacklisted`);
                            }
                        }
                    }
                }
            }
        }
    },
    getContext: function () {
        return this._context;
    },
    isBlackListedCookie(meta) {
        return meta && meta.status === 'blacklist' &&
            this._config && this._config.blackListedCookies.indexOf(meta.name) > -1;
    },
    isUnmanagedCookieAllowed(cookieId) {
        return this._config &&
            (this._config.blockUnmanagedCookies !== true || this._config.blockUnmanagedCookies === true &&
            this._config.unmanagedCookiesAllowList.indexOf(cookieId) > -1);
    },
    isCookieHttpOnly(meta) {
        if (!this._config || meta.httpOnly !== true) {
            return false;
        }
        return this._config.httpOnlyCookies && this._config.httpOnlyCookies.indexOf(meta.name) > -1;
    },
    setCookieValue: function (cookieId, value) {
        var meta = getCookieMeta(cookieId);
        if (meta) {
            if (this.isBlackListedCookie(meta)) {
                logger.warn(`Cookie ${meta.name} is blacklisted`, new Error('Application tried to set blacklisted cookie'));
                return;
            }
            var parentCookie = containingCookie(this, meta, true);
            if (parentCookie) {
                if (meta.cookielet) {
                    var cookielet = new EbayCookielet(meta, value);
                    parentCookie.addCookielet(cookielet);
                } else {
                    parentCookie.setUnpackedValue(value);
                }
            }
        } else if (cookieId) {
            if (value && typeof value === 'object') {
                this.getRawCookieManager().setCookieValue(cookieId, value.value);
                var domainCookie = this.getRawCookieManager().getCookie(cookieId);
                domainCookie.setPath(value.path);
                domainCookie.setDomain(value.domain);
                domainCookie.setMaxAge(value.maxAge);
                domainCookie.setSecure(value.secure);
                domainCookie.setSameSite(value.sameSite);
                domainCookie.setHttpOnly(value.httpOnly);
                if (value.partitioned !== undefined) {
                    domainCookie.setPartitioned(value.partitioned);
                }
            } else {
                if (this.isUnmanagedCookieAllowed(cookieId)) {
                    this.getRawCookieManager().setCookieValue(cookieId, value);
                }
                else {
                    logger.error(`The framework no longer allows to use cookies (${cookieId}) that are not registered in @ebay/cookies-resource-ebay, ` +
                        `this functionality will stop working in the next M4 SWU`);
                }
            }
        }
    },
    getCookieValue: function (cookieId) {
        const meta = getCookieMeta(cookieId);
        if (this.isBlackListedCookie(meta)) {
            logger.warn(`Requested cookie ${meta.name} is blacklisted, skipping`, new Error('App tried to read blacklisted cookie, please remove cookie ready from the code'));
            return;
        }
        let value;
        if (meta) {
            var parentCookie = containingCookie(this, meta, false);
            if (parentCookie) {
                if (meta.cookielet) {
                    value = parentCookie.getCookieletValue(meta);
                } else if (parentCookie.getUnpackedValue) {
                    value = parentCookie.getUnpackedValue();
                }
            }
        } else {
            if (this.isUnmanagedCookieAllowed(cookieId)) {
                value = this.getRawCookieManager().getCookieValue(cookieId);
            }
            else {
                logger.error(`The framework no longer allows to use cookies (${cookieId}) that are not registered in @ebay/cookies-resource-ebay, ` +
                    `this functionality will stop working in the next M4 SWU`);
            }
        }
        return value;
    },
    getCookieBitNameFromId: function (cookieBitId) {
            for (const [flagName, flagMeta] of Object.entries(metadata.Flags)) {
                console.log('flagMeta', flagMeta);
                if (flagMeta.cookieBitId === cookieBitId) {
                    console.log('flagName', flagName);
                    return flagName;
                }
            }
            return null;
    },
    removeCookie: function (cookieId) {
        var meta = getCookieMeta(cookieId);
        if (meta) {
            var parentCookie = containingCookie(this, meta, false);
            if (parentCookie) {
                if (meta.cookielet) {
                    parentCookie.removeCookielet(meta);
                } else {
                    parentCookie.remove();
                }
            }
         } else {
            this.getRawCookieManager().deleteCookie(cookieId);
        }
    },
    hasFlag: function (flag) {
        var self = this;
        var hasFlag = false;
        var cookieFlag = metadata.Flags[flag] || {};
        var cookieName = cookieFlag.cookie;

        var cookieStr = self.getCookieValue(cookieName);
        if (cookieStr && cookieStr.indexOf('#') === 0) {
            //parse by new format, it seems all/most are new format from cookie manager
            var bitIndex = cookieFlag.bitindex;
            var length = cookieStr.length;
            var charBitPosition = bitIndex % 4; //bit index starts from 0
            var charPosition = (bitIndex / 4) + 1;
            if (length > charPosition) {
                var absCharPosition = Math.ceil(length - charPosition);
                var subCookie = cookieStr.substring(absCharPosition, absCharPosition + 1);
                var hexValue = parseInt(subCookie, 16);

                var flagMask = 1 << charBitPosition;
                hasFlag = (hexValue & flagMask) === flagMask;
                hasFlag = !!hasFlag;
            }
        } else {
            //parse by OLD format
            //NEED TO DO
        }
        return hasFlag;
    },
    setFlag: function(flag, value){
        var self = this;
        var cookieFlag = metadata.Flags[flag] || {};
        var cookieName = cookieFlag.cookie;
        var setBit = value ? '1' : '0';
        var cookieStr = self.getCookieValue(cookieName);
        var flagDetails = getFlagBitObject(cookieStr || (cookieFlag ? '#' : undefined), cookieFlag);

        if (flagDetails) {
            cookieStr = flagDetails.expandedCookieStr ? flagDetails.expandedCookieStr : cookieStr;
            var subCookie = flagDetails.subCookie;
            var charBitPosition = flagDetails.charBitPosition;
            var absCharPosition = flagDetails.absCharPosition;

            //convert digit to binary - 4 digit
            var binaryString = parseInt(subCookie, 16).toString(2);
            //if its not 4 digits - append 0s
            binaryString = binaryString.length < 4 ? prependDigits(binaryString, '0', 4 - binaryString.length) : binaryString;
            //override the bit we want to with 0/1
            binaryString = binaryString.split('');
            binaryString[3 - charBitPosition] = setBit;
            binaryString = binaryString.join('');

            var updatedValue = parseInt(binaryString, 2).toString(16);
            //replace the bit in the original string
            var updatedCookieStr = cookieStr.substring(0, absCharPosition) +
                updatedValue +
                cookieStr.substring(absCharPosition + 1);

            return this.setCookieValue(cookieName, updatedCookieStr);
        }
    },
    getCreationDate: function (cookieId) {
        var meta = getCookieMeta(cookieId);
        var creationDate;
        if (meta) {
            var parentCookie = containingCookie(this, meta, false);
            if (parentCookie) {
                if (meta.cookielet) {
                    creationDate = parentCookie.getCookieletCreationDate(meta);
                } else {
                    creationDate = parentCookie.getUnpackedCreationDate();
                }
            }
        }
        return creationDate;
    },
    getServerName: function () {
        var req = this._request,
            host = req.ebay && req.ebay.host;
        if (!host) {
            host = req.headers.host;
            if (!host) {
                return null;
            }
            var portStart = host.indexOf(':');
            if (portStart !== -1) {
                host = host.substring(0, portStart);
            }
        }
        return host;
    }
};
module.exports = EbayCookieManager;
module.exports[Symbol.for('logger')] = logger;
