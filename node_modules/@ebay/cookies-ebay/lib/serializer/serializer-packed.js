'use strict';

var crypto = require('crypto');
var crc32 = require('buffer-crc32');
var metadata = require('../ebay-cookies/metadata');
var Constants = metadata.Constants;
var Cookies = metadata.Cookies;
var consts = require('../utils/constants');
var EbayCookielet = require('../ebay-cookies/EbayCookielet');
var rmtSessionKey = require('../session/session-key');
var calUtil = require('../utils/calUtils');
var debug = require('debug')('cookies:serializer-packed');


var HEADER_SIZE = 11;
var SECRET_SIGN_PERIOD = rmtSessionKey.SECRET_SIGN_PERIOD;
var EXTRA_VERIFY_PERIOD = 5 * Constants.ONE_YEAR_IN_SEC * 1000;
var HMAC_CHECKSUM_SIZE = 20;
var IPE_VERSION = 1;
var DEFAULT_DISCREPANCY = 5 * 1000;
var NO_FLAGS = 0;
var EXPIRATION = 128;

/**
 * Compute the size of a buffer big enough to hold the cookielets.
 */
function computeBufferSize(ebayCookie, flags) {
    var sizeNeeded = 1;
    var headerSize = 4;
    if ((flags & EXPIRATION) !== 0) {
        headerSize = 8;
    }
    ebayCookie.forEachCookielet(function (cookielet) {
        if (cookielet.isValid()) {
            sizeNeeded += headerSize + Buffer.byteLength(cookielet.getValue() + '');
        }
    });
    return sizeNeeded += 4;    //checksum
}

// NOTE: We use unsigned integers even though Java is using signed integers.
//       This was a mistake in the Java stack that will hopefully be corrected
//       before we exceed the range of signed integers when using expiration
//       times (in seconds)
function encodeCookielets(ebayCookie, buf, flags, offset) {
    var writingExpiration = (flags & EXPIRATION) !== 0;
    var isSessionCookie = ebayCookie.isSession();
    ebayCookie.forEachCookielet(function (cookielet) {
        if (cookielet.isValid()) {
            buf.writeUInt16BE(cookielet.getId(), offset);
            // write the id
            offset += 2;
            var bytes = new Buffer(cookielet.getValue() + '');
            var length = bytes.length;
            buf.writeUInt16BE(length, offset);
            // length of the value
            offset += 2;
            if (writingExpiration) {
                // are we writing the default time into a session cookie?
                // At one time, this was an optimization that could have skipped writing
                // expiration in sesion cookies where they were all expiring at the
                // default time.  However, the SingleSignon project changed the value
                // for max age and gave session cookielets a long one.  Unfortunately,
                // they didn't change this logic at the same time (and the corresponding
                // place in V2 code) so the optimization is basically broken.  Without
                // finding the change in V2 and making it together, site behavior may
                // have unexpected results.
                if (isSessionCookie && cookielet.getMaxAge() === Constants.DEFAULT_MAX_AGE) {
                    // then, we can use -1 as a placeholder value
                    buf.writeInt32BE(-1, offset);
                } else {
                    var expiryTime = cookielet.getExpiryTime();
                    buf.writeInt32BE(expiryTime === null || expiryTime === undefined ? -1 : expiryTime, offset);
                }
                offset += 4;
            }
            // now write the value, encoded as UTF-8 bytes
            bytes.copy(buf, offset, 0);
            offset += length;
        }
    });
    return offset;
}

function parseCookieletPayload(ebayCookie, payload, offset, len, flags) {
    var pos = offset;
    var limit = offset + len;
    var readExp = (flags & EXPIRATION) !== 0;
    // pick off the cookielets
    while (pos < limit) {
        var cid = payload.readUInt16BE(pos);
        pos += 2;
        var clen = payload.readUInt16BE(pos);
        pos += 2;
        var exp = 0;
        if (readExp) {
            exp = payload.readInt32BE(pos);
            pos += 4;
        } else {
            exp = -1;
        }
        var cval = payload.slice(pos, pos + clen).toString('utf8');
        pos += clen;
        var cookieletMeta = Cookies[cid];
        if (cookieletMeta) {
            var cookielet = new EbayCookielet(cookieletMeta, cval);
            // since the cookielet max age comes from the constructor call in
            // EbayCookieDefinition, extract it.  This is really kind of gross
            // but until we do the clean up that builds this info out of metadata,
            // I don't want to introduce another way that this information is defined.
            if (exp !== -1) {
                cookielet.setExpiryTime(exp);
            }
            ebayCookie.addCookielet(cookielet);
        } else {
            calUtil.createWarnEvent('Unrecognized cookielet with ID: "' + cid + '" in cookie "' + ebayCookie.meta.name + '"');
            ebayCookie.removeAllCookielets(); // clear cookielets per https://jirap.corp.ebay.com/browse/REGSTRN-13167
            ebayCookie.setValid(false);
        }
    }
}

function wrap(buf, channelId, offset, sessionKey) {
    if (!sessionKey) {
        throw new Error('IPE sessionKey is not ready before cookie serialization!');
    }
    var buffer = new Buffer(HEADER_SIZE + offset + HMAC_CHECKSUM_SIZE);
    // write the version
    buffer.writeUInt8(IPE_VERSION, 0);
    var secretId = sessionKey.id;
    var mode = 4294967296;
    var firstPart = Math.floor(secretId / mode);
    var secondPart = secretId % mode;
    buffer.writeUInt32BE(firstPart, 1);
    buffer.writeUInt32BE(secondPart, 5);
    //write channelId
    buffer.writeUInt16BE(channelId, 9);
    //write the cookie value
    buf.copy(buffer, HEADER_SIZE, 0, offset);
    var hmac = crypto.createHmac('sha1', new Buffer(sessionKey.secretValue, 'base64'));
    hmac.update(buffer.slice(0, offset + HEADER_SIZE));
    hmac.digest().copy(buffer, HEADER_SIZE + offset, 0, HMAC_CHECKSUM_SIZE);
    return buffer;
}

function getChannelId(ebayCookie) {
    return ebayCookie.meta === Cookies.SESSION ? 5 : 6;
}

function wrapIPE(ebayCookie, buf, offset) {
    // Get the cookie bytes so far (flags + payload) and generate IPE containing it
    buf = wrap(buf, getChannelId(ebayCookie), offset, rmtSessionKey.getSessionKeySync());
    var encodedString = buf.toString('base64').replace(/\=/g, '*');
    // return encoded string prepended with ID
    return consts.FORMAT_PACKED_IPE + encodedString;
}

function wrapCRC32(ebayCookie, buf, offset) {
    // Get the cookie bytes so far (flags + payload) and compute CRC32
    // checksum.  Then add it to the byte stream.
    buf.writeUInt32BE(crc32.unsigned(buf.slice(0, offset)), offset);
    var encodedString = buf.toString('base64').replace(/\=/g, '*');
    // return encoded string prepended with ID
    return consts.FORMAT_PACKED_CRC32 + encodedString;
}

function decodeWithCRC32(ebayCookie, encodedBytes) {
    if (crc32.unsigned(encodedBytes.slice(0, encodedBytes.length - 4)) !== encodedBytes.readUInt32BE(encodedBytes.length - 4)) {
        calUtil.createWarnEvent('CRC32 check failed for: ' + ebayCookie.meta.idName);
        ebayCookie.setValid(false);
    } else {
        parseCookieletPayload(ebayCookie, encodedBytes, 1, encodedBytes.length - 5, encodedBytes.readUInt8(0));
        // One last thing to check... This is the "insecure" CRC format, so it should
        // never contain any cookielets identified as being "secure".  Check that this
        // is true.  If the result list contains any "secure" cookielets, then we need
        // to discard all the cookielets and return an empty list.
        ebayCookie.forEachCookielet(function (cookielet) {
            if (cookielet.needsSecurity()) {
                ebayCookie.removeAllCookielets();
                calUtil.createWarnEvent('CRC32 signatured cookie ' + ebayCookie.meta.idName + ' contains a secure cookielet: ' + cookielet.meta.idName);
                ebayCookie.setValid(false);
                return;
            }
        });
    }
}

function validateIPE(ebayCookie, callback) {
    var cookie = ebayCookie._rawCookie;
    var cookieString = cookie.getValue() + '';
    debug('validating cookie: ' + ebayCookie.meta.name);
    debug('cookie value is: ' + cookieString);

    var encodedBytes = new Buffer(cookieString.substring(1).replace(/\*/g, '='), 'base64');
    var hasError = false,
        version,
        secretId,
        expirationTime,
        now = Date.now();
    if (encodedBytes.length < HEADER_SIZE + HMAC_CHECKSUM_SIZE) {
        hasError = true;
        calUtil.createWarnEvent('IPE encoded cookie has length less than IPE overhead: ' + encodedBytes.length);
    }

    if (!hasError) {
        version = encodedBytes.readUInt8(0);
        if (version !== IPE_VERSION) {
            hasError = true;
            calUtil.createWarnEvent('IPE encoded cookie has unexpected version value: ' + version);
        }
    }

    if (!hasError) {
        secretId = encodedBytes.readUInt32BE(1) * 4294967296 + encodedBytes.readUInt32BE(5);
        if (secretId > now + DEFAULT_DISCREPANCY) {
            hasError = true;
            calUtil.createWarnEvent('Secret from the future:' + secretId + ' > ' + now);
        }
    }

    if (!hasError) {
        expirationTime = secretId + SECRET_SIGN_PERIOD + EXTRA_VERIFY_PERIOD;
        if (expirationTime < now - DEFAULT_DISCREPANCY) {
            hasError = true;
            calUtil.createWarnEvent('Secret too old: ' + secretId + ', now: ' + now);
        }
    }

    if (!hasError) {
        var channelId = encodedBytes.readUInt16BE(9);
        var expectedChannel = getChannelId(ebayCookie);
        if (channelId !== expectedChannel) {
            hasError = true;
            calUtil.createWarnEvent('Wrong channel, expected ' + expectedChannel + ', received: ' + channelId);
        }
    }

    if (!hasError) {
        retrieveAndValidateSessionKey(ebayCookie, encodedBytes, secretId, callback);
    } else {
        ebayCookie.setValidated(true);
        ebayCookie.removeAllCookielets();
        ebayCookie.setValid(false);
        callback && callback(null, false);
        return;
    }
}

function retrieveAndValidateSessionKey(ebayCookie, encodedBytes, secretId, callback) {
    rmtSessionKey.getSessionKeyAsync(secretId, function (error, sessionKey) {
        var now = Date.now();
        if (secretId && secretId < now - 4 * Constants.ONE_YEAR_IN_SEC * 1000) {
            var warnMessage = 'Cookie is 4 years old. Failed to get session key for validation! Cookie Name: ' + ebayCookie.meta.name;
            calUtil.createWarnEvent(warnMessage);
        }
        else if (error) {
            var errorMessage = 'Failed to get session key for validation! Cookie Name: ' + ebayCookie.meta.name + '. Error: ' + error.message + '. Stack: ' + error.stack;
            calUtil.createErrorEvent(errorMessage);
        } else if (sessionKey) {
            debug('The session key is ', sessionKey);
            var hmac = crypto.createHmac('sha1', new Buffer(sessionKey.secretValue, 'base64'));
            var cookieValue = encodedBytes.slice(0, encodedBytes.length - HMAC_CHECKSUM_SIZE);
            hmac.update(cookieValue);
            var expectedSig = hmac.digest();
            var actualSig = encodedBytes.slice(encodedBytes.length - HMAC_CHECKSUM_SIZE);
            if (expectedSig.toString('base64') === actualSig.toString('base64')) {
                ebayCookie.setValidated(true);
                callback && callback(null, true);
                return;
            } else {
                calUtil.createWarnEvent('IPE signature check fail for  ' + ebayCookie.meta.name);
            }
        } else {
            calUtil.createWarnEvent('Failed to get sessionkey for secretId: ' + secretId);
        }
        ebayCookie.setValidated(true);
        ebayCookie.removeAllCookielets();
        ebayCookie.setValid(false);
        callback && callback(error, false);
        return;
    });
}

function decodeWithIPE(ebayCookie, encodedBytes) {
    //An IPE will will have 31 bytes of header and digest plus flag byte and at least one cookielet
    if (encodedBytes.length < 36) {
        calUtil.createWarnEvent('Invalid length for IPE cookie: ' + encodedBytes.length);
        ebayCookie.setValid(false);
    } else {
        // get the payload by striping off the header and digest.  This is kind of
        // gross, but the bypass should only be used in testing and utilities never on
        // the site.  The header is the first 11 bytes and the digest is the last 20
        // bytes, so the payload is 31 bytes shorter then the bytes and we want to
        // start copying at index 11. And the first byte is flags, so the offset is 12
        debug('IPE decoding, but not verified. cookie: ' + ebayCookie.meta.name);
        parseCookieletPayload(ebayCookie, encodedBytes, HEADER_SIZE + 1, encodedBytes.length - HEADER_SIZE - HMAC_CHECKSUM_SIZE - 1, encodedBytes.readUInt8(HEADER_SIZE));
        ebayCookie.setValidated(false);
        ebayCookie.setValidator(validateIPE);
    }
}

module.exports = {
    serialize: function (ebayCookie) {
        var secureCookielets = false;
        var flags = NO_FLAGS;
        ebayCookie.forEachCookielet(function (cookielet) {
            if (cookielet.isValid()) {
                // Does this cookielet force the use of expiration times?
                if (!ebayCookie.isSession() || cookielet.getMaxAge() !== Constants.DEFAULT_MAX_AGE) {
                    // must set expirations in cookielet payload
                    flags |= EXPIRATION;
                }
                // Does this cookielet require secure hash?
                if (cookielet.needsSecurity()) {
                    secureCookielets = true;
                }
            }
        });
        var bufSize = computeBufferSize(ebayCookie, flags);
        if (bufSize <= 1) {
            // no valid cookies, return null
            return null;
        }
        var buf = new Buffer(bufSize);
        // write the flag byte
        buf.writeUInt8(flags, 0);
        var offset = encodeCookielets(ebayCookie, buf, flags, 1);
        if (secureCookielets) {
            return wrapIPE(ebayCookie, buf, offset);
        } else {
            return wrapCRC32(ebayCookie, buf, offset);
        }
    },
    deserialize: function (ebayCookie, cookie) {
        var cookieString = cookie.getValue() + '';
        var encodedBytes;
        if (cookieString.length > 1) {
            encodedBytes = new Buffer(cookieString.substring(1).replace(/\*/g, '='), 'base64');
            var formatChar = cookieString.charAt(0);
            if (formatChar === consts.FORMAT_PACKED_IPE) {
                decodeWithIPE(ebayCookie, encodedBytes);
            } else if (formatChar === consts.FORMAT_PACKED_CRC32) {
                decodeWithCRC32(ebayCookie, encodedBytes);
            }
        } else {
            calUtil.createWarnEvent('Invalid length for packed cookie: ' + cookieString.length);
            ebayCookie.setValid(false);
        }
    },
    retrieveAndValidateSessionKey: retrieveAndValidateSessionKey
};

