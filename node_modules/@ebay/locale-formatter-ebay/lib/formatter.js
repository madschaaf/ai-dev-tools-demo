"use strict";
var Money = require('./Money'),
    cf = require('./formats/currencyFormat'),
    df = require('./formats/decimalFormat'),
    nf = require('./formats/numberFormat'),
    dtf = require('./formats/dateTimeFormat'),
    fmUtil = require('./formatUtil'),
    cPattern = fmUtil.currencyPatterns,
    moment = require('moment-timezone'),
    mValidator = require('./validator/moneyValidator');

function formatMoney (amount, currencyCode, locale, options) {

    options = options || {};
    options.emitInternalDecimal = options.emitInternalDecimal || false;
    options.currencySymbolType = options.currencySymbolType || "standard";
    locale = locale || "en_US";
    var resp = {
        format : "",
        currencySymbol: "",
        error : null
    };
    //convert Currency code to UPPER case
    currencyCode = currencyCode && currencyCode.toUpperCase();
    //Validate the amount and Currency
    var error = mValidator(amount, currencyCode);
    if (error) {
        resp.error = error;
        return resp;
    }


    var money = new Money(amount, currencyCode, options.decimal),
        minorUnit = money.getValueInMinorUnits(),
        currencyDec = money.getDecimal(),
        //Get Currency and decimal formats
        currencyFormat = cf(locale, currencyCode),
        decimalFormat = df(locale),
        groupingDig = decimalFormat.getGroupingDigits(),
        currPattern = currencyFormat.getCurrencyPattern(),
        patternStr = currPattern.pattern,
        matcher = currPattern.matcher,
        deferredMinus = false,
        currSymbol = currencyFormat.getStandardCurrencySymbol();

    //Validate the Standard Currency symbol- If not found exit with proper error.
    if (!currSymbol) {
        resp.error = "Currency format is not found for the currency code " + currencyCode;
        return resp;
    }

    //Check for deferred minus sign
    if (money.isNegative() && (patternStr === cPattern.Sn.pattern ||
        patternStr === cPattern.Sen.pattern)) {

        deferredMinus = true;
    }
    //Option to emit the Money internal decimal value
    if (options.emitInternalDecimal) {
        minorUnit = money.getInternalVal();
        currencyDec = money.getInternalDecimal();
    }

    //Convert the Money value to string
    var valueStr = fmUtil.stringify(minorUnit, currencyDec, {
        groupingUsed : groupingDig > 0,
        grouping : groupingDig,
        groupingChar : decimalFormat.getGroupingChar(),
        decimalChar : decimalFormat.getDecimalChar(),
        signSuffix : false
    });

    //Remove the sign if deffred minus
    if (deferredMinus) {
        valueStr = valueStr.substring(1);
    }

    if ((/SYMBOL/i).test(options.currencySymbolType)) {
        currSymbol = currencyFormat.getWorldCurrencySymbol() || currencyFormat.getSimpleCurrencySymbol();
    } else if ((/SIMPLE/i).test(options.currencySymbolType)) {
        currSymbol = currencyFormat.getSimpleCurrencySymbol();
    } else if ((/FANCY/i).test(options.currencySymbolType)) {
        currSymbol = currencyFormat.getFancyCurrencySymbol();
    } else {
        currSymbol = currencyFormat.getStandardCurrencySymbol();
    }

    var formatStr = matcher({
        value : valueStr,
        symbol : currSymbol,
        deferredMinus : deferredMinus
    });
    resp.currencySymbol = currSymbol;
    resp.format = formatStr;

    return resp;
}

function formatNumber (number, locale, options) {
    if (locale !== undefined && typeof locale === 'object') {
        // locale is options object
        options = locale;
        locale = "en_US";
    }

    options = options || {};
    locale = locale || "en_US";

    var resp = {
            format : "",
            error : null
        };

    if (number === undefined) {
        resp.error = "Undefined number";
    }

    //Validate it is a number
    if (isNaN(parseFloat(number))) {
        resp.error = "Invalid number";
    }

    if (resp.error) {
        return resp;
    }

    var numberFormat = nf(locale);
    var groupingChar = numberFormat.getGroupingChar();

    // this gets rendered as 0 for some reason when it should be '\u00A0'
    if (groupingChar === 0) {
        groupingChar = '\u00A0';
    }

    var decimalChar = numberFormat.getDecimalChar();

    number = number.toString().split('.');
    var integer = number[0];
    var decimal = number[1] || "";

    if (options.fractionDigits !== undefined) {
        decimal = decimal.slice(0, options.fractionDigits);
    }

    if (decimal.length < options.fractionDigits) {
        decimal = decimal + "0".repeat(options.fractionDigits - decimal.length);
    }

    integer = integer.replace(/\B(?=(\d{3})+(?!\d))/g, groupingChar); // add grouping delimiter

    resp.format = integer + (decimal ? decimalChar + decimal : '');

    return resp;
}

function formatDateTime (date, locale, options) {
    options = options || {};
    options.dateTimeOutput = options.dateTimeOutput || "both";
    options.dateFormatType = options.dateFormatType || "medium";
    options.timeFormatType = options.timeFormatType || "long";
    options.timeZone = options.timeZone || null;
    locale = locale || "en_US";
    const resp = {
        dateFormat : "",
        timeFormat : "",
        error : null
    };
    const dateTimeFormat = dtf(locale);
    let dateMoment = moment(date, undefined, locale);

    // If timeZone not passed from user, user defalts moment timeZone
    if(options.timeZone !== null) {
        dateMoment = dateMoment.tz(options.timeZone);
    }

    //Validate date and formatConf
    if (!date) {
        resp.error = "Undefined date";
    }
    if (!dateMoment.isValid()) {
        resp.error = "Invalid date";
    }
    if (resp.error) {
        return resp;
    }
    //If not 'timeonly' output format
    if (!(/timeonly/i).test(options.dateTimeOutput)) {
        formatDate(dateMoment, dateTimeFormat, options, resp);
    }
    //If not 'dateonly' output format
    if (!(/dateonly/i).test(options.dateTimeOutput)) {
        formatTime(dateMoment, dateTimeFormat, options, resp);
    }
    return resp;
}

function formatDate (dateMoment, dateTimeFormat, options, resp) {

    var datePatterns = fmUtil.datePatterns,
        pattern = datePatterns[options.dateFormatType],
        dateFormatStr;

    if (!pattern) {
        resp.error = `Invalid date format type:${options.dateFormatType}`;
        return;
    }
    dateFormatStr = pattern.matcher(dateTimeFormat);
    resp.dateFormat = dateMoment.format(dateFormatStr);
}

function formatTime (dateMoment, dateTimeFormat, options, resp) {

    var timePatterns = fmUtil.timePatterns,
        pattern = timePatterns[options.timeFormatType],
        timeFormatStr;

    if (!pattern) {
        resp.error = "Invalid time format type";
        return;
    }
    timeFormatStr = pattern.matcher(dateTimeFormat);
    resp.timeFormat = dateMoment.format(timeFormatStr);
}

exports = module.exports = {
    formatMoney : formatMoney,
    formatDateTime : formatDateTime,
    formatNumber : formatNumber
};
