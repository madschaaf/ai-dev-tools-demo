'use strict';

var ResolvedContent = require('./ResolvedContent');
var utils = require('./utils');
var integerRegExp = /^\d+$/;

// define default formatters for browser side
var defaultFormatters = {
    'ph': require('../formatters/ph'),
    'tag:DPH': require('../formatters/dph'),
    'simple': require('../formatters/simple'),
    'complex': require('../formatters/complex'),
    'tag': require('../formatters/tag')
};

function resolve(contentBundle, path) {
    path = path.replace(/\//g, '.');
    var resolvedCache = contentBundle._resolvedCache;
    var target = contentBundle._target;
    var bundleName = contentBundle._bundleName;

    var key = (target ? target + ':' : '') + (path || '.');

    //Sample path: FeedbackStarAltMessage/6
    var resolvedContent = resolvedCache[key];
    if (resolvedContent === undefined) {
        var current = contentBundle._rawBundle;

        var subParts = path.split('.');

        for (var i = 0, len = subParts.length; i < len; i++) {
            if (!current) {
                break;
            }

            var subPart = subParts[i];
            if (subPart === '') {
                break;
            }

            var arrayIndex = null,
                arrayStart = subPart.lastIndexOf('['),
                arrayEnd;

            if (arrayStart !== -1) {
                arrayEnd = subPart.lastIndexOf(']');
                if (arrayEnd !== -1) {
                    var arrayIndexStr = subPart.substring(arrayStart+1, arrayEnd);
                    if (integerRegExp.test(arrayIndexStr)) {
                        arrayIndex = parseInt(arrayIndexStr, 10);
                    } else {
                        arrayIndex = arrayIndexStr;
                    }

                    subPart = subPart.substring(0, arrayStart);
                }
            }

            current = current[subPart];

            if (arrayIndex != null && current) {
                current = current[arrayIndex];
            }
        }

        if (current) {
            if (current['@target']) {
                current = utils.select(current, target);
            }

            if (Array.isArray(current)) {
                current = current.map(function(child, i) {
                    return new ResolvedContent(child, path + '[' + i + ']', bundleName);
                });
            } else if (typeof current === 'object') {
                var converted = {};

                for (var k in current) {
                    if (current.hasOwnProperty(k)) {
                        converted[k] = new ResolvedContent(current[k], path + '[' + k + ']', bundleName);
                    }
                }
                current = converted;
            } else {
                current = new ResolvedContent(current, path, bundleName);
            }
        } else {
            current = null;
        }

        resolvedCache[key] = resolvedContent = current;
    }

    return resolvedContent;
}

function sameLocality(a, b) {
    if (a === b) {
        return true;
    }
    // normalize
    a = a || {};
    b = b || {};

    // normalize time zone properties
    var azone = a.timezone || a.timeZone;
    var bzone = b.timezone || b.timeZone;
    // so far we have only difference by timezone to compare
    if (azone !== bzone) {
        return false;
    }

    // check if any of required properties do no match, some will return true, then return false|opposite
    // comparing by ref or primitive
    return !['isoCurrencyCode', 'locale'].some(function (name) {
        return a[name] !== b[name];
    });
}

function ContentBundle(options) {
    this._rawBundle = options.rawBundle;
    this._resolvedCache = {};
    this._bundleName = options.bundleName;
    this._target = options.target;
    this._formatters = Object.assign({}, defaultFormatters, options.formatters);
    this._locality = options.locality;
}

ContentBundle.prototype = {
    localize: function (lookupContext) {
        // we do not need to compare locale or target, only locality
        // as we already cache bundle by target and locale
        // we want to save on caching the same things due to locality
        // so we better create a "proxy"
        if (sameLocality(this._locality, lookupContext.locality)) {
            return this;
        }

        var bundle = new ContentBundle({});
        Object.keys(this).forEach(function (key) {
            if (key.startsWith('_')) {
                bundle[key] = this[key];
            }
        }.bind(this));
        bundle._locality = lookupContext.locality;
        return bundle;
    },

    get: function get(path, data, context) {
        var resolvedContent = resolve(this, path);
        if (resolvedContent) {
            context = this.mergeContext(context);

            if (data) {
                return resolvedContent.get(data, context);
            }
            else {
                if (resolvedContent instanceof ResolvedContent) {
                    resolvedContent = resolvedContent.resolve(context);
                }
                else if (Array.isArray(resolvedContent)) {
                    resolvedContent = resolvedContent.map(function (itm) {
                        return itm.resolve(context);
                    });
                }
                else { // map
                    resolvedContent = Object.keys(resolvedContent).reduce(function (memo, key) {
                        memo[key] = resolvedContent[key].resolve(context);
                        return memo;
                    }, {});
                }
            }
        }
        return resolvedContent;
    },

    getText: function getText(path, data, context) {
        var resolvedContent = resolve(this, path);
        return resolvedContent ? resolvedContent.getText(data, this.mergeContext(context)) : null;
    },

    mergeContext: function (context) {
        var defaultCtx = {
            target: this._target,
            formatters: this._formatters,
            locality: this._locality
        };

        if (context) {
            var formatters = Object.assign({}, defaultCtx.formatters, context.formatters);
            return Object.assign(defaultCtx, context, {
                formatters: formatters
            });
        }
        return defaultCtx;
    }
};

ContentBundle.prototype.resolve = ContentBundle.prototype.get;

module.exports = ContentBundle;
