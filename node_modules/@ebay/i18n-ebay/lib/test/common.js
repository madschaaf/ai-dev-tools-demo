const { promisify } = require("node:util");
const fswalk = require("@nodelib/fs.walk/promises");
const i18n = require("../../");
const i18nManagerProvider = require("../manager-provider");
const path = require("node:path");

/**
 * @private
 */
const findBundles = (dirname, locale) =>
    fswalk
        .walk(path.join(dirname, locale), {
            entryFilter: (entry) =>
                entry.dirent.isFile() && entry.name.endsWith(".properties"),
        })
        .then((entries) => entries.map((entry) => entry.path));

/**
 * Recursively search the disk looking for bundle names from the provided
 * dirname & locale.
 * @private
 */
const getAllBundleNames = (dirname, locale) =>
    findBundles(dirname, locale)
        .then((propertiesFilenames) =>
            propertiesFilenames.map((filename) =>
                filename
                    .replace(".properties", "")
                    .split("/")
                    .slice(-2)
                    .join("/")
            )
        )
        .then((it) => it.sort());

export const createI18NBundlePreloader =
    ({ contentManager }) =>
    async (opts) => {
        const {
            allowMissing = false,
            bundleNames = [],
            localesDirname = "locales",
            locale = "en",
        } = opts ?? {};

        const names = bundleNames.length
            ? bundleNames
            : await getAllBundleNames(localesDirname, locale);

        const getBundlePromise = promisify(
            contentManager.getBundle.bind(contentManager)
        );

        const preloadBundle = (name, localesDirname) =>
            getBundlePromise(name, localesDirname).then(
                (bundle) => {
                    contentManager.preloaded[name] = bundle;
                },
                (err) => {
                    if (allowMissing) {
                        return;
                    }
                    throw err;
                }
            );

        const dedupedNames = [...new Set(names)];
        await Promise.all(
            dedupedNames.map((name) => preloadBundle(name, localesDirname))
        );
    };

export const bindGlobalContentManager = async ({
    fromLocalityOptions,
} = {}) => {
    const contentManager = i18nManagerProvider.fromLocality({
        country: "US",
        locale: "en-US",
        ...fromLocalityOptions,
    });

    const getProvider = () => contentManager;

    i18nManagerProvider.getOptional = getProvider;
    i18n.getContentManager = getProvider;

    return contentManager;
};
