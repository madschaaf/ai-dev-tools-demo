'use strict';

var spud = require('spud');
var nodePath = require('path');
var fs = require('fs');
var ContentBundle = require('./ContentBundle');

const Async = require('async');
var modConfig = require('@ebay/module-config-inc');
var DataHolder = require('raptor-async/DataHolder');
var cache = {};
var rawBundleCache = {};

var cwd = process.cwd();

function localeToPath(locale) {
    if (!locale) {
        return '';
    }

    var localeParts = locale.split(/[-_]/, 2);
    if (localeParts.length > 1) {
        var country = localeParts[1];
        var lang = localeParts[0];
        return country + '/' + lang;
    }
    return locale;
}

function loadRawBundle(path, callback) {
    var rawBundleDataHolder = rawBundleCache[path];
    if (rawBundleDataHolder) {
        return rawBundleDataHolder.done(callback);
    }

    rawBundleDataHolder = rawBundleCache[path] = new DataHolder();

    rawBundleDataHolder.done(callback);

    fs.exists(path, function(exists) {
        if (!exists) {
            rawBundleDataHolder.resolve(null);
            return;
        }

        spud.deserialize(
            fs.createReadStream(path),
            'properties',
            function (err, rawBundle) {
                if (err) {
                    rawBundleDataHolder.reject(err);
                    return;
                }

                rawBundleDataHolder.resolve(rawBundle);
            });
    });
}

function loadBundleInternal(options, callback) {
    var bundleName = options.bundleName;
    var localesDir = options.localesDir;
    var locales = options.locales;
    var target = options.target;
    var formatters = options.formatters;
    var locality = options.locality;

    var currentLocaleIndex = -1;

    function tryNextLocale() {
        currentLocaleIndex++;

        if (currentLocaleIndex >= locales.length) { 
            const err = Object.assign(new Error(`Content bundle not found (bundleName=${
                bundleName}, locales=[${locales.join(', ')}])`), {
                    code: 'NotFound'
                });
            return callback(err);
        }

        var locale = locales[currentLocaleIndex];

        var bundlePath = nodePath.resolve(localesDir, localeToPath(locale), bundleName);

        var filePath = bundlePath + '.properties';

        loadRawBundle(filePath, function(err, rawBundle) {
            if (err) {
                return callback(err);
            }

            if (!rawBundle) {
                tryNextLocale();
                return;
            }

            var contentBundle = new ContentBundle({
                rawBundle: rawBundle,
                filePath: filePath,
                target: target,
                formatters: formatters,
                locality
            });
            callback(null, contentBundle);
        });
    }

    tryNextLocale();
}

var resolveLocalesDirCache = {};

function resolveLocalesDir(from) {
    var resolvedPath = resolveLocalesDirCache[from];

    if (resolvedPath === undefined) {

        from = from ? nodePath.resolve(cwd, from) : process.cwd();
        var currentDir = from;
        while (currentDir) {
            var localesDir = nodePath.join(currentDir, 'locales');

            if (fs.existsSync(localesDir)) {
                resolvedPath = localesDir;
                break;
            }

            var parentDir = nodePath.dirname(currentDir);
            if (parentDir === currentDir || !parentDir) {
                break;
            }

            currentDir = parentDir;
        }

        resolvedPath = resolveLocalesDirCache[from] = resolvedPath || null;
    }



    if (resolvedPath === null) {
        throw new Error('Unable to find the "locales" directory relative to "' + from + '"');
    }

    return resolvedPath;
}

function resolveFormatters(formatters) {
    Object.keys(formatters || {}).forEach(function (name) {
        var formatter = formatters[name];
        if (typeof formatter === 'string') {
            formatters[name] = require(formatter);
        }
    });

    return formatters;
}

exports.loadRawBundle = loadRawBundle;

exports.loadBundle = function loadBundle(bundleName, lookupContext, from, cb) {
    if (!lookupContext) {
        lookupContext = {};
    }

    const target = lookupContext.target;
    const localesDir = resolveLocalesDir(from);

    const dir = nodePath.resolve(__dirname, '..');
    modConfig(dir, function (_, config) {
        const defaultLocale = config.get('i18n-ebay:default-locale') || 'en';
        const miniSites = config.get('i18n-ebay:mini-sites');
        const formatters = Object.assign({}, resolveFormatters(
            config.get('i18n-ebay:formatters')), undefined);
        const onlySiteSupportLanguages = config.get('i18n-ebay:onlySiteSupportLanguages');
        /**
         * onlySiteSupportLanguages flag is used along with acceptLanguages ony and has 3 possible options: 
         *  - undefined - accept languages are disabled
         *  - true - only allow supported languages
         *  - false - turn off and allow all languages
         */
        if (lookupContext.acceptLanguages) {
            // we need to iterate the chain of languages till
            // the required content bundle is found
            let languages; // de-dup duplicate values
            if (onlySiteSupportLanguages === false) {
                languages = lookupContext.acceptLanguages.reduce((expand, lang) => {
                    expand.add(lang);
                    if (lang === 'en-US') {
                        expand.add('en');
                    }
                    return expand;
                }, new Set());
            }
            else if (onlySiteSupportLanguages === true) {
                const supportedLanguages = lookupContext.locality.supportedLanguages || [];
                const allowedLanguages = lookupContext.acceptLanguages.filter(
                    lang => supportedLanguages.includes(lang));
                languages = new Set(allowedLanguages);
            }
            // then add fallback to parent language
            const parentLocale = miniSites && miniSites[lookupContext.locale];
            parentLocale && languages.add(parentLocale);
            // and fallback to default language
            languages.add(lookupContext.locale);

            // now do resolve
            Async.eachSeries([...languages], (language, next) => {
                resolve(language, false, (err, bundle) => {
                    if (bundle) {
                        cb(null, bundle);
                        return;
                    }
                    if (err.code === 'NotFound') {
                        // continue search
                        next();
                        return;
                    }
                    // unexpected error happened, stop the search
                    cb(err);
                });
            }, () => {
                // here we get only if no bundles found
                resolve(defaultLocale, false, cb);
            });
            return;
        }

        // original resolve before acceptLanguages introduction in this code
        // we fallback to default language
        resolve(lookupContext.locale, true, cb);

        function resolve(locale, fallbackToDefault, callback) {
            const cacheKey = bundleName + '/' + localesDir + '/' + fallbackToDefault + '/' + locale + '/' + (target || '');
            const callbackWrapper = (err, bundle) => {
                if (bundle) {
                    bundle = bundle.localize(lookupContext);
                }
                callback(err, bundle);
            };
        
            let bundleDataHolder = cache[cacheKey];
            if (bundleDataHolder) {
                bundleDataHolder.done(callbackWrapper);
                return;
            }
        
            bundleDataHolder = cache[cacheKey] = new DataHolder();
        
            // Attach a listener for the callback
            bundleDataHolder.done(callbackWrapper);
            
            // here we form a constant fallback chain that is cached under
            // the same primary locale passed to this resolve function
            const locales = [locale];
            if (fallbackToDefault) {
                const parentLocale = miniSites && miniSites[locale];
                parentLocale && locales.push(parentLocale);
                defaultLocale && locales.push(defaultLocale);    
            }
    
            loadBundleInternal({
                bundleName,
                localesDir,
                locales,
                target,
                formatters,
                locality: lookupContext.locality
            }, function(err, bundle) {
                if (err) {
                    return bundleDataHolder.reject(err);
                }
    
                bundleDataHolder.resolve(bundle);
            });
        }
    });
};
