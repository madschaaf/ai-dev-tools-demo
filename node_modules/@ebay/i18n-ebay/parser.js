'use strict';

const varRegExp = /\{\s*([A-Za-z0-9_\-\.\(\)]+)(\s*,\s*([A-Za-z0-9_\-\.]+)\s*(\(\s*([^\)\(\}]+)?\s*\)\s*)?)?\}|<([\:A-Za-z0-9_\.]+)((?:\s+[\w_-]+="[^>"]*")+)?\s*(\/)?>|<\/([\:A-Za-z0-9_\.]+)>/g;
const phRegExp = /\{\s*([A-Za-z0-9_\-\.\(\)]+)(\s*,\s*([A-Za-z0-9_\-\.]+)\s*(\(\s*([^\)\(\}]+)?\s*\)\s*)?)?\}/g;
const tagAttrsRegExp = /\s+(\w+="[^"]+"|\w+='[^']+'|\w+=[^\s]+)+/;

class Content {
    constructor(contentType) {
        this.contentType = contentType;
    }

    resolve(data, context) {
        const format = context && context.formatters[this.contentType];
        if (!format) {
            throw new Error(`Cannot find formatter for content element "${this.contentType}"`);
        }
        return format(this, data, context);
    }
}

/*
    For dynamic placeholders we need to support
    Money,
    Number,
    Double,
    Date/time

    Complex placeholder like a/span/image/etc will be handle as tag placeholders and can be formatted later, if needed
*/
class PlaceHolder extends Content {
    constructor(name, type, options) {
        super('ph');
        this.name = name;
        this.type = type;
        this.options = options;
    }
}

class SimpleContent extends Content {
    constructor(text) {
        super('simple');
        this.text = text;
    }
}

class ComplexContent extends Content {
    constructor() {
        super('complex');
        this.children = [];
    }

    add(part) {
        this.children.push(part);
    }
}

class TagPart extends Content {
    constructor(name, attributes, closed) {
        super('tag');
        this.name = name;
        this.attributes = attributes || {};

        // DPH legacy code support
        if (/DPH:/.test(name)) {
            var nameParts = name.split(':');
            this.type = nameParts.shift();
            this.name = nameParts.join();
        }

        this.id = this.attributes.elementId || this.attributes.id || this.name;
        delete this.attributes.elementId;

        this.type = this.attributes.elementType || this.type || this.name;
        delete this.attributes.elementType;

        this.closed = closed;
        this.children = [];
    }

    add(part) {
        this.children.push(part);
    }
}

function parse(str, file) {
    varRegExp.lastIndex = 0;
    if (!str) {
        throw new Error('Content string is empty or undefined');
    }

    var content;

    var match;
    var current = 0;
    var tagStack = [];

    while(match = varRegExp.exec(str)) {
        if (!content) {
            content = new ComplexContent();
            tagStack.unshift(content);
        }

        var varName = match[1];
        var openTag =  match[6];
        var closeTag = match[8] === '/';

        // handle header text
        var textPart = match.input.substring(current, match.index);
        if (textPart) {
            tagStack[0].add(textPart);
        }
        // update current position to the end of placeholder
        current = varRegExp.lastIndex;

        // now handle placeholder
        if (varName !== undefined && varName !== null) {
            /*
             We support simple placeholder as well as complex
             Simple: Hello {user}
             Complex: Today is {now, date("timeFormat":"SHORT","dateFormat":1)}
            */
            var config = match[5] ? tryParse(match[5], file) : undefined;
            var formatter = match[3];
            var ph = new PlaceHolder(varName, formatter, config);
            tagStack[0].add(ph);
        }
        else if (openTag != null) {
            // get in-line tag attributes
            var tag = new TagPart(openTag, parseTagAttrs(match[7]), closeTag);
            tagStack[0].add(tag);
            if (!closeTag) {
                tagStack.unshift(tag);
            }
        }
        else if (match[9]) {
            var openTagMeta = tagStack.shift();
            while (openTagMeta && openTagMeta.name !== match[9] &&
                (openTagMeta.type +':'+ openTagMeta.name) !== match[9]) {
                    
                openTagMeta = tagStack.shift();
                // throw new Error('Close tag:' + match[9] + ' does not match open tag:' +
                // ((openTagMeta instanceof ComplexContent) && 'Container' || openTagMeta.name) +
                // ', content:' + str + ', file:' + file);
            }

            // remove current tag from the stack
            if (openTagMeta) {
                openTagMeta.dual = true;
            }
        }
    }

    if (content && current < str.length) {
        if (tagStack.length === 0) {
            throw new Error(`The content element has either single quotes used in html/custom tags or unmatching tags ${str}, file: ${file}`);
        }
        tagStack[0].add(str.substring(current));
    }

    return content || new SimpleContent(str);
}

function parseAttributeValue(val, file) {
    phRegExp.lastIndex = 0;
    var attrValue;
    var match;
    var current = 0;
    while(match = phRegExp.exec(val)) {
        attrValue = attrValue || [];
        var varName = match[1];

        // handle header text
        var textPart = match.input.substring(current, match.index);
        if (textPart) {
            attrValue.push(textPart);
        }
        // update current position to the end of placeholder
        current = phRegExp.lastIndex;

        // now handle placeholder
        if (varName !== undefined && varName !== null) {
            /*
             We support simple placeholder as well as complex
             Simple: Hello {user}
             Complex: Today is {now, date("timeFormat":"SHORT","dateFormat":1)}
            */
            var config = match[5] ? tryParse(match[5], file) : undefined;
            var type = match[3];
            var ph = new PlaceHolder(varName, type, config);
            attrValue.push(ph);
        }
    }

    if (attrValue && current < val.length) {
        attrValue.push(val.substring(current));
    }

    return attrValue || val;
}

function trim(str) {
    return str && str.replace(/^[\s]+|[\s]+$/g, '').replace(/^["']|["']$/g, '');
}

function tryParse(str, file) {
    var parsed = tryJSONParse('{' + str + '}', null);
    if (parsed !== null) {
        return parsed;
    }
    // otherwise let's use more tolerant parser
    try {
        var pairs = str.split(',');
        return pairs.reduce(function (acc, pair) {
            var keyVal = pair.split(':');
            if (keyVal.length > 1) {
                var key = trim(keyVal[0]);
                var val = trim(keyVal[1]);
                if (acc[key] !== undefined) {
                    throw new Error('Duplicate attribute found, key:' + key);
                }
                acc[key] = tryJSONParse(val, val);    
            }
            return acc;
        }, {});
    } catch (e) {
        throw new Error('Failed to parse attributes:\'' + str + '\', file:' + (file || 'unwknown') + ', error:' + e.stack);
    }
}

function tryJSONParse(str, defaultValue) {
    try {
        return JSON.parse(str);
    } catch (err) {
        return defaultValue;
    }
}

function parseTagAttrs(str) {
    var attributes = {};
    var dynamicAttributes;
    if (str) {
        tagAttrsRegExp.lastIndex = 0;
        var attrKvpsStr = str.split(tagAttrsRegExp);
        attrKvpsStr.forEach(function (kvpStr) {
            if (!kvpStr) {
                return;
            }
            var kvpParts = kvpStr.split('=');
            var key = kvpParts.shift().trim();
            var value = kvpParts.join('=').replace(/^['"]|['"]$/g, '');
            attributes[key] = parseAttributeValue(value);
            if (Array.isArray(attributes[key])) {
                dynamicAttributes = true;
            }
        });
    }
    if (dynamicAttributes) {
        attributes.$dynamicAttributes = dynamicAttributes;
    }
    return attributes;
}

module.exports = {
    parse,
    varRegExp,
    PlaceHolder,
    TagPart,
    ComplexContent,
    SimpleContent,
    tryParse
};
