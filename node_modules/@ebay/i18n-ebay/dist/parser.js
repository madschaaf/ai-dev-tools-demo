'use strict';

function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var varRegExp = /\{\s*([A-Za-z0-9_\-\.\(\)]+)(\s*,\s*([A-Za-z0-9_\-\.]+)\s*(\(\s*([^\)\(\}]+)?\s*\)\s*)?)?\}|<([\:A-Za-z0-9_\.]+)((?:\s+[\w_-]+="[^>"]*")+)?\s*(\/)?>|<\/([\:A-Za-z0-9_\.]+)>/g;
var phRegExp = /\{\s*([A-Za-z0-9_\-\.\(\)]+)(\s*,\s*([A-Za-z0-9_\-\.]+)\s*(\(\s*([^\)\(\}]+)?\s*\)\s*)?)?\}/g;
var tagAttrsRegExp = /\s+(\w+="[^"]+"|\w+='[^']+'|\w+=[^\s]+)+/;
var Content = /*#__PURE__*/function () {
  function Content(contentType) {
    _classCallCheck(this, Content);
    this.contentType = contentType;
  }
  return _createClass(Content, [{
    key: "resolve",
    value: function resolve(data, context) {
      var format = context && context.formatters[this.contentType];
      if (!format) {
        throw new Error("Cannot find formatter for content element \"".concat(this.contentType, "\""));
      }
      return format(this, data, context);
    }
  }]);
}();
/*
    For dynamic placeholders we need to support
    Money,
    Number,
    Double,
    Date/time

    Complex placeholder like a/span/image/etc will be handle as tag placeholders and can be formatted later, if needed
*/
var PlaceHolder = /*#__PURE__*/function (_Content) {
  function PlaceHolder(name, type, options) {
    var _this;
    _classCallCheck(this, PlaceHolder);
    _this = _callSuper(this, PlaceHolder, ['ph']);
    _this.name = name;
    _this.type = type;
    _this.options = options;
    return _this;
  }
  _inherits(PlaceHolder, _Content);
  return _createClass(PlaceHolder);
}(Content);
var SimpleContent = /*#__PURE__*/function (_Content2) {
  function SimpleContent(text) {
    var _this2;
    _classCallCheck(this, SimpleContent);
    _this2 = _callSuper(this, SimpleContent, ['simple']);
    _this2.text = text;
    return _this2;
  }
  _inherits(SimpleContent, _Content2);
  return _createClass(SimpleContent);
}(Content);
var ComplexContent = /*#__PURE__*/function (_Content3) {
  function ComplexContent() {
    var _this3;
    _classCallCheck(this, ComplexContent);
    _this3 = _callSuper(this, ComplexContent, ['complex']);
    _this3.children = [];
    return _this3;
  }
  _inherits(ComplexContent, _Content3);
  return _createClass(ComplexContent, [{
    key: "add",
    value: function add(part) {
      this.children.push(part);
    }
  }]);
}(Content);
var TagPart = /*#__PURE__*/function (_Content4) {
  function TagPart(name, attributes, closed) {
    var _this4;
    _classCallCheck(this, TagPart);
    _this4 = _callSuper(this, TagPart, ['tag']);
    _this4.name = name;
    _this4.attributes = attributes || {};

    // DPH legacy code support
    if (/DPH:/.test(name)) {
      var nameParts = name.split(':');
      _this4.type = nameParts.shift();
      _this4.name = nameParts.join();
    }
    _this4.id = _this4.attributes.elementId || _this4.attributes.id || _this4.name;
    delete _this4.attributes.elementId;
    _this4.type = _this4.attributes.elementType || _this4.type || _this4.name;
    delete _this4.attributes.elementType;
    _this4.closed = closed;
    _this4.children = [];
    return _this4;
  }
  _inherits(TagPart, _Content4);
  return _createClass(TagPart, [{
    key: "add",
    value: function add(part) {
      this.children.push(part);
    }
  }]);
}(Content);
function parse(str, file) {
  varRegExp.lastIndex = 0;
  if (!str) {
    throw new Error('Content string is empty or undefined');
  }
  var content;
  var match;
  var current = 0;
  var tagStack = [];
  while (match = varRegExp.exec(str)) {
    if (!content) {
      content = new ComplexContent();
      tagStack.unshift(content);
    }
    var varName = match[1];
    var openTag = match[6];
    var closeTag = match[8] === '/';

    // handle header text
    var textPart = match.input.substring(current, match.index);
    if (textPart) {
      tagStack[0].add(textPart);
    }
    // update current position to the end of placeholder
    current = varRegExp.lastIndex;

    // now handle placeholder
    if (varName !== undefined && varName !== null) {
      /*
       We support simple placeholder as well as complex
       Simple: Hello {user}
       Complex: Today is {now, date("timeFormat":"SHORT","dateFormat":1)}
      */
      var config = match[5] ? tryParse(match[5], file) : undefined;
      var formatter = match[3];
      var ph = new PlaceHolder(varName, formatter, config);
      tagStack[0].add(ph);
    } else if (openTag != null) {
      // get in-line tag attributes
      var tag = new TagPart(openTag, parseTagAttrs(match[7]), closeTag);
      tagStack[0].add(tag);
      if (!closeTag) {
        tagStack.unshift(tag);
      }
    } else if (match[9]) {
      var openTagMeta = tagStack.shift();
      while (openTagMeta && openTagMeta.name !== match[9] && openTagMeta.type + ':' + openTagMeta.name !== match[9]) {
        openTagMeta = tagStack.shift();
        // throw new Error('Close tag:' + match[9] + ' does not match open tag:' +
        // ((openTagMeta instanceof ComplexContent) && 'Container' || openTagMeta.name) +
        // ', content:' + str + ', file:' + file);
      }

      // remove current tag from the stack
      if (openTagMeta) {
        openTagMeta.dual = true;
      }
    }
  }
  if (content && current < str.length) {
    if (tagStack.length === 0) {
      throw new Error("The content element has either single quotes used in html/custom tags or unmatching tags ".concat(str, ", file: ").concat(file));
    }
    tagStack[0].add(str.substring(current));
  }
  return content || new SimpleContent(str);
}
function parseAttributeValue(val, file) {
  phRegExp.lastIndex = 0;
  var attrValue;
  var match;
  var current = 0;
  while (match = phRegExp.exec(val)) {
    attrValue = attrValue || [];
    var varName = match[1];

    // handle header text
    var textPart = match.input.substring(current, match.index);
    if (textPart) {
      attrValue.push(textPart);
    }
    // update current position to the end of placeholder
    current = phRegExp.lastIndex;

    // now handle placeholder
    if (varName !== undefined && varName !== null) {
      /*
       We support simple placeholder as well as complex
       Simple: Hello {user}
       Complex: Today is {now, date("timeFormat":"SHORT","dateFormat":1)}
      */
      var config = match[5] ? tryParse(match[5], file) : undefined;
      var type = match[3];
      var ph = new PlaceHolder(varName, type, config);
      attrValue.push(ph);
    }
  }
  if (attrValue && current < val.length) {
    attrValue.push(val.substring(current));
  }
  return attrValue || val;
}
function trim(str) {
  return str && str.replace(/^[\s]+|[\s]+$/g, '').replace(/^["']|["']$/g, '');
}
function tryParse(str, file) {
  var parsed = tryJSONParse('{' + str + '}', null);
  if (parsed !== null) {
    return parsed;
  }
  // otherwise let's use more tolerant parser
  try {
    var pairs = str.split(',');
    return pairs.reduce(function (acc, pair) {
      var keyVal = pair.split(':');
      if (keyVal.length > 1) {
        var key = trim(keyVal[0]);
        var val = trim(keyVal[1]);
        if (acc[key] !== undefined) {
          throw new Error('Duplicate attribute found, key:' + key);
        }
        acc[key] = tryJSONParse(val, val);
      }
      return acc;
    }, {});
  } catch (e) {
    throw new Error('Failed to parse attributes:\'' + str + '\', file:' + (file || 'unwknown') + ', error:' + e.stack);
  }
}
function tryJSONParse(str, defaultValue) {
  try {
    return JSON.parse(str);
  } catch (err) {
    return defaultValue;
  }
}
function parseTagAttrs(str) {
  var attributes = {};
  var dynamicAttributes;
  if (str) {
    tagAttrsRegExp.lastIndex = 0;
    var attrKvpsStr = str.split(tagAttrsRegExp);
    attrKvpsStr.forEach(function (kvpStr) {
      if (!kvpStr) {
        return;
      }
      var kvpParts = kvpStr.split('=');
      var key = kvpParts.shift().trim();
      var value = kvpParts.join('=').replace(/^['"]|['"]$/g, '');
      attributes[key] = parseAttributeValue(value);
      if (Array.isArray(attributes[key])) {
        dynamicAttributes = true;
      }
    });
  }
  if (dynamicAttributes) {
    attributes.$dynamicAttributes = dynamicAttributes;
  }
  return attributes;
}
module.exports = {
  parse: parse,
  varRegExp: varRegExp,
  PlaceHolder: PlaceHolder,
  TagPart: TagPart,
  ComplexContent: ComplexContent,
  SimpleContent: SimpleContent,
  tryParse: tryParse
};