'use strict';

var managerProvider = require('../lib/manager-provider');
var utils = require('../lib/utils');

function readContent (pluginContext, optimizerContext, callback) {
    var path = pluginContext.path;
    var from = pluginContext.getParentManifestDir();

    var contentManager = managerProvider.fromOptimizerContext(optimizerContext);
    var target = contentManager.getTarget();

    //sk: TODO need to get request here
    contentManager.getBundle(path, from, function (err, bundle) {
        if (err) {
            callback(err);
        } else {
            // NOTE: assume that bundle._rawBundle exists
            // filter out all non-matching current target
            var filteredBundleContent = utils.copy(bundle._rawBundle, target);

            callback(null,
                '(function (i18n) {' +
                    'i18n["' + path + '"] = ' + JSON.stringify(filteredBundleContent) + ';' +
                '}(window.$i18n || (window.$i18n = {})));'
            );
        }
    });
}

/*
 * The plugin support one propeprty that specifies project/bundle.
 * Example:
 *   {
 *      "dependencies": [
 *           "content: ProjectName/BundleName"
 *       ]
 *   }
 */
module.exports = {
    // Declare which properties can be passed to the dependency type
    properties: {
        'path': 'string'
    },

    // Validation checks and initialization based on properties:
    init: function () {
        if (!this.path) {
            throw new Error('"path" is required');
        }
    },

    // Read the resource:
    read: function (optimizerContext, callback) {
        var self = this;

        if (callback) {
            readContent(self, optimizerContext, callback);
        } else {
            return new Promise(function (resolve, reject) {
                readContent(self, optimizerContext, function (err, content) {
                    return err ? reject(err) : resolve(content);
                });
            });
        }
    },

    getUnbundledTarget: function() {
        return 'content/' + this.path;
    },

    // // getSourceFile is optional and is only used to determine the last modified time
    // // stamp and to give the output file a reasonable name when bundling is disabled
    getDir: function () {
        return null;
    }
};
