'use strict';

const localeFormatter = require('@ebay/locale-formatter-ebay');

module.exports = function formatDate(element, data, context) {
    if (!(data instanceof Date)) {
        data = new Date(data);
    }

    const options = element.options || {};
    const emissionOption = getDateTimeEmissionOption(options);
    const formatOptions = {
        dateTimeOutput: getDateTimeEmissionOption(options),
        dateFormatType: getDateFormatOption(options.dateFormat),
        timeFormatType: getTimeFormatOption(options.timeFormat),
        timeZone: context.locality && (context.locality.timeZone || context.locality.timezone)
    };

    const formattedValues = localeFormatter.formatDateTime(data, context.locality && context.locality.locale, formatOptions);
    if (formattedValues.error) {
        throw new Error(formattedValues.error);
    }

    if (emissionOption === 'TIME_ONLY') {
        data = formattedValues.timeFormat.trim();
    }
    else if (emissionOption === 'DATE_ONLY') {
        data = formattedValues.dateFormat.trim();
    }
    else {
        data = (formattedValues.dateFormat.trim() + ' ' + formattedValues.timeFormat.trim());
    }
    return data;
};

function getDateTimeEmissionOption(options) {
    options = options || {};
    if (options.timeFormat !== 'none' && options.dateFormat === 'none') {
		return 'TIME_ONLY';
	}
    else if (options.timeFormat === 'none' && options.dateFormat !== 'none') {
		return 'DATE_ONLY';
	}
    else {
		return 'BOTH';
	}
}

function getDateFormatOption(dateFormat) {
    if (!dateFormat || dateFormat === 'none') {
        return 'medium';
    }
    return dateFormat;
}

function getTimeFormatOption(timeFormat) {
    if (!timeFormat || timeFormat === 'none') {
        return 'long';
    }
    return timeFormat;
}
