/**
 * This method walks up the tree from the provided node to find the
 * root "_i18n-use-root" node. The root node is what asynchronously
 * loads all of the bundles and asynchronously renders the body. If a
 * root "_i18n-use-root" node is not found then a new one is created
 * and made to be a child of the true root. All of the child nodes
 * of the actual root node are moved to children of the newly created
 * node.
 *
 * @param node Node to search form
 * @param compiler Used to create the node if it is not found.
 */
function findRootUseNode(node, compiler) {
    if (node.isRoot()) {
        if (node.data.i18nUseNode) { // Is a "_i18n-use-root" already associated with the root node?
            // If so then use that node
            return node.data.i18nUseNode;
        } else {
            // Otherwise, create a new "_i18n-use-root" node
            var rootUseNode = node.data.i18nUseNode = compiler.createTagHandlerNode('_i18n-use-root');

            // *Move* all of the existing children of the root node to this node
            // NOTE: A node can only have one parent so an appendChild will move the node to the new parent
            node.forEachChild(function (childNode) {
                // Make the node that used to be a child of the root node, a child of the 'i18n-use' node
                rootUseNode.appendChild(childNode);
            });

            // Now make the new "_i18n-use-root" node the only child of the root node
            node.appendChild(rootUseNode);

            // Keep up with each bundles need to be loaded in order to render the template
            var bundleNameExpressionArray = [];
            var bundleNamesExpression = function () { // This function will be called at code generation time
                                                      // to produce the expression for the "bundleNames" property
                // Convert the used bundle names to an Array expression
                return compiler.makeExpression('[' + bundleNameExpressionArray.join(', ') + ']');
            };

            rootUseNode.setProperty('bundleNames', bundleNamesExpression);

            // Set a flag to indicate that this is the root "_i18n-use-root" node
            rootUseNode.data.isRootUseNode = true;

            // Add a helper method to the data object that can be used to add additional bundle
            // dependencies to the root use node
            rootUseNode.data.addUse = function addUse(varName, bundleNameExpression) {
                // We will introduced variables by adding parameters to the compiled function that
                // is used to render the body.
                rootUseNode.addNestedVariable(varName);

                // Keep track of all of the expressions that are used to refer to bundles
                bundleNameExpressionArray.push(bundleNameExpression.toString());
            };

            // Return the newly created "_i18n-use-root" node
            return rootUseNode;
        }
    } else {
        return findRootUseNode(node.parentNode, compiler);
    }
}

module.exports = function transform(node, compiler, builder) {

    // Get or create the root "_i18n-use-root" node
    var rootUseNode = findRootUseNode(node, compiler);

    if (node.tagName === 'i18n-use') {
        // If we are transforming an "i18n-use" tag then we might be adding multiple bundles
        // Example:
        // <i18n-use bundle1="MyProject.bundle1" bundle2="${someReferenceToBundle2}" hello="MyProject.hello"/>
        node.forEachProperty(function (varName, bundleName) {
            // NOTE: bundleName is actually a JavaScript expression represented as a String
            rootUseNode.data.addUse(varName, bundleName);
        });

        // Remove this node out of the tree since it is no longer needed
        node.parentNode.removeChild(node);
    } else if (node.tagName === 'i18n-bundle') {
        var varName = node.getAttribute('var');
        var bundleName = node.getProperty('path');

        // NOTE: bundleName is actually a JavaScript expression represented as a String
        rootUseNode.data.addUse(varName, bundleName);

        // Remove this node out of the tree since it is no longer needed
        node.parentNode.removeChild(node);
    }
};