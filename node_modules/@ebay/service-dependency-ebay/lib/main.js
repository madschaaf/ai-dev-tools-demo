'use strict';
const fs = require('fs');
const path = require('path');
const async = require('async');

function discover(projectPath) {
    const prcoessed = {};
    const rootPath = projectPath;
    return findAll(projectPath);

    function findAll(cwd) {
        let registry = {};
        const pkgPath = path.join(cwd, 'package.json');
        if (prcoessed[pkgPath]) {
            return registry;
        }
        prcoessed[pkgPath] = true;
        const pkg = tryRequire(pkgPath);

        if (pkg) {
            registry = Object.keys(pkg.dependencies || {}).reduce((accum, depModule) => {
                // verify if we already has information about this module
                let childModulePath = path.join(cwd, 'node_modules', depModule);

                // Check for npm3x/yarn
                if (!fs.existsSync(childModulePath)) {
                    childModulePath = path.join(rootPath, 'node_modules', depModule);
                }

                // Get All Child dependencies for this module
                const childDep = findAll(childModulePath);
                return Object.keys(childDep).reduce((tempObj, elem) => {
                    tempObj[elem] = childDep[elem];
                    return tempObj;
                }, accum);
            }, registry);

            if (fs.existsSync(path.join(cwd, 'config/config.json'))) {
                registry[pkg.name] = { name: pkg.name, path: cwd, version: pkg.version };
            }
        }

        return registry;
    }
}

function loadServiceDetails(registry, callback) {
    const modConfig = require('@ebay/module-config-inc');

    const asyncFuncs = Object.keys(registry).map(element => {
        return function (asyncCallback) {
            modConfig(registry[element].path, (err, config) => {
                let servicesList = null;
                // err will never happen here, so skipping handling

                if (config.get('services')) {
                    servicesList = Object.keys(config.get('services')).reduce((accu, service) => {
                        const servInfo = config.get('services')[service];
                        const port = servInfo.protocol === 'http:' ? 80 : 443;
                        const hostname = servInfo.hostname;
                        const servicename = servInfo.name || service;
                        const moduleName = registry[element].path.split('/').pop();
                        const serviceId = servInfo.urn || `urn:REST:${servicename}`;
                        accu.push({
                            'serviceId': serviceId,
                            'hostname': hostname,
                            'port': servInfo.port || port,
                            'modulename': moduleName,
                            'servicename': servicename
                        });
                        return accu;
                    }, []);
                }
                // avoid catching error by moduleConfig in asyncCallback function
                setImmediate(() => asyncCallback(null, servicesList && servicesList.length > 0 ? servicesList : null));
            });
        };
    });

    async.parallel(asyncFuncs, (err, results) => {
        // Filter Empty
        results = results.filter(elem => !!elem);

        // Merge arrays
        results = results.reduce((accum, elem) => {
            return accum.concat(elem);
        }, []);

        callback(results);
    });
}

function tryRequire(path) {
    try {
        return require(path);
    } catch (e) {
        // skip
    }
}

module.exports = {
    discover,
    loadServiceDetails
};
