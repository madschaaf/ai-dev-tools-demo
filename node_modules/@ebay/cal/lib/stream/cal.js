'use strict';

var os = require('os'),
    net = require('net'),
    util = require('util'),
    moment = require('moment'),
    stream = require('stream'),
    objutil = require('objutil'),
    apputil = require('../apputil'),
    tryRequire = require('try-require'),
    nconf = tryRequire('nconf'),
    constants = require('../constants'),
    debug = require('debug')('cal:stream');

const appContext = require('@ebay/app-context-ebay');

var machineName = os.hostname(),
    ipAddress = require('ip').address(),
    RETRY_LIMIT = 150,  // qa is really bad here
    DEFAULT_CONNECTION_TIMEOUT = 65000,    //1+ min
    DEFAULT_DELAY_START = 500,   //500ms - do not want to kill CAL with previous 10ms
    MAX_DELAY_START = 500;  //500ms

var skipper = 0,
    skipperSize = 0,
    resolvedHost;

const CAL_ENV = ['CMS_REGION','CMS_AVAILABILITYZONE','TESS_CLUSTER_ID','TRAFFIC_MIRROR'];

function Transformer(options) {
    Transformer.super_.apply(this);
    options = options || {};

    this._state = Transformer.State.DISCONNECT;
    this._connRetryCounter = 0;
    this._delayStart = DEFAULT_DELAY_START;

    // ebay-scope-conversion-skip-next-line
    var tconf = nconf && nconf.get('cal') || {};

    this._port = tconf.port || options.port || 1118;
    if (resolvedHost) {
        this._host = resolvedHost;
    } else {
        this._host = tconf.host || options.host || this._host;
        debug('using %s host', this._host);
        resolvedHost = this._host;
    }

    this._environment = options.environment || 'prod';
    const poolname = options.poolname || appContext.poolName || constants.UNSET;
    this._poolname = appContext.calPoolName || (poolname + (process.env.ODBMO_NAME &&
        process.env.PAAS_REALM === 'staging' && `-${process.env.ODBMO_NAME}` || ''));

    this._buildLabel  = options.buildLabel || apputil.getBuildVersion() || constants.UNSET;
    this._configLabel = options.configLabel || apputil.getConfigVersion() || constants.UNSET;
    this._tryReconnect = true;
    this._connectionTimeout = options.timeout || DEFAULT_CONNECTION_TIMEOUT;

    this.once('finish', this._onEnd.bind(this));
    this.once('end', this._onEnd.bind(this));
}

Transformer.RECONNECTABLE = [ 'EPIPE', 'ECONNRESET', 'ECONNREFUSED' ];


Transformer.State = {
    DISCONNECT: 0,
    CONNECTING: 1,
    CONNECTED: 2
};


objutil.extend(Transformer, stream.Transform, {

    _createSocket: function () {
        var socket;
        socket = this._socket = new net.Socket();
        socket.setNoDelay(true);
        socket.setTimeout(this._connectionTimeout);
        socket.on('pipe',    this._onPipe.bind(this));
        socket.on('unpipe',  this._onUnpipe.bind(this));
        socket.on('error',   this._onError.bind(this));
        socket.once('close',   this._onClose.bind(this));
        socket.on('timeout', this._onTimeout.bind(this));
        debug('creating new socket');
        return socket;
    },

    _destroySocket: function () {
        var socket = this._socket;
        if (socket) {
            socket.removeAllListeners('pipe');
            socket.removeAllListeners('unpipe');
            socket.removeAllListeners('error');
            socket.removeAllListeners('close');
            socket.removeAllListeners('timeout');
            socket.removeAllListeners('data');
            socket.destroy();
        }
        this._socket = undefined;
        this._pendingConnection = undefined;
        // remove old destination to avoid connection reset error
        this.removeAllListeners('data');
        debug('socket destroyed');
    },

    _connect: function () {
        let socket;

        if (this._pendingConnection) {
            if (this._state === Transformer.State.CONNECTING) {
                debug('still connecting...');
            }
            else if (this._state === Transformer.State.CONNECTED) {
                debug('reusing existing socket');
            }
            return this._pendingConnection;
        }

        socket = this._createSocket();

        this._state = Transformer.State.CONNECTING;
        debug('socket connect', this._host, this._port);

        return this._pendingConnection = new Promise((resolve, reject) => {
            socket.connect(this._port, this._host, () => {
                debug('Socket Status=', (socket.pending || socket.connecting));
                this.unpipe(socket);
                this.pipe(socket);
                this._delayStart = DEFAULT_DELAY_START;
                resolve();
            });
        });
    },

    _transform: function (chunk, encoding, callback) {
        var that = this;

        if (this._state === Transformer.State.DISCONNECT) {
            debug('disconnected state, connecting again',
                that._socket && (that._socket.pending ||
                    that._socket.connecting));
            // it will always be resolved no matter if it is error or success
            // hence no reject handling
            this._connect().then(() => {
                debug('Socket pending=',
                    that._socket && (that._socket.pending ||
                        that._socket.connecting));
                sendChunk();
            }).catch(err => {
                console.error('Unexpected error during connect operation', err);
            });
            return;
        }
        
        sendChunk();

        function sendChunk() {
            if (chunk.length > 0) {
                const data = chunk.toString('utf8');
                debug('sending chunk', that._state);
                that.push(that._packMessage(data));
                skipperSize += chunk.length;
                if (skipper % 1000 === 0) {
                    debug('writing %s bytes', skipperSize);
                    skipperSize = 0;
                }
                skipper++;
            }
            
            callback();
        }
    },

    _onEnd: function () {
        if (this._socket) {
            this._socket && this._socket.end();
            this._state = Transformer.State.DISCONNECT;
            this._destroySocket();
            debug('socket end');
        }
    },

    _onTimeout: function () {
        this._socket && this._socket.end();
        this._state = Transformer.State.DISCONNECT;
        this._destroySocket();
        debug('socket timeout');
    },


    _onError: function (err) {
        debug('In _onError() state=%d', this._state, err);
        if (this._state === Transformer.State.DISCONNECT) {
            return;
        }
        this._state = Transformer.State.DISCONNECT;

        // always reconnect to any error to be resilient to any failures
        // if (!~Transformer.RECONNECTABLE.indexOf(err.code)) {
        //     this._tryReconnect = false;
        //     resolvedHost = null;
        //     this.emit('error', err);
        // }

        // _onClose will be called next which will destory the socket
        // so we do not need to do it here
        // this is a minor bug that caused no retries
        // this._destroySocket();

        // now we only count it for debugging
        debug(err.code, 'retry count:', this._connRetryCounter++, ' - ', resolvedHost);
    },


    _onClose: function (hadError) {
        debug('In _onClose() state=%d, hadError=%s', this._state, hadError);

        if (!hadError && this._state === Transformer.State.DISCONNECT || !resolvedHost) {
            return;
        }
        this._state = Transformer.State.DISCONNECT;
        debug('In _onClose() disconnected, state=%d, hadError=%s', this._state, hadError);
        this._destroySocket();
        if (hadError) {
            debug('closing with errors');
            if (this._tryReconnect) {
                setTimeout(() => {
                    this._connect();
                }, this._delayStart);
                debug('retrying cal connection after %sms', this._delayStart);
                this._delayStart = Math.max(this._delayStart + DEFAULT_DELAY_START, MAX_DELAY_START);
            }
        } else {
            debug('closing without errors');
        }
    },


    _onPipe: function () {
        this._connRetryCounter = 0;
        this._socket.write(this._packMessage(this._createMachineHeader()));
        debug('piping machine headers');
        this._state = Transformer.State.CONNECTED;
    },


    _onUnpipe: function () {
        // nada for now
    },


    _createMachineHeader: function () {
        var header = [];

        if (this._environment === 'PayPal') {
            header.push(util.format('SQLLog for %s:%s', this._poolname, machineName));
        } else {
            header.push(util.format('SQLLog for %s:%s:%s', this._poolname, machineName, ipAddress));
        }
        header.push(util.format('Environment: %s', this._environment));
        // Cal seems to accept two possible options for the label header:
        // 1. `Label: {buildId}` <- what we were doing before
        // 2. `Label: {buildId};{configId};{xsllabel}` <- what we're doing now
        // passing buildId and configId only will result in configId being ignored
        // I have no idea what xsllabel is but in raptor it is also just always unset
        header.push(util.format('Label: %s;%s;unset', this._buildLabel, this._configLabel));
        header.push(util.format('Start: %s', moment().format('DD-MM-YYYY HH:mm:ss')));
        
        // Added for Docker PDLC to inject pod env to CAL header
        let envKeys = Object.keys(process.env).filter(key => (key.startsWith('CAL_LABEL_') || CAL_ENV.indexOf(key) > -1));
        if(envKeys && envKeys.length > 0) {
            let calEnvArr = [];
            for(let i=0; i<envKeys.length; i++){
                let key = envKeys[i];
                if(key.startsWith('CAL_LABEL_')) {
                    let trimmedKey = key.substring(10).toLowerCase();
                    calEnvArr.push(`${trimmedKey}=${process.env[key]}`);
                } else {
                    calEnvArr.push(`${key.toLowerCase()}=${process.env[key]}`);
                }                                
            }
            header.push(util.format('CALLabels: %s', calEnvArr.join(';')));
        }
        
        return header.join('\n');
    },


    _packMessage: function (message) {
        var parts = message.split('\t'),
            threadId,
            eventId,
            parentEventId;

        if (parts.length > 3) {
            eventId = +(parts.shift());
            parentEventId = +(parts.shift());
            threadId = +(parts.shift());
            message = parts.join('\t');
        }

        eventId = eventId || 0;
        parentEventId = parentEventId || 0;
        threadId = threadId || constants.DEFAULT_THREAD_ID;

        var buffer = Buffer.alloc(constants.HEADER_SIZE + Buffer.byteLength(message));
        buffer.writeUInt32BE(threadId, 0);
        buffer.writeUInt16BE(parentEventId, 4);
        buffer.writeUInt16BE(eventId, 6);
        buffer.writeUInt32BE(Buffer.byteLength(message), 8);
        buffer.write(message, 12);
        return buffer;
    },

    shutdown: function (next) {
        this._tryReconnect = false;
        resolvedHost = null;
        debug('shutting down connection');
        this.end();
        next && next();
    }

});

exports = module.exports = {

    createWriteStream: function cal(options) {
        return new Transformer(options);
    }

};

exports.Transformer = Transformer;
