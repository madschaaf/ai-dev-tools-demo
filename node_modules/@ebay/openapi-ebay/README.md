openapi-ebay
==================

The module provides an openapi layer on top of express.

Ported from openapi-hapi and swaggerize-express projects, it is not a middleware like openapi-hapi or swaggerize-express but a solid base to build the next service layer upon. For example, we can use it to provide a configuration layer for service stack similar to how kraken-js does it for frontend. 

`openapi-ebay` is a design-driven approach to building RESTful apis with [Swagger](http://swagger.io) and [Express](http://expressjs.com).

`openapi-ebay` provides the following features:

- OpenAPI 3.0 schema validation.
- Routes based on the OpenAPI schema document.
- API documentation route.
- Input validation.

### Why "Design Driven"

There are already a number of modules that help build RESTful APIs for node with swagger. However, these modules tend to focus on building the documentation or specification as a side effect of writing the application business logic.

`openapi-ebay` begins with the swagger document first. This facilitates writing APIs that are easier to design, review, and test.

### Usage

```javascript
const confgure = require('openapi-ebay');
const app = await confgure({
    schema: Path.resolve('./schema.json'),
    docspath: '/api-docs',
    handlers: './handlers',
    securityProviders: './security' //Optional - security authorize handlers as per `securitySchemas`
    handlerRuntimeFactory: './handler-runtime-factory' // Optional
    ...restOfOptions
});
```

Options:
- `schema` - (*Object*) or (*String*) or (*Promise*) - (required) - a valid openapi 3.0 document. schema can be one of the following.
    - A relative or absolute path to the OpenAPI schema document.
    - A URL of the OpenAPI schema document.
    - The OpenAPI schema object
    - A promise (or a `thenable`) that resolves to the OpenAPI schema object.
- `basedir` - root dir for provided schema
- `docspath` - the path to expose api docs for swagger-ui, etc. Defaults to `/`.
- `handlers` - - (*Object*) or (*String*) - (required) - either a directory structure for route handlers or a pre-created object (see *Handlers Object* below). If `handlers` option is not provided, route builder will try to use the default `handlers` directory (only if it exists).
- `securityProviders` - (*Object*) or (*String*) - (optional) - authorization handlers or path to the file that provides a map of handlers corresponding to `securitySchemas`.
- `refResolver` - custom resolver for external type references.
- `preControllerMiddleware` - a list of express handlers that will be injected into the pipeline before route middleware
- `controllerMiddleware` - a list of express handlers that will execute post route resolution and before controller handler.
- `postControllerMiddleware` - a list of express handlers that will be injected into the pipeline after controller handler, useful for commong error handlers
- `handlerRuntimeFactory` - a factory (*Function*) - (optional) - that can wrap express specific handler into a custom function handler. For example, we can create an [Oja](https://github.com/eBay/oja) context based runtime instead of express.

The framework will make properties (query|header|body) available in the request object

- `route` - will have route specific metadata.
- `req.parameters` - all resolved parameters available via this generic property

#### Setup Example:

```javascript
var http = require('http');
var express = require('express');
var configure = require('openapi-ebay').configure;

app = express();

await configure(app, {
    schema: require('./schema.json'),
    docspath: '/api-docs',
    handlers: './handlers'
});

var server = http.createServer(app);
server.listen(port, 'localhost', () => {
    app.api.host = server.address().address + ':' + server.address().port;
});

```

### Schema definition

The module supports openapi 3.0 spec.

The schema allows to reference external types defined in schema files relative to the current schema or packaged in external nodejs modules.

* Example of a relative schema reference
```json
"schemas": {
    "Pet": {
        "$ref": "path/to/other/schema.json#/Pet"
    }
}
```

* Example of an external module schema reference
```json
"schemas": {
    "Pet": {
        "$ref": "parent-types/schema.json#/Pet"
    }
}
```

__Note:__ Pet type is defined in parent-types module with schema at the root of the module.

### Handlers Directory

The `options.handlers` option specifies a directory to scan for handlers. These handlers are bound to the api `paths` defined in the swagger document.

```
handlers
  |--foo
  |    |--bar.js
  |--foo.js
  |--baz.js
```

Will route as:

```
foo.js => /foo
foo/bar.js => /foo/bar
baz.js => /baz
```

### Path Parameters

The file and directory names in the handlers directory can also represent path parameters.

For example, to represent the path `/users/{id}`:

```shell
handlers
  |--users
  |    |--{id}.js
```

This works with directory names as well:

```shell
handlers
  |--users
  |    |--{id}.js
  |    |--{id}
  |        |--foo.js
security
|----index.js
```js
module.exports = {
    OAuth2: require('./OAuth2'),
    Token: require('./Token')
}
```
|----OAuth2
|      |--index.js
|----Token
|      |--index.js
```

To represent `/users/{id}/foo`.

### Handlers File

Each provided javascript file should export an object containing functions with HTTP verbs as keys.

Example:

```javascript
module.exports = {
    get: function (req, res) { ... },
    put: function (req, res) { ... },
    ...
}
```

### Handler Middleware

Handlers can also specify middleware chains by providing an array of handler functions under the verb|operation:

```javascript
module.exports = {
    get: [
        function m1(req, res, next) { ... },
        function m2(req, res, next) { ... },
        function handler(req, res)  { ... }
    ],
    ...
}
```

### Handlers Object

The directory generation will yield this object, but it can be provided directly as `options.handlers`.

Note that if you are programmatically constructing a handlers obj this way, you must namespace HTTP verbs with `$` to
avoid conflicts with path names. These keys should also be *lowercase*.

Example:

```javascript
{
    'foo': {
        '$get': function (req, res) { ... },
        'bar': {
            '$get': function (req, res) { ... },
            '$post': function (req, res) { ... }
        }
    }
    ...
}
```

Handler keys in files do *not* have to be namespaced in this way.

### Security Middleware

If a security definition exists for a path in the swagger API definition, and an appropriate authorize function is provided via securityProviders functions

For example:

Schema API definition:

```json
    .
    .
    .

    //A route with security object.
    "security": [
        {
            "petstore_auth": [
                "write_pets",
                "read_pets"
            ]
        }
    ]
    .
    .
    .
    "components": {
        //security definitions
        "securitySchemes": {
            "petstore_auth": {
                "type": "oauth2",
                "flows": {
                    "implicit": {
                        "authorizationUrl": "http://example.org/api/oauth/dialog",
                        "scopes": {
                            "write_pets": "modify pets in your account",
                            "read_pets": "read your pets"
                        }
                    }
                }
            }
        }
    }
```

#### Security provider example

```javascript
function factory(routeSecurity, securityDefinitions) {
    const scopes = routeSecurity;
    const allowedScopes = securityDefinitions.scopes;
    // validate scopes
    scopes.forEach(scope => {
        Assert.ok(allowedScopes.includes(scope), `Scope "${scope}" is not found in allowed scopes [${allowedScopes}]`)
    });

    return function authorize(req) {
        return new Promise((resolve, reject) => {
            // validate function can red token details and validate scopes or other attributes attached
            // to the token and allow or disallow the flow
            validate(req, function (error) {
                if (error) {
                    error.status = 403;
                    reject(error);
                    return;
                }

                resolve();
            });
        });
    }
}
```

### External Type Resolver

In case one needs a custom logic on how to resolve type that are externally referened in openapi schema, one can provide its own resolver during configuration stage.

Example:
```js
const confgure = require('openapi-ebay');
const app = await configure({
    schema: Path.resolve('./schema.json'),
    refResolver: schemaRef => {
        // modify/resolve schemaRef here
        return schemaRef;
    }
});
```

In case one needs to get external type resolver for other tasks, one can use createModuleResolver method.

```js
const moduleRefResolver = require('openapi-ebay').createModuleResolver(schemaRef => {
    // modify/resolve schemaRef here
    return schemaRef;
});

require('swagger-parser')
    .bundle(...args, {
        resolve: {
            module: moduleRefResolver
        }
    });
```

### Not supported

* parameter with [styles](https://swagger.io/specification/#parameterObject)
    * matrix
    * label
    * deepObject
    * all types of objects encoding
