const Fs = require('fs');
const Path = require('path');

function create(resolver) {
    // resolver can be one of two types, full resolver or resolveSchema function
    if (resolver && typeof resolver === 'object') {
        return resolver;
    }

    return {
        /**
         * The order that this resolver will run, in relation to other resolvers.
         *
         * @type {number}
         */
        order: 10,

        resolveSchema(file) {
            let schemaRef = file.url;
            // if schema ref starts with implicit schema location where module name is inferred from schema file name
            if (resolver) {
                schemaRef = resolver(schemaRef);
            }

            const parts = schemaRef.split('/').reduce((acc, part) => {
                // handle scopped modules
                if (acc.length && /^@[^\/]+$/.test(acc[acc.length - 1])) {
                    part = [acc.pop(), part].join('/');
                }
                acc.push(part);
                return acc;
            }, []);

            let current;

            while (parts.length > 0) {
                const nextPath = current ? Path.resolve(current, parts[0]) : (parts[0] || '/');
                if (!Fs.existsSync(nextPath)) {
                    break;
                }
                parts.shift();
                current = nextPath;
            }

            if (parts.length === 0) {
                if (Fs.existsSync(current)) {
                    return current;
                }
                return findModuleRoot(current);
            }

            // resolve root for schema referenced via absolute path or module path
            while (parts.length > 0) {
                current = tryResolve(parts[0], current);
                if (!current) {
                    return;
                }
                parts.shift();
            }

            return current;

            function findModuleRoot(path) {
                const pkgPath = Path.resolve(path, 'package.json');
                if (Fs.existsSync(pkgPath)) {
                    return path;
                }
                const _path = Path.dirname(path);
                if (_path === path || _path === '/') {
                    return;
                }

                return findModuleRoot(_path);
            }

            function tryResolve(name, parent) {
                let options;
                if (parent) {
                    const parentRoot = findModuleRoot(parent);
                    if (parentRoot) {
                        options = {
                            paths: [
                                parentRoot,
                                Path.resolve(parentRoot, 'node_modules')
                            ]
                        };
                    }
                }
                try {
                    return require.resolve(name, options);
                }
                catch (e) {
                    if (!/^\.\//.test(name)) {
                        try {
                            return require.resolve(`./${name}`, options);
                        }
                        catch (e) {
                            // skip
                        }
                    }
                    return;
                }
            }
        },

        /**
         * Determines whether this resolver can read a given file reference.
         * Resolvers that return true will be tried, in order, until one successfully resolves the file.
         * Resolvers that return false will not be given a chance to resolve the file.
         *
         * @param {object} file           - An object containing information about the referenced file
         * @param {string} file.url       - The full URL of the referenced file
         * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
         * @returns {boolean}
         */
        canRead(file) {
            if (/\.json|\.yaml/.test((file.extension))) {
                const schemaPath = this.resolveSchema(file);
                return !!schemaPath;
            }
        },

        /**
         * Reads the given file and returns its raw contents as a Buffer.
         *
         * @param {object} file           - An object containing information about the referenced file
         * @param {string} file.url       - The full URL of the referenced file
         * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
         * @returns {Promise<Buffer>}
         */
        read(file) {
            return new Promise((resolve, reject) => {
                const schemePath = this.resolveSchema(file);
                try {
                    Fs.readFile(schemePath, (err, data) => {
                        if (err) {
                            reject(new Error(`Error opening file ${
                                schemePath || file.url}, long message: ${err.stack}`));
                        }
                        else {
                            resolve(data);
                        }
                    });
                }
                catch (err) {
                    reject(new Error(`Error opening file ${schemePath || file.url}, long message: ${err.stack}`));
                }
            });
        }
    };
}

module.exports = create(); // create default resolver
module.exports.create = create; // allow to create custom one
