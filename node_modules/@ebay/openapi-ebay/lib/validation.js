const entries = require('entries');
const Enjoi = require('enjoi');
const Joi = require('joi');
const Util = require('util');

const extensions = [
    { type: 'int64', base: Joi.string().regex(/^\d+$/) },
    { type: 'byte', base: Joi.string().base64() },
    { type: 'binary', base: Joi.binary() },
    { type: 'date', base: Joi.date() },
    { type: 'date-time', base: Joi.date().iso() }
];

function refineType(type, format) {
    if (type === 'integer') {
        type = 'number';
    }

    switch (format) {
        case 'int64':
        case 'byte':
        case 'binary':
        case 'date':
        case 'date-time':
            return format;
        default:
            return type;
    }
}

/*
    possible variations for parameter structure to handle
    multipart/mixed is not yet supported with encoding for each property

    {
        requestBody: {
            content: {
                mime-type1: {
                    schema
                },
                mime-type2: {
                    schema
                }
            }
        }
    },

    {
        schema: {}
        ---- or ----
        content: {
            mime-type1: {
                schema
            },
            mime-type1: {
                schema
            }
        }
    }
*/

function makeValidator(parameter) {
    let validator;
    if (parameter.schema) {
        validator = {
            coerce: coercion(parameter.schema),
            schema: applyParameterSpecifics(Enjoi.schema(parameter.schema, { extensions, refineType }))
        };
    }
    else if (parameter.content) {
        validator = buildContentValidators(parameter.content);
    }
    else if (parameter.requestBody) {
        validator = buildContentValidators(parameter.requestBody.content, true);
    }

    const meta = {
        parameter,
        validator,
        validate(value, contentType) {
            const { coerce, schema } = selectValidation(this.validator, contentType);

            if (!schema) {
                return;
            }

            const data = (value !== undefined && value !== null) ? coerce && coerce(value) : undefined;
            const { value: result, error } = (() => {
                try {
                    return schema.validate(data);
                }
                catch (err) {
                    return { error: err };
                }
            })();

            if (error) {
                const name = parameter.name || parameter.requestBody && 'requestBody';
                if (name) {
                    error.message = error.message.indexOf('value') > -1 ? error.message.replace('value', name) :
                        `${name} ${error.message}`;
                }
                error.message = error.message.replace('{contentType}', contentType || '"unspecified"');

                if (error.details?.length) {
                    const dmessages = error.details.reduce((acc, detail) => {
                        if (detail.context?.details) {
                            acc.push(detail.context.details.map(cd => cd.message).join(', '));
                        }
                        return acc;
                    }, []);
                    if (dmessages.length) {
                        error.message = `${error.message} [${dmessages.join(', ')}]`;
                    }
                }

                throw error;
            }
            return result;
        }
    };

    return meta;

    function selectValidation(validators, contentType) {
        if (Array.isArray(validators)) {
            for (let index = 0; index < validators.length; index++) {
                const validatorMeta = validators[index];
                if (!validatorMeta.match || validatorMeta.match(contentType) ||
                    validators.length === 1 && !contentType) {
                    return validatorMeta;
                }
            }
            return {};
        }
        return validators || {};
    }

    function scanNullables(schema) {
        const childSchemas = schema.oneOf || schema.anyOf || schema.allOf;
        if (childSchemas) {
            if (schema.nullable) {
                if (schema.oneOf) {
                    schema.oneOf.push({
                        nullable: true
                    });
                    delete schema.nullable;
                }
                else if (schema.anyOf) {
                    schema.anyOf.push({
                        nullable: true
                    });
                    delete schema.nullable;
                }
                else if (schema.allOf) {
                    schema.type = ['object'];
                }
            }

            childSchemas.forEach(scanNullables);
            return;
        }

        if (!schema.properties) {
            if (schema.nullable) {
                if (!Array.isArray(schema.type)) {
                    schema.type = schema.type && [schema.type] || [];
                }
                schema.type = schema.type ? [...schema.type, 'null'] : ['null'];
            }
            return;
        }

        const props = schema.properties;
        Object.keys(props).forEach(key => {
            const propSchema = props[key];
            if (propSchema.type === undefined || propSchema.type.includes('object')) {
                scanNullables(propSchema);
            }
            if (propSchema.type === 'array') {
                scanNullables(propSchema.items);
            }
            if (propSchema.nullable) {
                if (!Array.isArray(propSchema.type)) {
                    propSchema.type = propSchema.type && [propSchema.type] || [];
                }

                propSchema.type = propSchema.type ? [...propSchema.type, 'null'] : ['null'];
            }
        });
    }

    function buildContentValidators(content, requireContentType) {
        const contentTypeAllowed = [];
        const validators = Object.keys(content).map((type) => {
            // convert * into reg exp
            const param = content[type];
            type = type.replace(/\*/g, '.+');
            const matcher = new RegExp(type);
            contentTypeAllowed.push(type);
            // add map nullable to enjoi null support
            scanNullables(param.schema);
            return {
                coerce: coercion(param.schema),
                match: contentType => matcher.exec(contentType),
                schema: applyParameterSpecifics(Enjoi.schema(param.schema, { extensions, refineType }))
            };
        });

        // ATTENTION: this must be the last validators that will fail if none of the above content validators matched
        if (requireContentType) {
            validators.push({
                schema: {
                    validate: () => {
                        throw new Error(`content-type {contentType} is not supported, allowed ones are ${
                            contentTypeAllowed}`);
                    }
                }
            });
        }

        return validators;
    }

    function applyParameterSpecifics(sch) {
        if (parameter.schema && parameter.schema.type === 'array') {
            sch = sch.single(true);
        }

        if (parameter.required || parameter.requestBody && parameter.requestBody.required) {
            sch = sch.required();
        }

        if (!parameter.requestBody && parameter.allowEmptyValue) {
            sch = sch.allow('').optional();
        }

        return sch;
    }
}

function makeResponseValidator(responses) {
    const validators = {};

    for (const [code, response] of entries(responses)) {
        if (!isNaN(code)) {
            const validatorsByContentType = validators[code] = [];
            for (const [contentType, responseType] of entries(response.content)) {
                if (responseType.schema) {
                    const schema = Enjoi.schema(responseType.schema, { extensions, refineType });
                    if (responseType.schema.type === 'array') {
                        schema.single(true);
                    }

                    const matcher = new RegExp(contentType);
                    validatorsByContentType.push({
                        match: ctype => matcher.exec(ctype),
                        schema
                    });
                }
            }
            validators[code] = validatorsByContentType;
        }
    }

    return async (response, status = 'default', contentType = '*/*') => {
        const validatorsByContentType = validators[status] || validators.default;
        if (validatorsByContentType) {
            for (let index = 0; index < validatorsByContentType.length; index++) {
                const validator = validatorsByContentType[index];
                if (validator.match(contentType)) {
                    const { error, value } = validator.schema.validate(response);
                    if (error) {
                        throw error;
                    }
                    return value;
                }
            }
        }
    };
}

function pathsep(parameter) {
    switch (parameter.style) {
        case 'simple':
            return ',';
        case 'spaceDelimited':
            return ' ';
        case 'pipeDelimited':
            return '|';
        // no default
    }
}

function coercion(parameter) {
    let fn;
    const type = parameter.oneOf && 'object' ||
        parameter.allOf && 'object' ||
        parameter.type;

    switch (type) {
        case 'array':
            fn = function (data) {
                if (Array.isArray(data)) {
                    return data;
                }
                const sep = pathsep(parameter);
                return data.split(sep);
            };
            break;
        case 'integer':
        case 'number':
            fn = function (data) {
                if (parameter.format === 'int64') {
                    return data;
                }
                return Number(data);
            };
            break;
        case 'string':
            // TODO: handle date, date-time, binary, byte formats.
            if (parameter.format === 'binary' || parameter.format === 'byte') {
                fn = data => data;
            }
            fn = fn || String;
            break;
        case 'boolean':
            fn = function (data) {
                if ((data === 'true') || (data === '1') || (data === 1) || (data === true)) {
                    return true;
                }
                if ((data === 'false') || (data === '0') || (data === 0) || (data === false)) {
                    return false;
                }
                return data;
            };
            break;
        case 'object':
        default:
            fn = function (data) {
                if (Util.isObject(data) && !Object.keys(data).length) {
                    return undefined;
                }
                return data;
            };
            break;
    }

    return fn;
}

module.exports = {
    makeValidator,
    makeResponseValidator
};
