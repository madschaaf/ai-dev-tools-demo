const Utils = require('./utils');
const pathRegexp = require('path-to-regexp');
const Async = require('async');

/**
 * Creates a new Express route and adds it to the router.
 * @param router
 * @param mountpath
 * @param routeSpec
 */
const makeExpressRoute = ({
    route,
    preControllerMiddleware,
    postControllerMiddleware,
    controllerMiddleware
}) => {
    let pipe = [
        (req, res, next) => {
            req.route = route;
            next();
        }
    ];

    if (preControllerMiddleware) {
        pipe = pipe.concat(preControllerMiddleware);
    }

    if (route.security) {
        pipe.push((req, res, next) => {
            const errors = [];
            Async.some(route.security, (authorize, cb) => {
                const promise = authorize(req);
                if (!promise) {
                    return cb(true);
                }
                promise.then(() => cb(true)).catch(err => {
                    errors.push(err);
                    cb(false);
                });
            }, success => {
                if (!success) {
                    res.statusCode = 401;
                    const err = errors.shift();
                    if (err) {
                        err.status = 401;
                    }
                    next(err);
                    return;
                }
                next();
            });
        });
    }

    if (controllerMiddleware) {
        pipe = pipe.concat(controllerMiddleware);
    }

    if (route.validators) {
        for (let i = 0; i < route.validators.length; ++i) {
            pipe = pipe.concat(makeExpressValidator(route.validators[i]));
        }
    }

    // make all handlers async by default
    if (route.handler) {
        route.handler = asyncify(route.handler);
    }

    if (Array.isArray(route.handler)) {
        if (route.handler.length > 1) {
            pipe = pipe.concat(route.handler.slice(0, route.handler.length - 1));
        }
        route.handler = route.handler[route.handler.length - 1];
    }

    pipe.push(route.handler);

    if (postControllerMiddleware) {
        pipe = pipe.concat(postControllerMiddleware);
    }

    const path = Utils.prefix(route.path.replace(/{([^}]+)}/g, ':$1'), '/');

    return {
        methods: [route.method],
        path,
        handler: pipe
    };
};

function asyncify(handlers) {
    if (handlers) {
        return Array.isArray(handlers) ?
            handlers.map(handler => createAsyncHandler(handler)) :
            createAsyncHandler(handlers);
    }
}

function createAsyncHandler(handler) {
    if (handler.length === 4) {
        return handler;
    }
    return async function (req, res, next) {
        try {
            const ret = handler(req, res, next);
            if (ret instanceof Promise) {
                await ret;
            }
        }
        catch (err) {
            next(err);
        }
    };
}

/**
 * Builds the middleware to manage not allowed calls that use wrong Method
 * @param methods - list of avalaible method for this request
 * @return {function}
 */
const buildNotAllowedMiddleware = methods => (req, res, next) => {
    if (methods.indexOf(req.method.toLowerCase()) === -1) {
        res.set('Allow', methods.join(', ').toUpperCase());
        res.sendStatus(405).end();
        return;
    }
    next();
};

/**
 * Makes default accessor functions for a specific data location, e.g. query, params etc
 * @param dataLoc
 * @returns {{get: get, set: set}}
 */
function defaultAccessor(dataLoc) {
    return {
        get: (req, key) => req[dataLoc][key],
        set: (req, key, val) => { req[dataLoc][key] = val; }
    };
}

function valueAccessor(param) {
    if (param.in === 'path') {
        return defaultAccessor('params');
    }
    if (param.in === 'query') {
        return defaultAccessor('query');
    }
    if (param.in === 'header') {
        return {
            get: (req, key) => req.header(key),
            set: () => {
                // noop
            }
        };
    }
    if (param.requestBody) {
        return {
            get: (req, key) => key ? req.body[key] : req.body,
            set: (req, key, val) => {
                if (!key) {
                    req.body = val;
                    return;
                }
                req.body[key] = val;
            }
        };
    }
}

/**
 * Makes a validator function, to validate data input per the Swagger API spec.
 * @param {{}} validator
 * @returns {function}
 */
function makeExpressValidator(validator) {
    return (req, res, next) => {
        const paramSpec = validator.parameter;
        const accessor = valueAccessor(paramSpec);

        const inputValue = accessor.get(req, paramSpec.name);

        try {
            const value = validator.validate(inputValue, req.headers['content-type']);
            accessor.set(req, paramSpec.name, value);
            req.parameters = req.parameters || {};
            // store all parameters in more generally accessible place as well
            if (paramSpec.requestBody) {
                req.parameters.request = value;
            }
            else {
                req.parameters[paramSpec.name] = value;
            }
            next();
        }
        catch (e) {
            const err = new Error(`Invalid parameter`);
            err.status = e.details ? 400 : 500;
            err.code = 'INVALID_PARAMETER';
            err.details = e.message;

            next(err);
        }
    };
}

/**
 * Creates express router.
 * @param options
 */
function create({
    routes = [],
    docspath = '/api-docs',
    schema,
    preControllerMiddleware,
    postControllerMiddleware,
    controllerMiddleware
}) {
    const expressRoutes = [];
    const routesMethod = {};

    // Add the api document route
    expressRoutes.push({
        methods: ['get'],
        path: Utils.prefix(docspath, '/'),
        handler: (req, res) => res.json(schema)
    });
    // Iterate over routes (paths)
    routes.forEach(route => {
        const expressRoute = makeExpressRoute({
            route,
            preControllerMiddleware,
            postControllerMiddleware,
            controllerMiddleware
        });
        expressRoutes.push(expressRoute);
        routesMethod[route.path] = routesMethod[route.path] || [];
        routesMethod[route.path].push(route.method.toLowerCase());
    });

    Object.keys(routesMethod).forEach(routePath => {
        const expressRoute = {
            method: 'use',
            path: pathRegexp(routePath),
            handler: buildNotAllowedMiddleware(routesMethod[routePath])
        };
        expressRoutes.push(expressRoute);
    });

    return expressRoutes;
}

module.exports = { create, valueAccessor };
