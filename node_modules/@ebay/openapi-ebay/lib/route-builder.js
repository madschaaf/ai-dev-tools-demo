const Assert = require('assert');
const Utils = require('./utils');
const Validation = require('./validation');

function build({ schema, handlers, securityProviders, handlerRuntimeFactory }) {
    const routes = [];

    Object.keys(schema.paths).forEach(path => {
        const routeSpec = schema.paths[path];
        const routeValidators = buildValidators(routeSpec);

        Object.keys(routeSpec).forEach(method => {
            if (!Utils.verbs.includes(method)) {
                return;
            }
            const operationSpec = routeSpec[method];
            const operationId = operationSpec.operationId;
            let handler = operationId && findHandler(handlers, path, operationId) ||
                findHandler(handlers, path, method);

            if (handler) {
                if (handlerRuntimeFactory) {
                    if (!Array.isArray(handler)) {
                        handler = [handler];
                    }
                    handler = handler.map((h, index) =>
                        handlerRuntimeFactory(h, index > 0) // all subsequent handler must be error handlers
                    );
                }
                const components = schema.components || {};
                routes.push({
                    path,
                    name: operationSpec.operationId,
                    description: operationSpec.description,
                    method,
                    security: buildSecurity({
                        routeSecurity: operationSpec.security ||
                        schema.security,
                        securitySchemes: components.securitySchemes,
                        securityProviders
                    }),
                    handler,
                    validators: [].concat(routeValidators, buildValidators(operationSpec)),
                    spec: operationSpec
                });
            }
            else {
                throw new Error(`Cannot find handler for the route:${
                    path}, method:${method}${operationId ? `, operation:${
                    operationId}` : ''}`);
            }
        });
    });

    return routes;
}

function buildValidators(routeSpec) {
    // we need to construct validators for parameters and requestBody
    const validators = (routeSpec.parameters || []).map(paramSpec => Validation.makeValidator(paramSpec));
    if (routeSpec.requestBody) {
        validators.push(Validation.makeValidator(routeSpec));
    }

    return validators;
}

function findHandler(handlers, path, method) {
    const pathnames = path.split('/').filter(el => el);
    if (!handlers) {
        return;
    }

    return (pathnames[0] ?
        nextPath(method, pathnames, handlers[pathnames[0]]) :
        selectMethod(handlers, method));
}

function selectMethod(source, method) {
    const $find = source[`$${method}`];
    // Check if there is an operation key prefixed with `$` sign. (e.g:- $get, $post)
    // Handlers option passed as an object should have `$` prefixed operation key
    // to avoid namespace collisions.
    if ($find) {
        return $find;
    }
    return source[method];
}

/**
 * Match a route handler to a given path name set.
 * @param method
 * @param pathnames
 * @param handlers
 * @returns {*}
 */
function nextPath(method, pathnames, handlers) {
    if (!handlers) {
        return null;
    }
    if (pathnames.length > 1) {
        pathnames.shift();
        return nextPath(method, pathnames, handlers[pathnames[0]]);
    }

    return handlers[pathnames[0]] ? handlers[pathnames[0]] : selectMethod(handlers, method);
}

function buildSecurity({ routeSecurity, securitySchemes, securityProviders }) {
    if (routeSecurity) {
        Assert.ok(securitySchemes, `No security definitions found for the given route security ${routeSecurity}`);
        Assert.ok(securityProviders, 'Security providers must be provided');
        const securityHandlers = [];
        routeSecurity.forEach(routeDef => {
            Object.keys(routeDef).forEach(name => {
                const routeSecurityDef = routeDef[name];
                const securityDef = securitySchemes[name];
                Assert.ok(securityDef, `Cannot find security definition for security type ${name}`);
                const authorizeFactory = securityProviders && securityProviders[name];
                Assert.ok(authorizeFactory, `Missing security provider for ${name}`);
                const authorize = authorizeFactory(routeSecurityDef, securityDef);
                Assert.ok(typeof authorize === 'function',
                    `Security provider factory for '${name}' should return function`);
                securityHandlers.push(authorize);
            });
        });

        return securityHandlers;
    }
}

module.exports = {
    build,
    Utils: {
        findHandler,
        buildValidators,
        buildSecurity
    }
};
