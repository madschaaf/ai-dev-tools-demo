'use strict';

var Hoek = require('hoek'),
    extend = require('extend'),
    Objpath = require('object-path'),
    tryRequire = require('try-require'),
    DataHolder = require('raptor-async/DataHolder');

var env = require('@ebay/environment-ebay'),
    Tracking = tryRequire('@ebay/tracking-ebay'),
    hmv = require('@ebay/header-multi-value-ebay'),
    debug = require('debuglog')('@ebay/experimentation-ebay'),
    logger = require('@ebay/logging-inc').logger('experimentation-ebay/Context');

var Api = require('../api'),
    ExperimentationContext = require('../ExperimentationContext');

var FLAGS;
var GlobalFlags;
var SKIPPED_TAGS = {
    USER_QUALIFIED_TREATMENTS: "qt",
    CONTEXT_QUALIFIED_TREATMENTS: "qc",
    UID_QUALIFIED_TREATMENTS: "uqt",
    CONTEXT_QUALIFIED_UID_TREATMENTS: "uqc"
};

var REQUEST_HEADERS = {
    EPRESULT: 'EPRESULT',
    HEADER_KEY: 'X-EBAY-C-EXP',
    OPTIN_COOKIE: 'OPTIN_COOKIE'
};

var RESPONSE_HEADERS = {
    HEADER_KEY_LC: 'x-ebay-svc-ep-cookielet',
    HEADER_KEY_UC: 'X-EBAY-SVC-EP-COOKIELET'

};

function loadFlags() {
    if (!GlobalFlags) {
        GlobalFlags = Tracking ? Tracking.Flags.GlobalFlags : undefined;

        FLAGS = GlobalFlags ? [
            'BOTH_GUID_ABSNT',
            'PERSTNT_GUID_ABSNT',
            'SESSION_GUID_ABSNT'
        ].map(function map(name) {
            return GlobalFlags[name];
        }) : [];
    }
}

// TODO: Test trackServedTreatment in global header

/*
|  The module provides a way to decouple EP functionality from request/response/express
*/

class Context {

    constructor(req, res, config) {
        this.req = req;
        this.res = res;
        this.ebay = this.req.ebay;
        this.config = config;
        this.params = {};
        this._loggedTreatments = {};
        this.contextDataHolder = null;
        this.internals$ = createInternals(this);
        // lazy init of tracking flags
        loadFlags();
    }

    isBPoolRequest() {
        return this.getHeader('X-eBay-EP-Proxy-Request');
    }

    isAPoolEnabled() {
        return Objpath.get(this.config, 'a-pool.enabled');
    }

    getAPoolConfig() {
        return Objpath.get(this.config, 'a-pool');
    }

    isBotAllowed() {
        return Objpath.get(this.config, 'a-pool.botAllowed');
    }

    isBPoolEnabled() {
        return Objpath.get(this.config, 'b-pool.enabled');
    }

    getDeprecationConfig() {
        return Objpath.get(this.config, 'deprecation');
    }

    isBOTRequest() {
        var tracking = this.ebay.tracking;
        if (Tracking && tracking) {
            var sojournerContext = tracking.sojournerContext;
            if (!GlobalFlags) {
                logger.warn(new Error('Tracking GlobalFlags are not found'));
                return;
            }

            if (sojournerContext && sojournerContext.isAppFlagSet(GlobalFlags.DETECTED_BOT)) {
                // BOT detected
                logger.warn("ep: BOT detected");
                return true;
            }
            return false;
        }
    }

    getRemoteAddr() {
        return this.ebay.getRemoteAddr();
    }

    getOriginalUrl() {
        return this.ebay.requestUrl;
    }

    getRequestMethod() {
        return this.req.method;
    }

    isPersistentGuidAbsent() {
        var tracking = this.ebay.tracking;
        if (Tracking && tracking) {
            var sojournerContext = tracking.sojournerContext;
            if (!GlobalFlags) {
                logger.warn(new Error('Tracking GlobalFlags are not found'));
                return;
            }

            return sojournerContext.isContextFlagSet(GlobalFlags.PERSTNT_GUID_ABSNT);
        }
    }

    isBothGuidAbsent() {
        var tracking = this.ebay.tracking;
        if (Tracking && tracking) {
            var sojournerContext = tracking.sojournerContext;
            if (!GlobalFlags) {
                logger.warn(new Error('Tracking GlobalFlags are not found'));
                return;
            }

            return sojournerContext.isContextFlagSet(GlobalFlags.BOTH_GUID_ABSNT);
        }
    }

    getHeaders() {
        return this.req.headers;
    }

    getHeader(name) {
        var headers = this.req.headers;
        return headers[name] || headers[name.toLowerCase()];
    }

    getRequestURL() {
        return this.ebay.getEndUserContext().getApplicationURL();
    }

    getCommand() {
        return this.ebay.getPageName();
    }

    getRequestParams() {
        return this.req.body;
    }

    getRequestHeaders() {
        return this.req.headers;
    }

    getTrackingGuidFlags() {
        return this.getHeader('X-eBay-Tracking-GUID-Flags');
    }

    getProxyExperiement() {
        return this.getHeader('X-eBay-EP-Proxy-Experiment');
    }

    getProxyTreatment() {
        return this.getHeader('X-eBay-EP-Proxy-Treatment');
    }

    setResponseHeader(name, value) {
        this.res.set(name, value);
    }

    onResponse(handler) {
        var res = this.res;
        var _end = res.end;
        res.end = Hoek.once(function epEnd() {
            var args = arguments;
            handler(function onComplete() {
                _end.apply(res, args);
            });
        });
    }

    deserializeTrackingHeader(data) {
        var ebay = this.ebay;
        if (Tracking && ebay.tracking) {
            var sojournerContext = ebay.tracking.sojournerContext;
            for (var i = 0; i < data.length; i++) {
                if (data[i] === '1') {
                    sojournerContext.setContextFlag(FLAGS[i], true);
                }
            }
        }
    }

    serializeTrackingHeader() {
        var ebay = this.ebay;
        if (Tracking && ebay.tracking) {
            var sojournerContext = ebay.tracking.sojournerContext;
            var data = FLAGS.reduce(function reduce(memo, flag) {
                memo += (sojournerContext.isContextFlagSet(flag) ? '1' : '0');
                return memo;
            }, '');

            logger.debug('serializeTrackingdata=%s', data);
            return data;
        }
    }

    getContext(callback) {
        var self = this;

        if (self.contextDataHolder) {
            return self.contextDataHolder.done(callback);
        }

        var error = new Error('Experimentation-ebay is deprecated.');
        error.code = '500';

        var message = '[Deprecated] experimentation-ebay is deprecated and is replaced by openfeature-ebay. Please see go/experimentation-ebay-deprecation to learn how to remove the dependency and upgrade.';
        logger.error(message, error);

        var contextDataHolder = self.contextDataHolder = new DataHolder();
        contextDataHolder.done(callback);

        // Defaulting to returning mock response since API is deprecated
        const epContextMockResponse = {
            "logId": null,
            "treatments": [],
            "qTags": [],
            "rLogId": null,
            "ack": "SUCCESS",
            "epQualificationResult": null
        };
        contextDataHolder.resolve(new ExperimentationContext(self, epContextMockResponse));
    }

    track(data) {
        var req = this.req;
        // track experimentation tags
        if (!req.ebay.tracking) {
            logger.warn('Tracking context is not found, skipping tracking qTags for experimentation');
            return;
        }

        if (data && data.qTags) {
            data.qTags.forEach(function (tag) {
                // filter invalid tags
                if (!tag || !tag.key || tag.key === 'ct' || tag.value === null) {
                    return;
                }

                // EXPRMT-14017 filter not used tags that exceed tracking limit: qt, qc, uqt, uqc
                if (tag.key === SKIPPED_TAGS.USER_QUALIFIED_TREATMENTS ||
                    tag.key === SKIPPED_TAGS.CONTEXT_QUALIFIED_TREATMENTS ||
                    tag.key === SKIPPED_TAGS.UID_QUALIFIED_TREATMENTS ||
                    tag.key === SKIPPED_TAGS.CONTEXT_QUALIFIED_UID_TREATMENTS) {

                    debug("Drop tag to tracking, skip tag:" + tag.key);
                    return;
                }

                // log tags
                if (tag.type === 'VECTOR') {
                    req.ebay.tracking.trackVectorTag(tag.key, tag.value.split(','));
                } else {
                    req.ebay.tracking.trackTag(tag.key, tag.value);
                }
            });
        }
    }

    trackFailedTreatment(treatment) {
        var treatmentId = treatment.treatmentId;
        if (!this._loggedTreatments[treatmentId]) {
            var tracking = this.req && this.req.ebay && this.req.ebay.tracking;
            this._loggedTreatments[treatmentId] = true;

            if (tracking) {
                tracking.trackVectorTag(Tracking.Tags.EP_TRAFFIC_LOSS_EXPERIMENTS,
                    treatment.experimentId);
                tracking.trackVectorTag(Tracking.Tags.EP_TRAFFIC_LOSS_TREATMENTS,
                    treatmentId);
            }
        }
    }

    trackServedTreatment(treatment) {
        var treatmentId = treatment.treatmentId;
        if (!this._loggedTreatments[treatmentId]) {
            var tracking = this.req && this.req.ebay && this.req.ebay.tracking;
            this._loggedTreatments[treatmentId] = true;

            if (tracking) {
                tracking.trackVectorTag('xe', treatment.experimentId.toString());
                tracking.trackVectorTag('xt', treatmentId.toString());
            }
        }
    }

    preflightRequestHeaders(ctx, options, callback) {
        debug('EP:PreflightRequestHeaders', options);

        options = options || {};
        const epConfig = options.ep;
        const epType = epConfig && epConfig.type || epConfig || REQUEST_HEADERS.EPRESULT;

        options.headers = options.headers || {};

        if (epType === REQUEST_HEADERS.EPRESULT) {
            return this.getContext(function (err, epContext) {
                var encodedEPQualificationResult = epContext && epContext.getEncodedEPQualificationResult && epContext.getEncodedEPQualificationResult();

                if (encodedEPQualificationResult) {
                    options.headers[REQUEST_HEADERS.HEADER_KEY] = encodedEPQualificationResult;
                } else {
                    logger.warn('Cannot add Experimetation Headers, encodedEPQualificationResult is', encodedEPQualificationResult);
                }
                callback(null, options);
            });
        }

        if (epType === REQUEST_HEADERS.OPTIN_COOKIE) {
            var optin = {};
            var optinFlag = this.getOptedIntoFlag();

            if (optinFlag && optinFlag !== '-1') {
                optin['EP_OPTIN'] = optinFlag;
            }

            var fsom = this.ebay && this.ebay.getEndUserContext() && this.ebay.getEndUserContext().userPrefersDesktopExperience();
            if (fsom) {
                optin.CHANNEL = 1;
            }

            // If app overrode the channel to email use it to overrrid fsom.
            var emailChannel = this.req && this.req.emailChannel;
            if (emailChannel) {
                optin.CHANNEL = 6;
            }

            if (epConfig && epConfig.responseHeader === false) {
                optin.noepheader = 1;
            }

            var userSegment = this.getUserSegment();
            if (userSegment) {
                optin['USERSEGMENT'] = userSegment;
            }

            var epHeaderValue = hmv.create(optin);
            options.headers[REQUEST_HEADERS.HEADER_KEY] = epHeaderValue.toString();
        }
        callback(null, options);
    }

    handleResponseHeaders(ctx, headers) {
        debug('EP:HandleResponseHeaders', headers);
        var headerVal = headers && (headers[RESPONSE_HEADERS.HEADER_KEY_LC] || headers[RESPONSE_HEADERS.HEADER_KEY_UC]);
        this.setExperimentTreatements(headerVal);
    }

    redirect(status, location) {
        this.res.redirect(status, location);
    }

    addParams(params) {
        extend(true, this.params, params);
        // prepare for a new context request in the same flow
        this.contextDataHolder = undefined;
    }

    getGuid() {
        // Non-live guid override
        let guidOverride;

        if (env.isNotLive()) {
            guidOverride = this.req.query && this.req.query._guid;
        }

        return guidOverride || this.ebay.getGuid();
    }

    getSiteId() {
        return this.ebay.getSiteId();
    }

    getUserLocale() {
        return this.ebay.getAcceptLanguages()[0];
    }

    getUserId() {
        return this.ebay.getBestUserId();
    }

    getDeviceInfo() {
        return this.req && this.req.deviceInfo;
    }

    getPageId() {
        return this.ebay.getPageId();
    }

    getPageName() {
        return this.ebay.getPageName && this.ebay.getPageName();
    }

    getPoolName() {
        return this.ebay.appContext.poolName;
    }

    getUserAgent() {
        return this.ebay.getUserAgent();
    }

    getCountryCode() {
        return this.req && this.req.locality && this.req.locality.country;
    }

    getTrafficSource() {
        var mkcid = this.req && this.req.query && this.req.query.mkcid;
        if (mkcid && Array.isArray(mkcid)) {
            if (mkcid.length > 0) {
                return mkcid[0];
            }
            return undefined;
        }
        return mkcid;
    }
}

module.exports = Context;

module.exports._internals = {
    setFLAGS(value) {
        FLAGS = value;
    },
    setGlobalFlags(value) {
        GlobalFlags = value;
    }
};

function createInternals(context) {
    return {
        getDefaultParams() {
            const defaultParams = {
                client: {
                    siteId: context.getSiteId(),
                    channelId: Api.CHANNEL_ENUM.OTHER
                },

                userIdentity: {
                    guid: context.getGuid()
                },

                sendQtags: true,
                optedInto: context.getOptedIntoFlag(),

                contextParams: {
                    DATE: '' + Date.now(),
                    IP: context.getRemoteAddr(),
                    PAGEID: context.getPageId(),
                    REFERER: context.getReferer(),
                    SITEID: '' + context.getSiteId(),
                    USERAGENT: context.getUserAgent(),
                    USERLOCALE: context.getUserLocale(),
                    POOLNAME: context.getPoolName(),
                    COUNTRYCODE: context.getCountryCode()
                },

                additionalParams: {
                    isBOT: context.isBOTRequest()
                },

                filterCriteria: {}
            };

            const cookiesAndCookielets = context.getCookiesAndCookielets();
            if (cookiesAndCookielets) {
                defaultParams.contextParams.COOKIES = cookiesAndCookielets.cookies;
                defaultParams.contextParams.COOKIELETS = cookiesAndCookielets.cookielets;
            }

            const userId = context.getUserId();
            if (userId) {
                defaultParams.userIdentity.userId = userId;
            }

            const userSegment = context.getUserSegment();
            if (userSegment) {
                defaultParams.contextParams.USERSEGMENT = userSegment;
            }

            if (context.isEmailChannel()) {
                defaultParams.client.channelId = 6;
                defaultParams.contextParams.TRAFFICSOURCE = context.getTrafficSource();
            } else {
                const deviceInfo = context.getDeviceInfo();
                if (deviceInfo) {
                    const channelId = Api.getChannelId(deviceInfo);
                    defaultParams.client.channelId = channelId;
                    if (channelId !== Api.CHANNEL_ENUM.ANDROID_APP && channelId !== Api.CHANNEL_ENUM.IOS_APP) { // not native channel
                        defaultParams.contextParams.TRAFFICSOURCE = context.getTrafficSource();
                    }
                } else {
                    defaultParams.contextParams.TRAFFICSOURCE = context.getTrafficSource();
                    logger.error('Device detection middleware is not injected before calling EP defaulting channel to WEB (id = 1)');
                }
            }
            return defaultParams;
        }
    };
}
