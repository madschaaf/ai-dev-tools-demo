const waitForElement = (selector) => {
    return new Promise(function (resolve, reject) {
        var element = document.querySelector(selector);

        if (element) {
            resolve(element);
            return;
        }

        var observer = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
                var nodes = Array.from(mutation.addedNodes);
                for (var node of nodes) {
                    if (node.matches && node.matches(selector)) {
                        observer.disconnect();
                        resolve(node);
                        return;
                    }
                };
            });
        });

        observer.observe(document.documentElement, { childList: true, subtree: true });
    });
}

const getTagValue = (qTags, key) => {
    if (qTags && qTags.length) {
        const qTag = qTags.filter(tag => (tag.key === key));
        if (qTag && qTag.length && qTag[0] && qTag[0].value) {
            return qTag[0].value;
        }
    }
    return null;
}

// Add siteId in params to support multi-site. Different siteIds should be handled in handlers.
const executeHandler = (handler, factor, siteId) => {
    try {
        handler(siteId);
    } catch (error) {
        console.error(`CSEP Error: while executing handler for ${factor.name}`, error);
    }
}

const runExperiments = (experiments) => {
    const el = document.querySelector('#clientSideExperiments');
    if (el && el.value) {
        const { qTags, clientSideEps, siteId } = JSON.parse(el.value);
        const { pageci, operationid } = el.dataset;
        const qTagValue = getTagValue(qTags, 'ec');
        clientSideEps.forEach(ep => {
            const { factors = [], treatmentId } = ep;
            factors
                .filter(f => experiments.hasOwnProperty(f.name))  // when ep has multiple factors
                .forEach(factor => {
                    // To support multiple treatments in an ep, change the value in experiments to a list of handlers.
                    const handlerList = experiments[factor.name];
                    handlerList.forEach(({ qualifier, handler }) => {
                        if (factor.value === qualifier) {
                            dropXt(treatmentId, qTagValue, pageci, operationid);
                            executeHandler(handler, factor, siteId);
                        } else {
                            dropXt(treatmentId, qTagValue, pageci, operationid);
                        }
                    });
                });
        });
    }
}

const dropXt = (treatmentId, qTagValue, pageci, operationid) => {
    const today = new Date(Date.now());
    const payload = {
        flushImmediately: !0,
        eventAction: "TAGXT",
        eventFamily: "EXPRMT",
        operationId: operationid,
        timestamp: today.toUTCString(),
        eventProperty: {
            pageci: pageci,
            xt: treatmentId,
            c: qTagValue
        }
    };
    $(document).trigger("pulsar", payload);
}

module.exports = {
    runExperiments: runExperiments,
    waitForElement: waitForElement,
    getTagValue: getTagValue,
}