'use strict';

/**
 *  eBay Locale resolver
 *  Resolves the Locale based on several HTTP parameters
 *
 *
 */

var url = require('url'),
    utils = require('../utils'),
    CONSTANTS = require('../constants'),
    async = require('async'),
    logger = require('@ebay/logging-inc').logger('locale-ebay/locale-resolver'),
    locationServ = require('@ebay/location-service-ebay'),
    geoServ = require('@ebay/geo-service-ebay'),
    assert = require('assert'),
    LocaleResolver;

/**
 * runs a  pipeline of resolvers based on plan
 * @param plan is a list of actions to performe based on available list of determiners
*/
module.exports = LocaleResolver = function LocaleResolver(req, plan, geoConfig) {
    this.request = req;
    this.geoConfig = geoConfig;
    this.plan = plan;
};

LocaleResolver.prototype.resolve = function resolve(callback) {

    async.reduce(this.plan, {
        req: this.request,
        geoConfig: this.geoConfig || {},
        locality: {
            _determiners: []
        }
    }, function iterator(context, name, callback) {
        var determiner = determiners[name];
        if (!determiner) {
            throw new Error('Cannot find determiner "'+name+'"');
        }
        if (!determiner.predicate || determiner.predicate(context)) {
            logger.debug('determiner:', name);
            assert.ok(determiner.run, 'Determiner '+name+' does not have method run');
            determiner.run(context, callback);
        }
        else {
            callback(null, context);
        }
    }, callback);

};

module.exports.registerDeterminer = function registerDeterminer(determiner, override) {
    assert.ok(determiner.name, 'Determiner should have name');
    assert.ok(determiner.run, 'Determiner should have run method');
    if (!override && determiners[determiner.name]) {
        throw new Error('Determiner "'+determiner.name+'" already registered, use override to force it');
    }
    determiners[determiner.name] = determiner;
};

module.exports.removeDeterminer = function removeDeterminer(name) {
    var d = determiners[name];
    delete determiners[name];
    return d;
};

function needToProceed(context) {
    var locality = context.locality;
    return !(locality.country && locality.localeCountry);
}

var determiners = [
    {
        name: 'viaUserAgent',
        desc: 'Use UserAgent from req header',
        predicate: needToProceed,
        run: function run(context, cb) {
            var req = context.req;
            var userAgent = req && req.headers && req.headers['user-agent'],
                locale = null;

            var target = context.geoConfig.getUserAgentMapping(userAgent);
            if (target) {
                locale = utils.parseUserLocaleCookie(target);
            }
            var locality = context.locality;
            if (locale) {
                locality._determiners.push(this.name);
                locality.country = locality.country || locale.country;
                if (locale.language && locale.localeCountry) {
                    locality.language = locale.language;
                    locality.locale = locale.language + '-' + locale.localeCountry;
                }
            }
            cb(null, context);
        }
    },

    {
        name: 'viaUrl',
        desc: 'Read from Url for internal requests',
        predicate: needToProceed,
        run: function run(context, cb) {
            var req = context.req;
            if (req.query && req.query._ul) {
                // Use the LocationLocale from the "_ul" query string parameter
                // per https://jirap.corp.ebay.com/browse/NODE-1614 we now exposing this parameter to the outside world
                var locale = utils.parseUserLocaleCookie(req.query._ul);
                var locality = context.locality;
                if (locale) {
                    locality._determiners.push(this.name);
                    locality.country = locality.country || locale.country;
                    if (locale.language && locale.localeCountry) {
                        locality.language = locale.language;
                        locality.locale = locale.language + '-' + locale.localeCountry;
                    }
                    locality._isOverride = true;
                }
            }
            cb(null, context);
       }
    },

    {
        name: 'viaBean',
        desc: 'Read from _TestUserLocale',
        predicate: needToProceed,
        run: function run(context, cb) {
            var req = context.req;
            var locality = context.locality;
            //TODO
            var testLocale = null;  //configBean.get('_TestUserLocale');
            if (testLocale && req.ebay.isInternalHost().isInternal) {
                // Use the LocationLocale defined in the config bean
                var locale = utils.parseUserLocaleCookie(testLocale);
                if (locale) {
                    locality._determiners.push(this.name);
                    locality.country = locality.country || locale.country;
                    if (locale.language && locale.localeCountry) {
                        locality.language = locale.language;
                        locality.locale = locale.language + '-' + locale.localeCountry;
                    }
                    locality._isOverride = true;
                }
            }
            cb(null, context);
        }
    },

    {
        name: 'viaCookie',
        desc: 'Read from Cookie',
        predicate: needToProceed,
        run: function run(context, cb) {
            var req = context.req;
            var locality = context.locality;
            var userLocale = req.ebay.cookies.getCookieValue('USER_LOCALE');
            if (userLocale) {
                // Use the LocationLocale from the USER_LOCALE cookielet
                var locale = utils.parseUserLocaleCookie(userLocale);
                if (locale) {
                    locality._determiners.push(this.name);
                    locality.country = locality.country || locale.country;
                    if (locale.language && locale.localeCountry) {
                        locality.language = locale.language || locality.language;
                        locality.locale = locale.language + '-' + locale.localeCountry;
                    }
                    locality.user = locality.user || {};
                    locality.user.country = locale.country;
                    locality._isOverride = true;
                }
            }
            const userZipStr = req.ebay.cookies.getCookieValue('PERSISTENT_DESTINATION_POSTALCODE');
            if (userZipStr && !(locality.user && locality.user.zip)) {
                const userZip = userZipStr.split(',');
                const zip = userZip.shift();
                // get only postal code
                locality.user = locality.user || {};
                locality.user.zip = zip;
            }

            cb(null, context);
        }
    },

    {
        name: 'viaUserLocale',
        desc: 'Read user info from Cookie',
        predicate: needToProceed,
        run: function run(context, cb) {
            var req = context.req;
            var locality = context.locality;
            var userLocale = req.ebay.cookies.getCookieValue('USER_LOCALE');
            let locale;
            if (userLocale) {
                // Use the LocationLocale from the USER_LOCALE cookielet
                locale = utils.parseUserLocaleCookie(userLocale);
                if (locale) {
                    locality._determiners.push(this.name);
                    
                    locality.country = locality.country || locale.country;
                    if (locale.language && locale.localeCountry) {
                        locality.language = locale.language || locality.language;
                        locality.locale = locale.language + '-' + locale.localeCountry;
                    }
                    locality.user = locality.user || {};
                    locality.user.country = locale.country;
                }
            }
            const userZipStr = req.ebay.cookies.getCookieValue('PERSISTENT_DESTINATION_POSTALCODE');
            if (userZipStr && !(locality.user && locality.user.zip)) {
                const userZip = userZipStr.split(',');
                const zip = userZip.shift();
                // get only postal code
                if (zip) {
                    locality.user = locality.user || {};
                    locality.user.zip = zip;
                }
            }

            cb(null, context);
        }
    },

    {
        name: 'viaSiteInfo',
        desc: 'Use site info',
        predicate: function predicate(context) {
            return !context.locality.country;
        },
        run: function run(context, cb) {
            var req = context.req;
            var locality = context.locality;
            var siteInfo = req.ebay.getSiteInfo(),
                localeInfo = siteInfo && siteInfo['locale-info'];
            if (localeInfo) {
                locality._determiners.push(this.name);
                locality.country = locality.country || localeInfo.country;
                locality.language = locality.language || localeInfo.language;
                locality.locale = locality.locale || localeInfo.language + '-' + localeInfo.country;
            }
            cb(null, context);
        }
    },

    {
        name: 'viaDefault',
        desc: 'Use default locale',
        predicate: function predicate(context) {
            return !context.locality.country;
        },
        run: function run(context, cb) {
            var locality = context.locality;
            locality._determiners.push(this.name);
            locality.country = locality.country || CONSTANTS.Country;
            locality.language = locality.language || CONSTANTS.Language;
            locality.locale = locality.locale || CONSTANTS.Locale;

            cb(null, context);
        }
    },

    {
        name: 'countryByIp',
        desc: 'Detect location via IP',
        predicate: function predicate(context) {
            return !context.locality.country &&
                context.req.ebay &&
                !(context.req.ebay.isInternalRequest && context.req.ebay.isInternalRequest());
        },
        run: function run(context, cb) {
            var name = this.name;
            var req = context.req;
            var ebay = req.ebay;
            var ipAddress = ebay.getRemoteAddr();
            if (!ipAddress) {
                return cb(null, context);
            }
            var headers = {'X-EBAY-C-MARKETPLACE-ID': ebay.getMarketplaceId()};

            locationServ.context(req).getLocationByIp(ipAddress, headers, function (err, result) {
                if (err) {
                    context.locality.ipDetectionFailed = true;
                }
                else if (result) {
                    context.locality.country = context.locality.country || result.alpha2ISOcountryCode;
                    context.locality.user = context.locality.user || {};
                    context.locality.user.country = context.locality.user.country || context.locality.country;
                    context.locality.user.zip = context.locality.user.zip || result.postalCode;
                    context.locality._determiners.push(name);
                }
                context.locality._persist2Cookies = true;
                cb(null, context);
            });
        }
    },

    {
        name: 'seoURL',
        desc: 'Resolves geo country based on seo url pattern for geo countries (xx|xx-xx.(.*)?.ebay.com)',
        predicate: context => !context.req.ebay.cookies.getCookieValue('USER_LOCALE'),
        run: function run(context, cb) {
            const req = context.req;
            const ebay = req.ebay;
            const host = req.headers.host;
            const mpId = ebay.getMarketplaceId();

            if (mpId !== 'EBAY-US' || !/^([a-z]{2}|[a-z]{2}-[a-z]{2})\./.test(host)) {
                return cb(null, context);
            }

            const headers = {'X-EBAY-C-MARKETPLACE-ID': mpId};
            const countryDomain = host.split('.', 1).shift();
            const tokens = countryDomain.split('-');
            const country = tokens.pop().toUpperCase();
            const language = tokens.shift();

            geoServ.getGeoByCountryCode(country, headers, (err, geodata) => {
                if (geodata && geodata.hasGeoSubdomain) {
                    const subdomain = geodata.geoSupportedSubdomain[countryDomain] || 
                        geodata.geoSupportedSubdomain[`${language}-${countryDomain}`];
                    if (!subdomain || !subdomain.language) {
                        logger.warn(new Error(`Subdomain or language is not found in geodata for ${countryDomain}, detected country:${country}`));
                        return cb(null, context);
                    }
                    context.locality.language = subdomain.language.split('-').shift();
                    context.locality.locale = subdomain.language;
                    context.locality.country = geodata.alpha2ISOcountryCode;
                    if (context.locality.ipDetectionFailed) {
                        context.locality.user = context.locality.user || {
                            country: 'US'
                        };
                    }

                    context.geodata = geodata;
                    context.locality._determiners.push(this.name);
                }
                cb(null, context);
            });

        }
    },

    {
        name: 'userByIp',
        desc: 'Detect user location via IP, should not have countryByIp together with this handler',
        predicate: function predicate(context) {
            return !(context.locality.user && context.locality.user.country) &&
                context.req.ebay &&
                !(context.req.ebay.isInternalRequest && context.req.ebay.isInternalRequest());
        },
        run: function run(context, cb) {
            var name = this.name;
            var req = context.req;
            var ebay = req.ebay;
            var ipAddress = ebay.getRemoteAddr();
            if (!ipAddress) {
                return cb(null, context);
            }
            var headers = {'X-EBAY-C-MARKETPLACE-ID': ebay.getMarketplaceId()};
            locationServ.context(req).getLocationByIp(ipAddress, headers, function (err, result) {
                if (err) {
                    context.locality.ipDetectionFailed = true;
                }
                else if (result) {
                    context.locality.country = context.locality.country || result.alpha2ISOcountryCode;
                    context.locality.user = context.locality.user || {};
                    context.locality.user.country = context.locality.user.country || context.locality.country || result.alpha2ISOcountryCode;
                    context.locality.user.zip = context.locality.user.zip || context.locality.zip || result.postalCode;
                    context.locality._determiners.push(name);
                }
                context.locality._persist2Cookies = true;
                cb(null, context);
            });
        }
    },

    {
        name: 'geoByCountryCode',
        desc: 'Obtains geo by country code',
        predicate: context => !context.geodata, // run it only if geo has not been loaded
        run: function run(context, cb) {
            var req = context.req;
            var ebay = req.ebay;
            var headers = {'X-EBAY-C-MARKETPLACE-ID': ebay.getMarketplaceId()};

            geoServ.getGeoByCountryCode(context.locality.country, headers, function (err, geodata) {
                if (!err && geodata) {
                    context.geodata = geodata;
                }
                cb(null, context);
            });

        }
    }
].reduce(function (context, item) {
    context[item.name] = item;
    return context;
}, {});
