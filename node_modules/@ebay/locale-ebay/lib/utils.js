'use strict';

const logger = require('@ebay/logging-inc').logger('locale:geoconfig');

module.exports = {

    parseUserLocaleCookie: function (localeCookie) {
        if (!localeCookie || localeCookie.length > 7) {
            return;
        }

        let localeCountry;
        let country;
        let language;

        if (Array.isArray(localeCookie)) {
            localeCookie = localeCookie.shift();
        }
        const localeParts = localeCookie.split && localeCookie.split(/[-_]/, 2);
        if (localeParts.length === 2) {
            localeCountry = localeParts.pop();
            if (!/^[A-Z]{2}$/.test(localeCountry)) {
                return;
            }
        }

        const countryAndLanguage = localeParts.shift();
        if (!/^[A-Z]{2}$|^[a-z]{2}$|^[A-Z]{2}[a-z]{2}$/.test(countryAndLanguage)) {
            return;
        }

        if (/[a-z]{2}$/.test(countryAndLanguage)) {
            language = countryAndLanguage.substring(countryAndLanguage.length - 2);
        }

        if (/^[A-Z]{2}/.test(countryAndLanguage)) {
            country = countryAndLanguage.substring(0, 2);
        }

        return {
            country,
            language,
            localeCountry
        };
    },
    arrayToSet: function (array) {
        var set = {};

        if (array) {
            for (var i = 0, len = array.length; i < len; i++) {
                set['' + array[i]] = true;
            }
        }
        return set;
    },

    normalizeSet: function (set) {
        var normalizedSet = {};

        if (set) {
            for (var k in set) {
                if (set.hasOwnProperty(k)) {
                    var v = set[k];
                    normalizedSet[k] = (v === true || v === 'true');
                }
            }
        }

        return normalizedSet;
    },
    parseUserAgentMappings: function (mappings) {
        if (!mappings) {
            return null;
        }

        var result = [];

        for (var i = 0, len = mappings.length; i < len; i++) {
            var mapping = mappings[i];
            var lastEqual = mapping.lastIndexOf('=');
            if (lastEqual === -1) {
                logger.error('Invalid mapping: ', mapping);
                continue;
            }

            try {
                result.push({
                    pattern: new RegExp(mapping.substring(0, lastEqual)),
                    target: mapping.substring(lastEqual + 1)
                });
            }
            catch (e) {
                logger.error('Invalid mapping: ', mapping, e);
            }
        }

        return result;
    }

};
