'use strict';

var cal = require('@ebay/cal'),
    async = require('async'),
    utils = require('./utils'),
    CONSTANTS = require('./constants'),
    GeoConfig = require('./GeoConfig'),
    CtxGeoConfig = require('./CtxGeoConfig'),
    locationServ = require('@ebay/location-service-ebay'),
    moduleConfig = require('@ebay/module-config-inc'),
    LocaleResolver = require('./resolvers/locale-resolver'),
    directionalityResolver = require('./resolvers/directionality-resolver'),
    logger = require('@ebay/logging-inc').logger('locale-ebay'),
    objutil = require('objutil'),
    AcceptLanguage = require('accept-language'),
    debug = require('debug')('locale');

var localeModuleConfig,
    calEvent,
    CAL_TRANSCATION_TYPE = 'LOCALE';

function initConfig(callback) {
    moduleConfig(module, function (err, config) {
        localeModuleConfig = config.get('locale');
        var localeConfig = config.get('locale-ebay');
        var geoConfig = new GeoConfig(localeModuleConfig, localeConfig);
        callback(null, {
            geoConfig: geoConfig,
            localeConfig: localeConfig
        });
        return;
    });
}

function buildLocality(req, res, config, baseLocality, geodata) {
    geodata = geodata || {};
    var geoConfig = config.geoConfig;

    var ebay = req.ebay;

    var userPrefs = ebay.siteInfo && ebay.siteInfo['user-preferences'] || {};
    var siteId = ebay.getSiteId() || 0;
    var country = geodata.alpha2ISOcountryCode || geodata.country || baseLocality.country;
    var language = geodata.defaultLanguage;
    if (language && language.indexOf('-') !== -1) {
        language = language.split('-')[0];
    } else {
        language = geodata.language || CONSTANTS.Language;
    }
    var defaultLanguage = geodata.defaultLanguage || geodata.locale || baseLocality.locale || CONSTANTS.Locale;
    var supportedLanguages = geodata.supportedLanguages || [defaultLanguage];
    var locale = defaultLanguage;

    // this route only uses supported lanaguegs
    // TODO: this should go away eventually as the main logic has been moved to i18n-ebay
    //       as it is only language resolution, not location locate or marketplace,
    //       hence its place is i18n-ebay module
    if (ebay.isService || (config.localeConfig['accept-language'] && geodata.isGeoCountry)) {
        // accept language for service or if explicitly enabled
        const acceptLanguage = AcceptLanguage.create();
        acceptLanguage.languages([...supportedLanguages, CONSTANTS.Locale]);
        locale = acceptLanguage.get(req.headers['accept-language']) || defaultLanguage;
    }

    if (baseLocality._isOverride &&
            supportedLanguages.indexOf(baseLocality.locale) !== -1) {

        locale = baseLocality.locale || locale;
        language = baseLocality.language || language;
        country = baseLocality.country || country;
    }

    var directionality = directionalityResolver.resolve(language);
    var locality = {
        country  : country || CONSTANTS.Country,
        countryId: geodata.countryId || 1,
        isGeoCountry: geodata.isGeoCountry || false,
        siteId: geodata.siteId || siteId,
        locale : locale,
        language : language,
        defaultLanguage: defaultLanguage,
        supportedLanguages: supportedLanguages,
        directionality : directionality,
        isoCurrencyCode: geodata.isoCurrencyCode || CONSTANTS.CurrencyCode,
        siteDefaultIsoCurrencyCode: geodata.siteDefaultIsoCurrencyCode || CONSTANTS.CurrencyCode,
        timeZone : geodata.timeZone || userPrefs.timeZone || CONSTANTS.TimeZone,
        timeZoneStd: geodata.timeZoneStd || userPrefs.timeZoneNameStd || CONSTANTS.TimeZoneStd,
        timeZoneSummer: geodata.timeZoneSummer || userPrefs.timeZoneNameSummer || CONSTANTS.TimeZoneSummer,
        getGeoConfig: function () {
            return this.geoConfig || (this.geoConfig = new CtxGeoConfig(req, geoConfig));
        }
    };

    req.locality = objutil.mixin(locality, req.locality || {});

    //adding locality in res.locals.context for client side to consume
    res.locals = res.locals || {};
    res.locals.context = res.locals.context || {};
    res.locals.context.locality = locality;

    if (res.headers && locality) {
        res.headers['Content-Language'] =  (locality.locale || locality.defaultLanguage);
    }

    let userZip;
    let userCountry;
    let localeCookie;
    if (!req.ebay.isService) {
        var user = baseLocality.user;
        userZip = req.locality.user && req.locality.user.zip || user && user.zip;
        userCountry = req.locality.user && req.locality.user.country || user && user.country;
        localeCookie = ebay.cookies.getCookieValue('USER_LOCALE');
        if (baseLocality._persist2Cookies) {
            if (localeCookie !== locality.country) {
                // user locale should be set only with country, the locale can only be set by GH on client side
                ebay.cookies.setCookieValue('USER_LOCALE', userCountry || locality.country);
            }
            if (userZip) {
                ebay.cookies.setCookieValue('PERSISTENT_DESTINATION_POSTALCODE', userZip);
            }
        }
        // update user context
        const euc = ebay.getEndUserContext && ebay.getEndUserContext();
        if (euc) {
            // update user physical location based on locality
            const ulc = euc.getUserPhysicalLocation();
            const userGeoCountry = userCountry || req.locality.country;
            ulc.setCountry(userGeoCountry);
            req.locality.unrecognizedUSUserOnIntlSite = siteId !== 0 && userGeoCountry && userGeoCountry === 'US' && !ebay.getCorrelationGuid();
            if (userZip) {
                ulc.setZip(userZip);
            }
        }
    }

    if (cal) {
        calEvent = cal.createEvent(CAL_TRANSCATION_TYPE, 'locale');
        calEvent.status = cal.Status.SUCCESS;
        calEvent.correlationId = req.correlationId;
        calEvent.addData(CONSTANTS.CAL_COUNTRY_KEY, locality.country);
        calEvent.addData(CONSTANTS.CAL_LANGUAGE_KEY, locality.language);
        calEvent.addData(CONSTANTS.CAL_LOCALE_KEY, locality.locale);
        calEvent.addData(CONSTANTS.CAL_RULE_KEY, (baseLocality._determiners || []).join(','));
        if (localeCookie) {
            calEvent.addData('USER_LOCALE', localeCookie);
        }
        calEvent.complete();
    }


    // track geo attributes
    if (req.ebay.tracking) {
        req.ebay.tracking.trackTag('uc', locality.countryId);
        req.ebay.tracking.trackTag('bs', locality.siteId);
        req.ebay.tracking.trackTag('ul', locality.locale);
        if (locality.isGeoCountry) {
            req.ebay.tracking.trackContextFlag(15);
        }
    }
    else {
        logger.warn('Tracking context is not found, skipping tracking of geo tags');
    }
}

function _resolve(req, res, config, callback) {
    var localeResolver;
    var plan = selectPlan(req, config);
    localeResolver = new LocaleResolver(req, plan, config.geoConfig);
    localeResolver.resolve(function (err, result) {
        if (!err && result) {
            buildLocality(req, res, config, result.locality, result.geodata);
        } else {
            buildLocality(req, res, config, result.locality);
        }
        callback();
    });
}

function selectPlan(req, config) {
    var geoConfig = config.geoConfig;
    var plans =  config.localeConfig.plans;
    if (req.locality && req.locality.plan) {
        return req.locality.plan;
    }
    var nonGeoContext;
    var ebay = req.ebay;

    var siteId = ebay.getSiteId() || 0;
    var pageName = ebay.getPageName();
    var ipAddress = ebay.getRemoteAddr();

    if (!geoConfig.isSiteEnabled(siteId)) {
        debug('Geo disabled for site: ', siteId);
        nonGeoContext = true;
    }

    if (geoConfig.isBlacklistedCommand(pageName)) {
        debug('Page is blacklisted for Geo: ', pageName);
        nonGeoContext = true;
    }

    return plans[!nonGeoContext && !req.ebay.isService ? 'geo': 'default'];
}

function resolve(req, res, cb) {
    initConfig(function (err, config) {
        _resolve(req, res, config, cb);
    });
}

module.exports = function nodeLocale(options) {
    options = options || {};
    return function locale(req, res, next) {
        resolve(req, res, next);
    };
};

module.exports.registerDeterminer = LocaleResolver.registerDeterminer;
module.exports.removeDeterminer = LocaleResolver.removeDeterminer;
