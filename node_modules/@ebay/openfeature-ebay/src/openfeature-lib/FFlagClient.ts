import {
    ErrorCode,
    EvaluationContext,
    ResolutionDetails,
} from '@openfeature/js-sdk';
import cal from '@ebay/cal';
import { Logger, getLogger } from "@ebay/logging-inc";

import { FlagEvalDetail } from './types/FlagEvalDetail';

/**
 * FFlagClient is only used to check the evaluation results map for the flag evaluation for the {@link OpenFeatureProvider}
 * The reevaluation logic and calls to epsvc are handled by the experimentationhook in the before lifecycle.
 */
export class FFlagClient {
    logger: Logger;
    constructor() {
        this.logger = getLogger(
            'openfeature-ebay:fflagClient',
        );
    }
    /**
     * Generic method to evaluate the incoming feature flag for each data type that is supported.
     * Default dropTag is set to false as this functionality is not yet supported in espvc.
     * Current implementation with openfeature only supports one feature flag per request, which
     * is why the flagEvals array is created with only a snigle feature flag.
     * @param flagKey
     * @param evalCriteria
     * @returns resolutionDetails evaluation details from epsvc response
     */
    async evaluateFlag(
        flagKey: string,
        evalContext: EvaluationContext,
        evaluationResultsMap: Map<string, FlagEvalDetail>
    ): Promise<FlagEvalDetail> {
        const flagEvalDetail: FlagEvalDetail = await this.fetchFlagEvalDetail(
            flagKey,
            evaluationResultsMap,
        );
        this.handlePoolMismatch(flagEvalDetail);
        return flagEvalDetail;
    }

    /**
     * Given a feature flag key, this method will return the flag evaluation details.
     * ExperimentationHook does the heavy lifting now of re-evaluating the flag in cases for not found or deferred.
     * @param flagKey
     * @param evalContext 
     * @param _evaluationResults 
     * @returns 
     */
    async fetchFlagEvalDetail(
        flagKey: string,
        _evaluationResults: Map<string, FlagEvalDetail>
    ): Promise<FlagEvalDetail> {
        if (!_evaluationResults || _evaluationResults.size == 0) {
            this.logger.debug(`Evaluation results was empty.`);
        }
    
        const flagEvalFromStore = await this.fetchFlagEvaluationFromStore(flagKey, _evaluationResults);
    
        // ExperimentationHook should stub flags that were not found, so this shouldn't happen.
        if (!flagEvalFromStore) {
            this.logger.warn(`Didn't find evaluation from store for ${flagKey}`);
            return null;
        }
    
        return flagEvalFromStore;
    }

    /**
     * This method returns the flag evaluation details from the evaluationResultsMap (store) for the flag key that was passed in.
     * @param flagKey 
     * @param evaluationResultsMap 
     * @returns flagEvaluDetail
     */
    async fetchFlagEvaluationFromStore(
        flagKey: string,
        evaluationResultsMap: Map<string, FlagEvalDetail>
    ): Promise<FlagEvalDetail> {
        const flagEvalDetail = evaluationResultsMap.get(flagKey);
        return flagEvalDetail;    
    }

    /**
     * Flushes a CAL event if the pool is mismatched and is not a pure feature flag. Related JIRA tickets:
     * https://jirap.corp.ebay.com/browse/TS-1724 - Raptor io inline implementation
     * https://jirap.corp.ebay.com/browse/TS-4705 - This change in openfeature-ebay
     * The same implementation can be found on raptor io:
     * raptor-experimentation-impl/src/main/java/com/ebay/experimentation/impl/openfeature/UniversalProviderUtil.java
     * @param flagEval 
     */
    handlePoolMismatch(flagEval: FlagEvalDetail) {
        if (flagEval) {
            const isPoolMatched: boolean = flagEval.isPoolMatched ?? true;
            const isPureFeatureFlag: boolean = flagEval.isPureFeatureFlag;

            if (this.logger.isLogLevelEnabled('debug')) {
                const debugEvent = cal.createEvent('DEBUG', 'VARIABLE');
                debugEvent.addData(`isFeatureFlag= ${isPureFeatureFlag};isPoolMatched=${isPoolMatched}`)
                debugEvent.complete(cal.Status.SUCCESS);
            }
            if (!isPureFeatureFlag && !isPoolMatched){
                // This warning log with status=1 (FATAL) will bypass the opentracing 1% sampling, allowing Touchstone
                // to capture domain pool mismatch events even with minimal Experiment traffic during validation.
                const poolMismatchEvent = cal.createEvent('Warn', 'POOL_MISMATCHED')
                poolMismatchEvent.addData('This App pool does not match the pool list registered from Touchstone');
                poolMismatchEvent.complete(cal.Status.FATAL);
            }
        }
    }
}

export function translateResult<T>(
    flagEval: FlagEvalDetail,
): ResolutionDetails<T> {
    const { details } = flagEval;
    return {
        value: flagEval.featureFlagValue,
        variant: (details && details.variantId.toString()) || '',
        reason: (details && details.reason) || '',
        errorCode:
            (details && (details.errorCode as ErrorCode)) || ErrorCode.GENERAL,
        flagMetadata: {
            isPureFeatureFlag: flagEval?.isPureFeatureFlag,
            isClientSide: flagEval?.isClientSide || false,
            variantName: details && details.variantName,
            variantDataType: details && details.variantDataType,
            deferredForRuleLevel: details && details.deferredForRuleLevel,
            deferredForEpAaffLevel: details && details.deferredForEpAaffLevel
        },
    };
}

export function convertToBoolean(stringBool: string): boolean | null {
    if (typeof stringBool === 'boolean') {
        return stringBool;
    }

    if (
        stringBool == null ||
        typeof stringBool !== 'string' ||
        stringBool === ''
    ) {
        return null;
    }

    if (stringBool.toLowerCase() === 'true') {
        return true;
    }

    if (stringBool.toLowerCase() === 'false') {
        return false;
    }

    return null;
}
