import { Client, OpenFeature } from '@openfeature/js-sdk';
import modConfig from '@ebay/module-config-inc';
import { promisify } from 'util';
import { trace } from '@opentelemetry/api';

const loadConfig = promisify(modConfig);

import { MetricsPublisherHook } from './hooks/MetricsPublisherHook';
import { MetricsPublisher } from './metrics/MetricsPublisher';
import OpenFeatureProvider from './provider/OpenFeatureProvider';
import { create } from './openfeature-context';
import { FFlagClient } from './FFlagClient';
import { EPOpenfeatureAPI } from './EPOpenfeature';
import { Context } from './openfeature-context/Context';
import { ExperimentationHook } from './hooks/ExperimentationHook';
import Services from './Services';
import { translateTags } from './tracking/utils';
import DiagnosticsHook from './hooks/DiagnosticsHook';
import { FeatureFlagSpanProcessor, featureFlagSpanManager, TracingDataHolder } from './tracing';
import { setErrorMetricsToTracingDataHolder } from './tracing/FeatureFlagEventUtils';
const logger = require('@ebay/logging-inc').logger(
    'openfeature-ebay:middleware',
);
// saved flags list for smart client
const smartClientFlagsSet: Set<string> = new Set();

// saved labels for evaluation with smart client
const labelForEvalSet: Set<string> = new Set();

// to be used for flag configurations or labels
export const openfeatureGlobalCache: Map<String, Object> = new Map<String, Object>();

openfeatureGlobalCache.set('smartClientFlagsSet', smartClientFlagsSet);
openfeatureGlobalCache.set('labelForEvalSet', labelForEvalSet);
// boolean to check whether flags have been initalized. After the first web request, it will be set to true. If the boolean is true and the flags and label sets are empty, it will skip calls to epsvc
openfeatureGlobalCache.set('flagsInitialized', false);
const NANOSECONDS_PER_SECOND: number = 1000000000;
const provider = trace.getTracerProvider() as any;
export default function openfeature(options = {} as any) {
    const metricsPublisher = new MetricsPublisher();
    let flagClient = new FFlagClient();
    const openfeatureProvider = new OpenFeatureProvider(flagClient);
    OpenFeature.setProvider('ep-openfeature', openfeatureProvider);
    OpenFeature.addHooks(new MetricsPublisherHook(metricsPublisher));

    // configure feature flag span processor with configurable TTL
    const featureFlagProcessor = new FeatureFlagSpanProcessor();
    
    const errorTracingProcessingEnabled = options.errorTracing ?? true;
    // Safely add span processor - if errorTracing option is configured to false in middleware configuration it will skip processor
    try {
        if (errorTracingProcessingEnabled && provider && provider._delegate && provider._delegate.addSpanProcessor) {
            provider._delegate.addSpanProcessor(featureFlagProcessor);
            // Register globally for middleware access
            featureFlagSpanManager.setProcessor(featureFlagProcessor);
        } else {
            logger.debug('Span processor not available, skipping span processor setup');
        }
    } catch (error) {
        logger.debug('Failed to setup span processor:', error);
    }
    return async function openfeatureMiddleware(req, res, next) {
        const routeConfig =
            req.route && req.route.config && req.route.config.openfeature;
        if (routeConfig && routeConfig.enabled === false) {
            logger.debug(
                'Openfeature is disabled for this route. Please check routes.json if this is not expected',
            );
            return next();
        }
        
        const startTimeInNanoSeconds = process.hrtime.bigint(); // returns time in nanoseconds

        const client: Client = OpenFeature.getClient('ep-openfeature');
        const context: Context = create(req, res, openfeatureGlobalCache);
        req.ebay = req.ebay || {};
        client.setContext(context.getContextParams());
        client.addHooks(new ExperimentationHook(context));
        // add diagnostics hook to the client
        const diagnosticsHook = new DiagnosticsHook(context);
        client.addHooks(diagnosticsHook);
        context.setServiceClient(new Services());
        // add context to req object
        const epOpenfeature = new EPOpenfeatureAPI(context, client);
        req.ebay.openfeature = epOpenfeature;

        // publish qualification input details to the cal
        diagnosticsHook.publishDataToCal('EP_DIAGNOSTICS', 'DIAGNOSTICS_DATA', diagnosticsHook.createQualificationInput(context));


        // check if openfeature is enabled after setting openfeature client. This ensures the client is not null if openfeature is disabled on this environment
        const config = await loadConfig(__dirname);
        const openfeatureEnabled = config?.get?.('openfeature:enabled');
        // This allows disabling error trace writes to CAL on the fly without restarting the application. Because FeatureFlagSpanProcessor is configured on startup it will continue processing spans if enabled.
        const errorTracingPublishingEnabled = config?.get?.('openfeature:errorTracing');
        if (!openfeatureEnabled) {
            logger.debug(
                'Openfeature is disabled for this environment. Please check your environment config.json if this is not expected',
            );
            return next();
        }
        
        context.initializeFFPromise = initializeFeatureFlags(context)
            .catch(err => logger.debug('Failed to initialize feature flags: %s', err));

        
        metricsPublisher.usageCounter.inc(
            {
                apiName: 'benchmark',
                status: 'success',
                techStack: 'nodejs',
            },
            1,
        );

        const currentTimeInNanoSeconds = process.hrtime.bigint(); // returns time in nanoseconds
        const nsDuration =
            currentTimeInNanoSeconds - startTimeInNanoSeconds;
        // converting to seconds to make it same as raptor and raptorio
        const secondsDuration: number =
            Number(nsDuration) / NANOSECONDS_PER_SECOND;
        metricsPublisher.apiBenchmarkLatencySla
            .labels('nodejs')
            .observe(secondsDuration);  

        //call flushExptTagsToTracking within openfeature-ebay to send all the experimentation tags to tracking
        //call flushDiagnosticsDataToCal to send the diagnostics data to CAL
        res.on('finish', function flushDataToTrackingAndCal() {
            let traceId = '';
            try {
                // this is the end of the request, so any future requests will indicate smart list state is stable from the first request
                openfeatureGlobalCache.set('flagsInitialized', true);

                /**
                 * req.otel.isRecording: determined by opentelemetry -- whether traces are recorded, a prerequisite to processing feature flag events
                 * errorTracingProcessingEnabled -- configured on application startup to determine whether to hook up FeatureFlagSpanProcessor to capture error events.
                 *  - This option can only be changed on application startup and is set in the middleware.json openfeature-ebay arguments ("arguments": [{"errorTracing": false}])
                 * errorTracingPublishingEnabled -- configured by config bean and can determine whether to process the trace errors and publish feature_flag_data to CAL
                 *  - This option can be configured on the fly using validate internals.
                 * 
                 */
                if (req.otel?.isRecording && errorTracingProcessingEnabled && errorTracingPublishingEnabled) {
                    traceId = req.otel.traceId;
                    const lce = featureFlagSpanManager.getLoggingContextError(traceId);    
                    const commandName = req.route?.name || 'unset';                
                    setErrorMetricsToTracingDataHolder(context, traceId, lce, commandName);
                    diagnosticsHook.publishWithRespCode(TracingDataHolder.getCalDataListById(traceId), res.statusCode);
                }
                diagnosticsHook.flushDiagnosticsDataToCal();
                context.flushExptTagsToTracking(); /// <<<<<< WILL they be there, what happens if initializeFeatureFlags fails???
            } catch (error) {
                logger.error('Error in OpenFeature finish handler:', error);
            } finally {
                // ensure tracing data holder is cleaned up on res finish to prevent memory leak.
                TracingDataHolder.removeByTraceId(traceId);
                featureFlagSpanManager.removeTrace(traceId);
            }
        });
        next();
    };

    async function initializeFeatureFlags(
        context: Context
    ) {
        const startTimeInNanoSeconds = process.hrtime.bigint(); // returns time in nanoseconds
        const keys: Set<string> = openfeatureGlobalCache.get('smartClientFlagsSet') as Set<string>;
        let labelForEval: Set<string> = openfeatureGlobalCache.get('labelForEvalSet') as Set<string>;
        let flagsInitialized: boolean = openfeatureGlobalCache.get('flagsInitialized') as boolean;

        // check whether flags are initalized before. If flags are initialized (not startup call) and smart client flags and label sets are empty, skip the call to epsvc
        if (flagsInitialized && keys.size === 0 && labelForEval.size === 0) {
            logger.debug(
                'Flag Keys and Labels are empty but this is not a startup call. Skipping call to epsvc.',
            );
            const evaluationResultsMap = new Map();
            const emptyEvaluationResults = {
                evaluationResultsMap,
                epTagsEvent: null,
            };
            context.setEvaluationResults(emptyEvaluationResults.evaluationResultsMap, keys);
            context.setEpTagsEventMap(
                translateTags(emptyEvaluationResults.epTagsEvent),
            );
            return Promise.resolve('skipped');
        }
    
        const contextParams = context.getContextParams();
        if (labelForEval) {
            contextParams.labelForEval = Array.from(labelForEval);
        }
    
        contextParams.shouldUseEPCache = true; // this is now the default, but we still need to pass along the shouldUseEPCache value
        const data = await context.getServiceClient()
            .invokeInternalSearchApiByFlagList(contextParams, keys);
    
        if (data && data.evaluationResultsMap) {
            context.setEvaluationResults(data.evaluationResultsMap, keys);
            context.setEpTagsEventMap(
                translateTags(data.epTagsEvent),
            );
            logger.debug(
                'Added %s evaluations into context.',
                data.evaluationResultsMap.size,
            );
        }      
        const currentTimeInNanoSeconds = process.hrtime.bigint(); // returns time in nanoseconds
        const nsDuration =
            currentTimeInNanoSeconds - startTimeInNanoSeconds;
        // converting to seconds to make it same as raptor and raptorio
        const secondsDuration: number =
            Number(nsDuration) / NANOSECONDS_PER_SECOND;
            metricsPublisher.apiQualificationLatencySla
            .labels('nodejs')
            .observe(secondsDuration);  
        return Promise.resolve('done');
    }

}
