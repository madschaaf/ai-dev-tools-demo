import {
    EvaluationContext,
    EvaluationDetails,
    FlagValue,
    Hook,
    HookContext,
    HookHints,
} from '@openfeature/js-sdk';
import { Context } from '../openfeature-context/Context';
import { ApiLog } from '../types/ApiLog';
import { DiagnosticsData, DebugCodes } from '../types/DiagnosticsData';
import { getChannelId } from '../Api';
import { FeatureFlagRawEvent } from '../types/FeatureFlagRawEvent';
import { FeatureFlagCalEvent } from '../types/FeatureFlagCalEvent';
import { CalResponseCodeUtils } from '../types/CalResponseCode';
const logger = require('@ebay/logging-inc').logger(
    'openfeature-ebay:diagnosticsHook',
);
const cal = require('@ebay/cal');
cal.setDefaultWriteStream('cal'); // if you want to print to console, use cal.setDefaultWriteStream('console')

/**
 * DiagnosticsHook is an implementation of the Hook interface that collects diagnostic data
 * during feature flag evaluations and publishes it to CAL (Common Application Logging).
 * 
 * This hook is used for preparing the diagnostic data. It set the apiLogList in context with required values
 * from response based on flag evaluation and then publish to the CAL. 
 * It uses @ebay/cal library and cal.createEvent method to create the log event. 
 * 
 * @param context - The context object containing API log list and other diagnostic information.
 */
export default class DiagnosticsHook implements Hook {
    context: Context;
    constructor(context) {
        this.context = context;
    }

    /**
     * Adds diagnostic data to the API log list if the feature flag key is not already present.
     *
     * @param hookContext - The context of the hook containing information about the feature flag evaluation.
     * @param evaluationDetails - The details of the flag evaluation, including metadata such as variant and reason.
     */
    addDataToApiLogList(hookContext: HookContext, evaluationDetails: EvaluationDetails<FlagValue>) {
        // add data to apiLogList
        const apiLog = new ApiLog();
        apiLog.apiName = 'openfeature-ebay';
        apiLog.input = {
            GENERATE_TAG: hookContext.context.dropTag,
            featureFlagKey: hookContext.flagKey,
        };
        apiLog.output = {
            variantId: evaluationDetails?.variant ? evaluationDetails?.variant : null,
            evaluationStatus: evaluationDetails?.reason ? evaluationDetails?.reason : "",
        };
        // add the apiLog to context's apiLogList
        this.context.apiLogList.push(apiLog);
    }

    /**
     * Flushes the diagnostics data to CAL (Common Application Logging).
     *
     * This method is called from middleware.ts when diagnostics data with ApiLogList is ready 
     * and response is returned. 
     */
    flushDiagnosticsDataToCal() {
        try {
            var diagnosticsData : DiagnosticsData = new DiagnosticsData();
            diagnosticsData.apiLogList = this.context.apiLogList;
            // for diagnostics data, we are using EP_DIAGNOSTICS as event type and DIAGNOSTICS_DATA as event name
            this.publishDataToCal('EP_DIAGNOSTICS', 'DIAGNOSTICS_DATA', diagnosticsData);
        } catch (error) {
            logger.error(`error occurred in flushDiagnosticsDataToCal`, error);
        }
    }

    /**
     * Publishes diagnostic data to CAL by creating an event,
     * attaching the serialized diagnostics data, and completing the event.
     * event type and name can be changed based on requirements
     *
     * @param type - The type of the CAL event.
     * @param name - The name of the CAL event.
     * @param diagnosticsData - The diagnostics data to be published, which will be serialized to JSON.
     */
    publishDataToCal(eventType: String, eventName : String, diagnosticsData: DiagnosticsData) {
        var event = cal.createEvent(eventType, eventName);
        event.addData(JSON.stringify(diagnosticsData));
        event.complete();
    }

    /**
     * Publishes feature_flag_data to CAL with captured error and exception span data from open-telemetry
     */
    publishWithRespCode(featureFlagRawEvents: FeatureFlagRawEvent[], respCode: number) {
        const eventType: String = "Feature_Flag_Data";
        const eventName: String = eventType;

        featureFlagRawEvents.forEach((featureFlagRawEvent) => {
            const calEvent: FeatureFlagCalEvent = featureFlagRawEvent.calEvent;
            
            if (!calEvent) {
                return;
            }

            // Set response code for the main event
            calEvent.respCode = CalResponseCodeUtils.getResponseCodeByCode(respCode);
            
            // Ensure calErrorName is null for the main event
            calEvent.calErrorName = null;
            
            try {
                const calData: String = JSON.stringify(calEvent);
                const event = cal.createEvent(eventType, eventName);

                // See example of feature_flag_data for overall summary
                // {"commandName":"unset","calErrorName":null,"featureFlagKey":"AAFF.StringDataTest","featureFlagErrorCount":12,"variantId":"126549", "respCode":"2XX"}
                event.addData(calData);
                event.complete();
            } catch (error) {
                logger.error('Error serializing feature flag data:', error);
            }

            // Handle error count map and publish additional events
            const errorCountMap = featureFlagRawEvent.calErrorCountMap;
            if (errorCountMap && Object.keys(errorCountMap).length > 0) {
                for (const [errorName, count] of Object.entries(errorCountMap)) {
                    try {
                        // Create a copy of the calEvent for error-specific events
                        const errorCalEvent: FeatureFlagCalEvent = {
                            ...calEvent,
                            calErrorName: errorName,
                            featureFlagErrorCount: count
                        };
                        
                        const errorCalData = JSON.stringify(errorCalEvent);
                        const errorEvent = cal.createEvent(eventType, eventName);
                        errorEvent.addData(errorCalData);
                        errorEvent.complete();
                    }
                    catch (error) {
                        logger.error('Error serializing feature flag data:', error);
                    }
                }
            }
        });
    }

    /**
     * Called before the flag evaluation begins, adds the triggered feature flag key to flag list.
     * In case of any evaluation failures the only point which can capture the feature flag key is before evaluation.
     * @param hookContext 
     */
    before(hookContext: HookContext) {
        //Add the feature flag key that was used to feature flag holder for processing feature flag data
        this.context.addFeatureFlagKey(hookContext.flagKey);
    }

    /**
     * Called after a flag evaluation has completed.
     * Adds diagnostic data to the API log list for publishing.
     *
     * @param hookContext - The context of the hook invocation, containing flag and evaluation metadata.
     * @param evaluationDetails - The details of the flag evaluation, including the evaluated value.
     */
    after(
        hookContext: HookContext,
        evaluationDetails: EvaluationDetails<FlagValue>,
    ) {
        //Add data to api log list which will be published to cal
        this.addDataToApiLogList(hookContext, evaluationDetails);
    }

    /**
     * Creates and returns a `DiagnosticsData` object populated with qualification input and platform data.
     *
     * @param context - The context object containing user and device information.
     * @returns A `DiagnosticsData` instance with populated qualification input and platform data.
     */
    createQualificationInput(context: Context) {
        var diagnosticsData: DiagnosticsData = new DiagnosticsData();
        var debugCodesArr: number[] = [];
        if(context?.getIsBot()) { 
            debugCodesArr.push(DebugCodes.BOT_REQUEST); 
        } else if(context?.getSiteId() == null || context?.getSiteId() == undefined) { 
            debugCodesArr.push(DebugCodes.NULL_SITE); 
        } else if(getChannelId(context?.getDeviceInfo()) == null || getChannelId(context?.getDeviceInfo()) == 99) { 
            debugCodesArr.push(DebugCodes.NULL_CHANNEL); 
        }
        const qualificationInput = {
            guid: context?.getGuid(),
            uid: context?.getUserId(),
            siteId: context.getSiteId(),
            channelId: getChannelId(context.getDeviceInfo()),
            userAgent: context.getUserAgent(),
            bot: context.getIsBot(),
            debugCodes: debugCodesArr?.length > 0 ? debugCodesArr : null,
        };
        diagnosticsData.qualificationInput = qualificationInput;
        diagnosticsData.platformData = {"platformType" : "epOpenFeatureMiddlware"};
        return diagnosticsData;
    }
}
