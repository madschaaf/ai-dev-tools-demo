import { SpanProcessor, ReadableSpan } from '@opentelemetry/sdk-trace-node';
import { Span, SpanStatusCode, Context } from '@opentelemetry/api';
import { FeatureFlagErrorInfo } from '../types/FeatureFlagErrorInfo';

export class FeatureFlagSpanProcessor implements SpanProcessor {
  private traceIdMap: Map<string, FeatureFlagErrorInfo>;

  constructor() {
    this.traceIdMap = new Map();
  }

  /** Do nothing. For satisfying SpanProcessor interface only */
  onStart(span: Span, parentContext: Context): void {
    return;
  }

  onEnd(span: ReadableSpan): void {
    try {
      this.report(span);
    } catch (error) {
      console.error('Error in FeatureFlagSpanProcessor:', error);
    }
  }

  /** Do nothing. For satisfying SpanProcessor interface only */
  shutdown(): Promise<void> {
    return Promise.resolve();
  }
  /** Do nothing. For satisfying SpanProcessor interface only */
  forceFlush(): Promise<void> {
    return Promise.resolve();
  }


  private report(span: ReadableSpan): void {
    if (!span || !span.attributes) {
      return;
    }

    const name = this.getErrorName(span);
    const status = this.getStatus(span);
    const httpStatusCode = this.getHttpStatusCode(span);    
    // For error detection we will check:
    // 1. Is the trace status === 2 (ERROR)
    // 2. Is the http status code attribute >= 400
    if (span.spanContext().traceId) {
      if (status === 2 || httpStatusCode >= 400) {
          this.getFeatureFlagErrorInfo(span.spanContext().traceId).addErrorEvent(name);
      }
    }
  }

  private getFeatureFlagErrorInfo(traceId: string): FeatureFlagErrorInfo {
    let existErrInfo = this.traceIdMap.get(traceId);
    
    // Check if existing map contains trace id key already
    if (existErrInfo) {
      return existErrInfo;
    }
    
    existErrInfo = new FeatureFlagErrorInfo();
    
    // Put new TraceEntry obj by trace id to map
    this.traceIdMap.set(traceId, existErrInfo);

    const newErrInfo = this.traceIdMap.get(traceId);
    if (newErrInfo) {
      return newErrInfo;
    }
    return existErrInfo;
  }

  /** 
   * Return the error message name from span
   */
  private getErrorName(span: ReadableSpan): string {
    const attributes = span.attributes || {};
    const exceptionMessage = attributes['exception.message'];
    
    if (typeof exceptionMessage === 'string') {
      return exceptionMessage;
    }
    
    // Check span status message
    if (span.status?.message) {
      return span.status.message;
    }
    
    return 'null';
  }

  /**
   * Returns the span status which is defined by SpanStatusCode
   * 0 = UNSET
   * 1 = OK
   * 2 = ERROR
   * @param span
   * @returns 
   */
  private getStatus(span: ReadableSpan): number {
    const statusCode = span.status.code;

    if (statusCode) {
      return statusCode
    };
    
    return SpanStatusCode.UNSET;
  }

  private getHttpStatusCode(span: ReadableSpan): number {
    const attributes = span.attributes || {};
    const httpStatusCode = attributes['http.status_code'];

    // Type check and validate the HTTP status code
    if (typeof httpStatusCode === 'number' && !isNaN(httpStatusCode)) {
      return httpStatusCode;
    }

    return 200;
  }

  public removeTrace(traceId: string): void {
    this.traceIdMap.delete(traceId);
  }

  public removeTraceMap(): void {
    this.traceIdMap.clear();
  }

   public getTraceIdMap(): Map<string, FeatureFlagErrorInfo> {
    return new Map(this.traceIdMap);
  }
}
