import { EvaluationContext } from '@openfeature/js-sdk';
import { EvalCriteria } from '../types/EvalCriteria';
import { CHANNEL_ENUM } from '../Api';
import { EvalRequest } from '../types/EvalRequest';
import { FeatureFlag } from '../types/FeatureFlag';
import { Sample, SampleTypes } from '../types/Sample';
import { getLogger } from '@ebay/logging-inc';

const epBuiltIn = {
    siteId: 'number',
    channelId: 'number',
    guid: 'string',
    uid: 'string',
    dropTag: 'boolean',
    optedInto: 'string',
    internalIp: 'boolean',
    contextParams: 'object',
    anyId: 'object',
    featureFlags: 'object',
    ANY_ID_TYPE: 'string',
};

const LOGGER = getLogger('openfeature-ebay/translateContext');

function addContextParams(value): object {
    const contextParams = {};
    Object.entries(value).forEach(([key, value]) => {
        if (
            typeof value === 'string' ||
            typeof value === 'boolean' ||
            typeof value === 'number'
        ) {
            contextParams[key] = value;
        }
    });
    return contextParams;
}

function addAnyId(key: string, type: string): Sample {
    const anyIdSample = {
        sampleType: SampleTypes.ANYID,
        sampleId: key,
        sampleIdType: type,
    };
    return anyIdSample;
}

function addFeatureFlags(featureFlagsList): any {
    const featureFlags = [];
    featureFlagsList.forEach((flagKey) => {
        const featureFlagEntry: FeatureFlag = {
            key: flagKey,
        };
        featureFlags.push(featureFlagEntry);
    });
    return featureFlags;
}

/**
 * Convert an OpenFeature evaluation context into EvalCriteria.
 * @param evalContext The OpenFeature evaluation context to translate.
 * @returns An EvalCriteria based on the evaluation context.
 *
 * @internal
 */
export default function translateContext(
    evalContext: EvaluationContext,
    flagKey?: string,
    flagsList?: Array<string>,
): EvalRequest {
    const defaultEvalCriteria: EvalCriteria = {
        siteId: -1,
        channelId: CHANNEL_ENUM.OTHER,
        samples: [],
    };

    let featureFlag: FeatureFlag;
    let featureFlagsForEval = [];

    if (flagKey) {
        featureFlag = {
            key: flagKey,
        };
        featureFlagsForEval.push(featureFlag);
    }

    featureFlagsForEval = featureFlagsForEval.filter(
        (value, index, self) =>
            index === self.findIndex((t) => t.key === value.key),
    );

    if (flagsList && flagsList.length > 0) {
        const additionalFeatureFlags = addFeatureFlags(flagsList);
        featureFlagsForEval.push.apply(
            featureFlagsForEval,
            additionalFeatureFlags,
        );
    }

    const { targetingKey, ANY_ID_TYPE, isBot } = evalContext;
    let labelForEval: any = [];

    if (targetingKey && ANY_ID_TYPE) {
        const anyIdSample = addAnyId(targetingKey, ANY_ID_TYPE.toString());
        defaultEvalCriteria.samples.push(anyIdSample);
    }

    Object.entries(evalContext).forEach(([key, value]) => {
        if (key === 'targetingKey') {
            return;
        }
        if (key === 'labelForEval') {
            labelForEval = value;
        }
        if (key in epBuiltIn) {
            if (value == null) {
                return;
            }
            if (typeof value === epBuiltIn[key]) {
                if (key === 'guid') {
                    const guidSample = {
                        sampleType: SampleTypes.GUID,
                        sampleId: `${value}`,
                    };
                    defaultEvalCriteria.samples.push(guidSample);
                } else if (key === 'uid') {
                    const userIdSample = {
                        sampleType: SampleTypes.UID,
                        sampleId: `${value}`,
                    };
                    defaultEvalCriteria.samples.push(userIdSample);
                } else if (key === 'dropTag') {
                    featureFlag.dropTag = Boolean(value);
                } else if (key === 'contextParams') {
                    const transformedContextParams = addContextParams(value);
                    defaultEvalCriteria.contextParams =
                        transformedContextParams;
                } else {
                    defaultEvalCriteria[key] = value;
                }
            }
        }
    });
    let { shouldUseEPCache } = evalContext;
    if (labelForEval.length > 0) {
        shouldUseEPCache = false; // do not use new cache if the application is using labels
    }
    const evalMetadata = {}
    if (shouldUseEPCache) {
        evalMetadata['EP_FF_FOR_NEW_CACHE_RAPT_IO'] = true
    };

    if (isBot) {
        evalMetadata['IS_BOT'] = true;
    }

    if (Object.keys(evalMetadata).length > 0) {
        defaultEvalCriteria.evalMetadata = evalMetadata;
    }

    const evalRequest: EvalRequest = {
        evalCriteria: defaultEvalCriteria,
        featureFlagsForEval,
        labelForEval: labelForEval,
    };

    LOGGER.info(evalRequest);

    return evalRequest;
}
