import {
    Client,
    ErrorCode,
    EvaluationDetails,
    FlagValue,
} from '@openfeature/js-sdk';
import { CHANNEL_ENUM, getChannelId } from '../Api';
import {
    ClientSideEvaluationResults,
    FlagEvalDetail,
} from '../types/FlagEvalDetail';
import { EPTags } from '../types/EpTagsEventMap';
import hmv from '@ebay/header-multi-value-ebay';
import { addQtagsToPulsarEventTracker, addXtTagsToPulsarEventTracker, addTagToPulsarEventTracker } from '../tracking/utils';
import Services from '../Services';
import { ApiLog } from '../types/ApiLog';

const logger = require('@ebay/logging-inc').logger('openfeature-ebay:context');

const REQUEST_HEADERS = {
    EPRESULT: 'EPRESULT',
    HEADER_KEY: 'X-EBAY-C-EXP',
    OPTIN_COOKIE: 'OPTIN_COOKIE',
};

const HEADER_KEY = 'x-ebay-svc-ep-cookielet';

const appContext = require('@ebay/app-context-ebay');

/*
 * This class extracts the guid, userid, site, and channel from the req object.
 * In order for channel to be derrived, device dection middleware is required
 */
export abstract class Context {
    req: any;
    res: any;
    ebay: any;
    ebayRes: any;
    _evaluationResults: Map<string, FlagEvalDetail>;
    _epTagsEventMap: EPTags;
    hasStoredData = false;
    client: Client; // openfeature client
    internals$: any;
    optinFlag: string;
    pulsarEventTracker;
    _loggedTreatments = {};
    openfeatureGlobalCache;
    services: Services;
    initializeFFPromise: Promise<string>;
    apiLogList: ApiLog[] = new Array();
    featureFlags: Set<string> = new Set(); // tracks the flags that were invoked in this request

    constructor(req: any, res: any, openfeatureGlobalCache: Map<String, Object>) {
        this.req = req;
        this.res = res;
        this.ebay = this.req.ebay;
        this.ebayRes = this.res;
        this.openfeatureGlobalCache = openfeatureGlobalCache;
        this.internals$ = this.createInternals(this);
    }

    getContextParams(): any {
        return this.internals$.createDefaultParams();
    }

    getEvaluationResults(): Map<string, FlagEvalDetail> {
        return this._evaluationResults;
    }

    getOpenfeatureGlobalCache(): Map<String, Object> {
        return this.openfeatureGlobalCache;
    }

    setServiceClient(services: Services) {
        this.services = services;
    }

    getServiceClient() {
        return this.services;
    }

    async getClientSideEPs(
        labelForEval: string[],
    ): Promise<ClientSideEvaluationResults> {
        const clientSideExperiments = {
            qTags: null,
            clientSideEps: [],
            siteId: -1,
        };

        // check if any labels are in smart list and exists in labelForEval input
        const labelForEvalSet = this.openfeatureGlobalCache.get('labelForEvalSet');

        // check if the labelForEval is a subset of the smart list
        const intersection = new Set([...labelForEval].filter(x => labelForEvalSet.has(x)));

        // if there are new labels not originally stored in list, retry services with labels
        if (intersection.size == 0) {
            // call services with label request
            const defaultContext = this.getContextParams();
            const clientSideData = await this.services.invokeInternalSearchApiByLabel(defaultContext, intersection);
            const { evaluationResultsMap } = clientSideData;
            this.setEvaluationResults(evaluationResultsMap, null);
            labelForEvalSet.add(...labelForEval);
        }

        // filter for client side eps within the evaluation results
        if (this.hasStoredData) {
            if (this._evaluationResults && this._evaluationResults.size > 0) {
                const clientSideEps = [];
                for (let flagKey of this._evaluationResults.keys()) {
                    const flagEvalDetails = this._evaluationResults.get(flagKey);
                    if (!flagEvalDetails.isClientSide) {
                        continue;
                    }
                    let exp = {
                        flagKey: flagEvalDetails.featureFlagKey,
                        flagValue: flagEvalDetails.featureFlagValue,
                        variant: flagEvalDetails.details.variantId,
                        reason: flagEvalDetails.details.reason,
                    };
                    clientSideEps.push(exp);
                }

                if (clientSideEps.length > 0) {
                    if (this._epTagsEventMap) {
                        clientSideExperiments.qTags = this._epTagsEventMap;
                    }
                    clientSideExperiments.clientSideEps = clientSideEps;
                }
            }
            clientSideExperiments.siteId = this.getSiteId();
        }

        return clientSideExperiments;
    }

    setEvaluationResults(evaluationResults: Map<string, FlagEvalDetail>, keys: Set<string>): void {
        // If the key from smart list is not found in evaluation results, create a stubbed result
        // This logic is slighly different from the use case found in ExperimentationHook
        // This logic will be removed when we complete EXPRMT-16811 (convert evaluationResults to map)
        if (keys) {
            keys.forEach(key => {
                const existsInEvaluationResults = evaluationResults.has(key);
                if (!existsInEvaluationResults) {
                    const details = {
                        variantId: null,
                        variantName: null,
                        reason: 'Flag not found or not qualified',
                        errorCode: ErrorCode.FLAG_NOT_FOUND,
                    };
                    const stubbedEvaluationResult: FlagEvalDetail = {
                        featureFlagKey: key,
                        featureFlagValue: null,
                        details,
                        isClientSide: null,
                        isPureFeatureFlag: null,
                    };

                    evaluationResults.set(key, stubbedEvaluationResult);
                }
            })
        }
        // combine the evaluation results with the existing evaluation results
        if (this._evaluationResults) {
            evaluationResults.forEach((value, key) => {
                this._evaluationResults.set(key, value);
            });
        } else {
            this._evaluationResults = evaluationResults as Map<string, FlagEvalDetail>;
            this.hasStoredData = true;
        }
    }

    getEpTagsEventMap(): EPTags {
        return this._epTagsEventMap;
    }

    setEpTagsEventMap(qTags: EPTags): void {
        if (this._epTagsEventMap) {
            this._epTagsEventMap = qTags;
            return;
        }
        this._epTagsEventMap = qTags;
        this.hasStoredData = true;
    }

    track(data: EPTags) {
        const ebayReq = this.ebay;

        if (data) {
            this.pulsarEventTracker =
                ebayReq.tracking &&
                ebayReq.tracking.getPulsarEventTracker &&
                ebayReq.tracking.getPulsarEventTracker();
            addQtagsToPulsarEventTracker(
                this.pulsarEventTracker,
                data,
            );
        }
    }

    flushExptTagsToTracking() {
        const ebayReq = this.ebay;
        // skips tracking if middleware is not detected or tracking is disabled on route
        if (!ebayReq.tracking || !ebayReq.tracking.isTrackingEnabled()) {
            logger.warn('Tracking is missing or disabled for this route');
            return;
        }
        const data: EPTags = this.getEpTagsEventMap();
        let ot = null;
        if (data && data.qTags && data.qTags.length > 0) {
            data.qTags.forEach((tag) => {
                if (tag.key === 'ot') {
                    ot = tag.value;
                }
            });
        }

        // check if this._loggedTreatments is an empty object to skip tracking for events with no !xt or ot tag
        if (Object.keys(this._loggedTreatments).length > 0 || ot != null) {
            this.track(data);
            const treatmentIds = Object.keys(this._loggedTreatments)
                .filter((key) => this._loggedTreatments[key] === true)
                .join(',');
            if (this.pulsarEventTracker) {
                if (treatmentIds != '') {
                    addXtTagsToPulsarEventTracker(this.pulsarEventTracker, treatmentIds);
                }
                // Add environment to tracking
                addTagToPulsarEventTracker(this.pulsarEventTracker, `epcalenv`, this.getPoolEnv());
                this.pulsarEventTracker.flush();
            }
        }
        logger.debug('Skipping tracking for events with no !xt or ot tag');
    }

    trackServedTreatment(evaluationResult: EvaluationDetails<FlagValue>): void {
        const treatmentId = evaluationResult.variant;
        if (treatmentId && !this._loggedTreatments[treatmentId]) {
            this._loggedTreatments[treatmentId] = true;
        }
    }

    abstract getOptedIntoFlag(): string;
    abstract setExperimentTreatements(
        experimentationCookieletHeader: string,
    ): void;

    preflightRequestHeaders(options, callback) {
        options = options || {};
        const epConfig = options.ep;
        const epType =
            (epConfig && epConfig.type) || epConfig || REQUEST_HEADERS.EPRESULT;

        options.headers = options.headers || {};

        if (epType === REQUEST_HEADERS.OPTIN_COOKIE) {
            let optin: any = {};
            let optinFlag = this.getOptedIntoFlag();

            if (optinFlag && optinFlag !== '-1') {
                optin['EP_OPTIN'] = optinFlag;
            }

            const fsom =
                this.ebay &&
                this.ebay.getEndUserContext() &&
                this.ebay.getEndUserContext().userPrefersDesktopExperience();
            if (fsom) {
                optin.CHANNEL = 1;
            }

            // If app overrode the channel to email use it to overrrid fsom.
            const emailChannel = this.req && this.req.emailChannel;
            if (emailChannel) {
                optin.CHANNEL = 6;
            }

            if (epConfig && epConfig.responseHeader === false) {
                optin.noepheader = 1;
            }

            let epHeaderValue = hmv.create(optin);
            options.headers[REQUEST_HEADERS.HEADER_KEY] =
                epHeaderValue.toString();
        }
        callback(null, options);
    }

    handleResponseHeaders(headers) {
        const headerVal = headers && headers[HEADER_KEY];
        this.setExperimentTreatements(headerVal);
    }

    createInternals(context): any {
        return {
            createDefaultParams(): any {
                // default parameters
                const evalContext: any = {
                    siteId: context.getSiteId(),
                    channelId: CHANNEL_ENUM.OTHER, // supported on web, mWeb, etc.
                    guid: context.getGuid(),
                    uid: null,
                    isBot: context.getIsBot(),
                    contextParams: {
                        DATE: '' + Date.now(),
                        IP: context.getClientIP(),
                        PAGEID: context.getPageId(),
                        REFERER: context.getReferer(),
                        PAGENAME: context.getPageName(),
                        SITEID: '' + context.getSiteId(),
                        USERAGENT: context.getUserAgent(),
                        USERLOCALE: (context.getCountryCode() || '') + context.getUserLocale(),
                        POOLNAME: context.getPoolName(),
                        COUNTRYCODE: context.getCountryCode(),
                        POOLENV: context.getPoolEnv(),
                    },
                };

                if (context.isEmailChannel()) {
                    evalContext.channelId = 6;
                    evalContext.contextParams.TRAFFICSOURCE =
                        context.getTrafficSource();
                } else {
                    const deviceInfo = context.getDeviceInfo();
                    if (deviceInfo) {
                        const channelId = getChannelId(deviceInfo);
                        evalContext.channelId = channelId;
                        evalContext.contextParams.CHANNEL = channelId;
                        if (channelId !== 5 && channelId !== 6) {
                            // not native channel
                            evalContext.contextParams.TRAFFICSOURCE =
                                context.getTrafficSource();
                        }
                    } else {
                        evalContext.contextParams.TRAFFICSOURCE =
                            context.getTrafficSource();
                    }
                }
                // set the best guessed userId if possible
                const userId = context.getUserId();
                if (userId) {
                    evalContext.uid = userId;
                }

                const cookiesAndCookielets = context.getCookiesAndCookielets();
                if (cookiesAndCookielets) {
                    evalContext.contextParams.COOKIES =
                        cookiesAndCookielets.cookies;
                    evalContext.contextParams.COOKIELETS =
                        cookiesAndCookielets.cookielets;
                }

                evalContext.optedInto = context.getOptedIntoFlag();

                return evalContext;
            },
        };
    }

    getGuid(): string {
        return this.ebay.getGuid();
    }

    getSiteId(): number {
        return this.ebay.getSiteId();
    }

    getUserId(): string {
        return this.ebay.getBestUserId();
    }

    getDeviceInfo() {
        return this.req && this.req.deviceInfo;
    }

    getPageId() {
        return this.ebay.getPageId();
    }

    getPageName() {
        return this.ebay.getPageName();
    }

    getPoolName() {
        return this.ebay.appContext.poolName;
    }

    getUserAgent() {
        return this.ebay.getUserAgent();
    }

    getUserLocale() {
        return this.ebay.getAcceptLanguages()[0];
    }

    getTrafficSource() {
        const mkcid = this.req && this.req.query && this.req.query.mkcid;
        if (mkcid && Array.isArray(mkcid)) {
            if (mkcid.length > 0) {
                return mkcid[0];
            }
            return undefined;
        }
        return mkcid;
    }

    getIsBot() {
        const tracking = this.ebay.tracking;
        if (tracking && tracking.sojournerContext) {
            const { sojournerContext } = tracking;
            if (!tracking?.Flags?.GlobalFlags) {
                logger.debug(new Error('Tracking GlobalFlags are not found'));
                return;
            }

            if (sojournerContext.isAppFlagSet(tracking.Flags.GlobalFlags.DETECTED_BOT) ||
                    sojournerContext.isContextFlagSet(tracking.Flags.GlobalFlags.DETECTED_BOT)) {
                // BOT detected
                logger.debug("ep: BOT detected");
                return true;
            }
            return false;
        }
    }

    getPoolEnv() {
        const paasRealm = appContext.paasRealm;
        if (paasRealm) {
            logger.debug(`Paasrealm from appContext.paasRealm: ${paasRealm}`);
            return paasRealm;
        }
        return 'Dev';
    }

    getApiLogList(): ApiLog[] {
        return this.ebay.apiLogList;
    }

    setApiLogList(value: ApiLog[]) {
        this.ebay.apiLogList = value;
    }

    addFeatureFlagKey(featureFlagKey: string) {
        this.featureFlags.add(featureFlagKey);
    }

    getFeatureFlagKeys(): Set<string> {
        return this.featureFlags;
    }
}
