"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../Api");
const Sample_1 = require("../types/Sample");
const logging_inc_1 = require("@ebay/logging-inc");
const epBuiltIn = {
    siteId: 'number',
    channelId: 'number',
    guid: 'string',
    uid: 'string',
    dropTag: 'boolean',
    optedInto: 'string',
    internalIp: 'boolean',
    contextParams: 'object',
    anyId: 'object',
    featureFlags: 'object',
    ANY_ID_TYPE: 'string',
};
const LOGGER = (0, logging_inc_1.getLogger)('openfeature-ebay/translateContext');
function addContextParams(value) {
    const contextParams = {};
    Object.entries(value).forEach(([key, value]) => {
        if (typeof value === 'string' ||
            typeof value === 'boolean' ||
            typeof value === 'number') {
            contextParams[key] = value;
        }
    });
    return contextParams;
}
function addAnyId(key, type) {
    const anyIdSample = {
        sampleType: Sample_1.SampleTypes.ANYID,
        sampleId: key,
        sampleIdType: type,
    };
    return anyIdSample;
}
function addFeatureFlags(featureFlagsList) {
    const featureFlags = [];
    featureFlagsList.forEach((flagKey) => {
        const featureFlagEntry = {
            key: flagKey,
        };
        featureFlags.push(featureFlagEntry);
    });
    return featureFlags;
}
/**
 * Convert an OpenFeature evaluation context into EvalCriteria.
 * @param evalContext The OpenFeature evaluation context to translate.
 * @returns An EvalCriteria based on the evaluation context.
 *
 * @internal
 */
function translateContext(evalContext, flagKey, flagsList) {
    const defaultEvalCriteria = {
        siteId: -1,
        channelId: Api_1.CHANNEL_ENUM.OTHER,
        samples: [],
    };
    let featureFlag;
    let featureFlagsForEval = [];
    if (flagKey) {
        featureFlag = {
            key: flagKey,
        };
        featureFlagsForEval.push(featureFlag);
    }
    featureFlagsForEval = featureFlagsForEval.filter((value, index, self) => index === self.findIndex((t) => t.key === value.key));
    if (flagsList && flagsList.length > 0) {
        const additionalFeatureFlags = addFeatureFlags(flagsList);
        featureFlagsForEval.push.apply(featureFlagsForEval, additionalFeatureFlags);
    }
    const { targetingKey, ANY_ID_TYPE, isBot } = evalContext;
    let labelForEval = [];
    if (targetingKey && ANY_ID_TYPE) {
        const anyIdSample = addAnyId(targetingKey, ANY_ID_TYPE.toString());
        defaultEvalCriteria.samples.push(anyIdSample);
    }
    Object.entries(evalContext).forEach(([key, value]) => {
        if (key === 'targetingKey') {
            return;
        }
        if (key === 'labelForEval') {
            labelForEval = value;
        }
        if (key in epBuiltIn) {
            if (value == null) {
                return;
            }
            if (typeof value === epBuiltIn[key]) {
                if (key === 'guid') {
                    const guidSample = {
                        sampleType: Sample_1.SampleTypes.GUID,
                        sampleId: `${value}`,
                    };
                    defaultEvalCriteria.samples.push(guidSample);
                }
                else if (key === 'uid') {
                    const userIdSample = {
                        sampleType: Sample_1.SampleTypes.UID,
                        sampleId: `${value}`,
                    };
                    defaultEvalCriteria.samples.push(userIdSample);
                }
                else if (key === 'dropTag') {
                    featureFlag.dropTag = Boolean(value);
                }
                else if (key === 'contextParams') {
                    const transformedContextParams = addContextParams(value);
                    defaultEvalCriteria.contextParams =
                        transformedContextParams;
                }
                else {
                    defaultEvalCriteria[key] = value;
                }
            }
        }
    });
    let { shouldUseEPCache } = evalContext;
    if (labelForEval.length > 0) {
        shouldUseEPCache = false; // do not use new cache if the application is using labels
    }
    const evalMetadata = {};
    if (shouldUseEPCache) {
        evalMetadata['EP_FF_FOR_NEW_CACHE_RAPT_IO'] = true;
    }
    ;
    if (isBot) {
        evalMetadata['IS_BOT'] = true;
    }
    if (Object.keys(evalMetadata).length > 0) {
        defaultEvalCriteria.evalMetadata = evalMetadata;
    }
    const evalRequest = {
        evalCriteria: defaultEvalCriteria,
        featureFlagsForEval,
        labelForEval: labelForEval,
    };
    LOGGER.info(evalRequest);
    return evalRequest;
}
exports.default = translateContext;
//# sourceMappingURL=translateContext.js.map