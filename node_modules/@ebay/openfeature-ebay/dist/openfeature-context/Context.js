"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
const tslib_1 = require("tslib");
const js_sdk_1 = require("@openfeature/js-sdk");
const Api_1 = require("../Api");
const header_multi_value_ebay_1 = tslib_1.__importDefault(require("@ebay/header-multi-value-ebay"));
const utils_1 = require("../tracking/utils");
const logger = require('@ebay/logging-inc').logger('openfeature-ebay:context');
const REQUEST_HEADERS = {
    EPRESULT: 'EPRESULT',
    HEADER_KEY: 'X-EBAY-C-EXP',
    OPTIN_COOKIE: 'OPTIN_COOKIE',
};
const HEADER_KEY = 'x-ebay-svc-ep-cookielet';
const appContext = require('@ebay/app-context-ebay');
/*
 * This class extracts the guid, userid, site, and channel from the req object.
 * In order for channel to be derrived, device dection middleware is required
 */
class Context {
    constructor(req, res, openfeatureGlobalCache) {
        this.hasStoredData = false;
        this._loggedTreatments = {};
        this.apiLogList = new Array();
        this.featureFlags = new Set(); // tracks the flags that were invoked in this request
        this.req = req;
        this.res = res;
        this.ebay = this.req.ebay;
        this.ebayRes = this.res;
        this.openfeatureGlobalCache = openfeatureGlobalCache;
        this.internals$ = this.createInternals(this);
    }
    getContextParams() {
        return this.internals$.createDefaultParams();
    }
    getEvaluationResults() {
        return this._evaluationResults;
    }
    getOpenfeatureGlobalCache() {
        return this.openfeatureGlobalCache;
    }
    setServiceClient(services) {
        this.services = services;
    }
    getServiceClient() {
        return this.services;
    }
    async getClientSideEPs(labelForEval) {
        const clientSideExperiments = {
            qTags: null,
            clientSideEps: [],
            siteId: -1,
        };
        // check if any labels are in smart list and exists in labelForEval input
        const labelForEvalSet = this.openfeatureGlobalCache.get('labelForEvalSet');
        // check if the labelForEval is a subset of the smart list
        const intersection = new Set([...labelForEval].filter(x => labelForEvalSet.has(x)));
        // if there are new labels not originally stored in list, retry services with labels
        if (intersection.size == 0) {
            // call services with label request
            const defaultContext = this.getContextParams();
            const clientSideData = await this.services.invokeInternalSearchApiByLabel(defaultContext, intersection);
            const { evaluationResultsMap } = clientSideData;
            this.setEvaluationResults(evaluationResultsMap, null);
            labelForEvalSet.add(...labelForEval);
        }
        // filter for client side eps within the evaluation results
        if (this.hasStoredData) {
            if (this._evaluationResults && this._evaluationResults.size > 0) {
                const clientSideEps = [];
                for (let flagKey of this._evaluationResults.keys()) {
                    const flagEvalDetails = this._evaluationResults.get(flagKey);
                    if (!flagEvalDetails.isClientSide) {
                        continue;
                    }
                    let exp = {
                        flagKey: flagEvalDetails.featureFlagKey,
                        flagValue: flagEvalDetails.featureFlagValue,
                        variant: flagEvalDetails.details.variantId,
                        reason: flagEvalDetails.details.reason,
                    };
                    clientSideEps.push(exp);
                }
                if (clientSideEps.length > 0) {
                    if (this._epTagsEventMap) {
                        clientSideExperiments.qTags = this._epTagsEventMap;
                    }
                    clientSideExperiments.clientSideEps = clientSideEps;
                }
            }
            clientSideExperiments.siteId = this.getSiteId();
        }
        return clientSideExperiments;
    }
    setEvaluationResults(evaluationResults, keys) {
        // If the key from smart list is not found in evaluation results, create a stubbed result
        // This logic is slighly different from the use case found in ExperimentationHook
        // This logic will be removed when we complete EXPRMT-16811 (convert evaluationResults to map)
        if (keys) {
            keys.forEach(key => {
                const existsInEvaluationResults = evaluationResults.has(key);
                if (!existsInEvaluationResults) {
                    const details = {
                        variantId: null,
                        variantName: null,
                        reason: 'Flag not found or not qualified',
                        errorCode: js_sdk_1.ErrorCode.FLAG_NOT_FOUND,
                    };
                    const stubbedEvaluationResult = {
                        featureFlagKey: key,
                        featureFlagValue: null,
                        details,
                        isClientSide: null,
                        isPureFeatureFlag: null,
                    };
                    evaluationResults.set(key, stubbedEvaluationResult);
                }
            });
        }
        // combine the evaluation results with the existing evaluation results
        if (this._evaluationResults) {
            evaluationResults.forEach((value, key) => {
                this._evaluationResults.set(key, value);
            });
        }
        else {
            this._evaluationResults = evaluationResults;
            this.hasStoredData = true;
        }
    }
    getEpTagsEventMap() {
        return this._epTagsEventMap;
    }
    setEpTagsEventMap(qTags) {
        if (this._epTagsEventMap) {
            this._epTagsEventMap = qTags;
            return;
        }
        this._epTagsEventMap = qTags;
        this.hasStoredData = true;
    }
    track(data) {
        const ebayReq = this.ebay;
        if (data) {
            this.pulsarEventTracker =
                ebayReq.tracking &&
                    ebayReq.tracking.getPulsarEventTracker &&
                    ebayReq.tracking.getPulsarEventTracker();
            (0, utils_1.addQtagsToPulsarEventTracker)(this.pulsarEventTracker, data);
        }
    }
    flushExptTagsToTracking() {
        const ebayReq = this.ebay;
        // skips tracking if middleware is not detected or tracking is disabled on route
        if (!ebayReq.tracking || !ebayReq.tracking.isTrackingEnabled()) {
            logger.warn('Tracking is missing or disabled for this route');
            return;
        }
        const data = this.getEpTagsEventMap();
        let ot = null;
        if (data && data.qTags && data.qTags.length > 0) {
            data.qTags.forEach((tag) => {
                if (tag.key === 'ot') {
                    ot = tag.value;
                }
            });
        }
        // check if this._loggedTreatments is an empty object to skip tracking for events with no !xt or ot tag
        if (Object.keys(this._loggedTreatments).length > 0 || ot != null) {
            this.track(data);
            const treatmentIds = Object.keys(this._loggedTreatments)
                .filter((key) => this._loggedTreatments[key] === true)
                .join(',');
            if (this.pulsarEventTracker) {
                if (treatmentIds != '') {
                    (0, utils_1.addXtTagsToPulsarEventTracker)(this.pulsarEventTracker, treatmentIds);
                }
                // Add environment to tracking
                (0, utils_1.addTagToPulsarEventTracker)(this.pulsarEventTracker, `epcalenv`, this.getPoolEnv());
                this.pulsarEventTracker.flush();
            }
        }
        logger.debug('Skipping tracking for events with no !xt or ot tag');
    }
    trackServedTreatment(evaluationResult) {
        const treatmentId = evaluationResult.variant;
        if (treatmentId && !this._loggedTreatments[treatmentId]) {
            this._loggedTreatments[treatmentId] = true;
        }
    }
    preflightRequestHeaders(options, callback) {
        options = options || {};
        const epConfig = options.ep;
        const epType = (epConfig && epConfig.type) || epConfig || REQUEST_HEADERS.EPRESULT;
        options.headers = options.headers || {};
        if (epType === REQUEST_HEADERS.OPTIN_COOKIE) {
            let optin = {};
            let optinFlag = this.getOptedIntoFlag();
            if (optinFlag && optinFlag !== '-1') {
                optin['EP_OPTIN'] = optinFlag;
            }
            const fsom = this.ebay &&
                this.ebay.getEndUserContext() &&
                this.ebay.getEndUserContext().userPrefersDesktopExperience();
            if (fsom) {
                optin.CHANNEL = 1;
            }
            // If app overrode the channel to email use it to overrrid fsom.
            const emailChannel = this.req && this.req.emailChannel;
            if (emailChannel) {
                optin.CHANNEL = 6;
            }
            if (epConfig && epConfig.responseHeader === false) {
                optin.noepheader = 1;
            }
            let epHeaderValue = header_multi_value_ebay_1.default.create(optin);
            options.headers[REQUEST_HEADERS.HEADER_KEY] =
                epHeaderValue.toString();
        }
        callback(null, options);
    }
    handleResponseHeaders(headers) {
        const headerVal = headers && headers[HEADER_KEY];
        this.setExperimentTreatements(headerVal);
    }
    createInternals(context) {
        return {
            createDefaultParams() {
                // default parameters
                const evalContext = {
                    siteId: context.getSiteId(),
                    channelId: Api_1.CHANNEL_ENUM.OTHER, // supported on web, mWeb, etc.
                    guid: context.getGuid(),
                    uid: null,
                    isBot: context.getIsBot(),
                    contextParams: {
                        DATE: '' + Date.now(),
                        IP: context.getClientIP(),
                        PAGEID: context.getPageId(),
                        REFERER: context.getReferer(),
                        PAGENAME: context.getPageName(),
                        SITEID: '' + context.getSiteId(),
                        USERAGENT: context.getUserAgent(),
                        USERLOCALE: (context.getCountryCode() || '') + context.getUserLocale(),
                        POOLNAME: context.getPoolName(),
                        COUNTRYCODE: context.getCountryCode(),
                        POOLENV: context.getPoolEnv(),
                    },
                };
                if (context.isEmailChannel()) {
                    evalContext.channelId = 6;
                    evalContext.contextParams.TRAFFICSOURCE =
                        context.getTrafficSource();
                }
                else {
                    const deviceInfo = context.getDeviceInfo();
                    if (deviceInfo) {
                        const channelId = (0, Api_1.getChannelId)(deviceInfo);
                        evalContext.channelId = channelId;
                        evalContext.contextParams.CHANNEL = channelId;
                        if (channelId !== 5 && channelId !== 6) {
                            // not native channel
                            evalContext.contextParams.TRAFFICSOURCE =
                                context.getTrafficSource();
                        }
                    }
                    else {
                        evalContext.contextParams.TRAFFICSOURCE =
                            context.getTrafficSource();
                    }
                }
                // set the best guessed userId if possible
                const userId = context.getUserId();
                if (userId) {
                    evalContext.uid = userId;
                }
                const cookiesAndCookielets = context.getCookiesAndCookielets();
                if (cookiesAndCookielets) {
                    evalContext.contextParams.COOKIES =
                        cookiesAndCookielets.cookies;
                    evalContext.contextParams.COOKIELETS =
                        cookiesAndCookielets.cookielets;
                }
                evalContext.optedInto = context.getOptedIntoFlag();
                return evalContext;
            },
        };
    }
    getGuid() {
        return this.ebay.getGuid();
    }
    getSiteId() {
        return this.ebay.getSiteId();
    }
    getUserId() {
        return this.ebay.getBestUserId();
    }
    getDeviceInfo() {
        return this.req && this.req.deviceInfo;
    }
    getPageId() {
        return this.ebay.getPageId();
    }
    getPageName() {
        return this.ebay.getPageName();
    }
    getPoolName() {
        return this.ebay.appContext.poolName;
    }
    getUserAgent() {
        return this.ebay.getUserAgent();
    }
    getUserLocale() {
        return this.ebay.getAcceptLanguages()[0];
    }
    getTrafficSource() {
        const mkcid = this.req && this.req.query && this.req.query.mkcid;
        if (mkcid && Array.isArray(mkcid)) {
            if (mkcid.length > 0) {
                return mkcid[0];
            }
            return undefined;
        }
        return mkcid;
    }
    getIsBot() {
        var _a;
        const tracking = this.ebay.tracking;
        if (tracking && tracking.sojournerContext) {
            const { sojournerContext } = tracking;
            if (!((_a = tracking === null || tracking === void 0 ? void 0 : tracking.Flags) === null || _a === void 0 ? void 0 : _a.GlobalFlags)) {
                logger.debug(new Error('Tracking GlobalFlags are not found'));
                return;
            }
            if (sojournerContext.isAppFlagSet(tracking.Flags.GlobalFlags.DETECTED_BOT) ||
                sojournerContext.isContextFlagSet(tracking.Flags.GlobalFlags.DETECTED_BOT)) {
                // BOT detected
                logger.debug("ep: BOT detected");
                return true;
            }
            return false;
        }
    }
    getPoolEnv() {
        const paasRealm = appContext.paasRealm;
        if (paasRealm) {
            logger.debug(`Paasrealm from appContext.paasRealm: ${paasRealm}`);
            return paasRealm;
        }
        return 'Dev';
    }
    getApiLogList() {
        return this.ebay.apiLogList;
    }
    setApiLogList(value) {
        this.ebay.apiLogList = value;
    }
    addFeatureFlagKey(featureFlagKey) {
        this.featureFlags.add(featureFlagKey);
    }
    getFeatureFlagKeys() {
        return this.featureFlags;
    }
}
exports.Context = Context;
//# sourceMappingURL=Context.js.map