"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.openfeatureGlobalCache = void 0;
const tslib_1 = require("tslib");
const js_sdk_1 = require("@openfeature/js-sdk");
const module_config_inc_1 = tslib_1.__importDefault(require("@ebay/module-config-inc"));
const util_1 = require("util");
const api_1 = require("@opentelemetry/api");
const loadConfig = (0, util_1.promisify)(module_config_inc_1.default);
const MetricsPublisherHook_1 = require("./hooks/MetricsPublisherHook");
const MetricsPublisher_1 = require("./metrics/MetricsPublisher");
const OpenFeatureProvider_1 = tslib_1.__importDefault(require("./provider/OpenFeatureProvider"));
const openfeature_context_1 = require("./openfeature-context");
const FFlagClient_1 = require("./FFlagClient");
const EPOpenfeature_1 = require("./EPOpenfeature");
const ExperimentationHook_1 = require("./hooks/ExperimentationHook");
const Services_1 = tslib_1.__importDefault(require("./Services"));
const utils_1 = require("./tracking/utils");
const DiagnosticsHook_1 = tslib_1.__importDefault(require("./hooks/DiagnosticsHook"));
const tracing_1 = require("./tracing");
const FeatureFlagEventUtils_1 = require("./tracing/FeatureFlagEventUtils");
const logger = require('@ebay/logging-inc').logger('openfeature-ebay:middleware');
// saved flags list for smart client
const smartClientFlagsSet = new Set();
// saved labels for evaluation with smart client
const labelForEvalSet = new Set();
// to be used for flag configurations or labels
exports.openfeatureGlobalCache = new Map();
exports.openfeatureGlobalCache.set('smartClientFlagsSet', smartClientFlagsSet);
exports.openfeatureGlobalCache.set('labelForEvalSet', labelForEvalSet);
// boolean to check whether flags have been initalized. After the first web request, it will be set to true. If the boolean is true and the flags and label sets are empty, it will skip calls to epsvc
exports.openfeatureGlobalCache.set('flagsInitialized', false);
const NANOSECONDS_PER_SECOND = 1000000000;
const provider = api_1.trace.getTracerProvider();
function openfeature(options = {}) {
    var _a;
    const metricsPublisher = new MetricsPublisher_1.MetricsPublisher();
    let flagClient = new FFlagClient_1.FFlagClient();
    const openfeatureProvider = new OpenFeatureProvider_1.default(flagClient);
    js_sdk_1.OpenFeature.setProvider('ep-openfeature', openfeatureProvider);
    js_sdk_1.OpenFeature.addHooks(new MetricsPublisherHook_1.MetricsPublisherHook(metricsPublisher));
    // configure feature flag span processor with configurable TTL
    const featureFlagProcessor = new tracing_1.FeatureFlagSpanProcessor();
    const errorTracingProcessingEnabled = (_a = options.errorTracing) !== null && _a !== void 0 ? _a : true;
    // Safely add span processor - if errorTracing option is configured to false in middleware configuration it will skip processor
    try {
        if (errorTracingProcessingEnabled && provider && provider._delegate && provider._delegate.addSpanProcessor) {
            provider._delegate.addSpanProcessor(featureFlagProcessor);
            // Register globally for middleware access
            tracing_1.featureFlagSpanManager.setProcessor(featureFlagProcessor);
        }
        else {
            logger.debug('Span processor not available, skipping span processor setup');
        }
    }
    catch (error) {
        logger.debug('Failed to setup span processor:', error);
    }
    return async function openfeatureMiddleware(req, res, next) {
        var _a, _b;
        const routeConfig = req.route && req.route.config && req.route.config.openfeature;
        if (routeConfig && routeConfig.enabled === false) {
            logger.debug('Openfeature is disabled for this route. Please check routes.json if this is not expected');
            return next();
        }
        const startTimeInNanoSeconds = process.hrtime.bigint(); // returns time in nanoseconds
        const client = js_sdk_1.OpenFeature.getClient('ep-openfeature');
        const context = (0, openfeature_context_1.create)(req, res, exports.openfeatureGlobalCache);
        req.ebay = req.ebay || {};
        client.setContext(context.getContextParams());
        client.addHooks(new ExperimentationHook_1.ExperimentationHook(context));
        // add diagnostics hook to the client
        const diagnosticsHook = new DiagnosticsHook_1.default(context);
        client.addHooks(diagnosticsHook);
        context.setServiceClient(new Services_1.default());
        // add context to req object
        const epOpenfeature = new EPOpenfeature_1.EPOpenfeatureAPI(context, client);
        req.ebay.openfeature = epOpenfeature;
        // publish qualification input details to the cal
        diagnosticsHook.publishDataToCal('EP_DIAGNOSTICS', 'DIAGNOSTICS_DATA', diagnosticsHook.createQualificationInput(context));
        // check if openfeature is enabled after setting openfeature client. This ensures the client is not null if openfeature is disabled on this environment
        const config = await loadConfig(__dirname);
        const openfeatureEnabled = (_a = config === null || config === void 0 ? void 0 : config.get) === null || _a === void 0 ? void 0 : _a.call(config, 'openfeature:enabled');
        // This allows disabling error trace writes to CAL on the fly without restarting the application. Because FeatureFlagSpanProcessor is configured on startup it will continue processing spans if enabled.
        const errorTracingPublishingEnabled = (_b = config === null || config === void 0 ? void 0 : config.get) === null || _b === void 0 ? void 0 : _b.call(config, 'openfeature:errorTracing');
        if (!openfeatureEnabled) {
            logger.debug('Openfeature is disabled for this environment. Please check your environment config.json if this is not expected');
            return next();
        }
        context.initializeFFPromise = initializeFeatureFlags(context)
            .catch(err => logger.debug('Failed to initialize feature flags: %s', err));
        metricsPublisher.usageCounter.inc({
            apiName: 'benchmark',
            status: 'success',
            techStack: 'nodejs',
        }, 1);
        const currentTimeInNanoSeconds = process.hrtime.bigint(); // returns time in nanoseconds
        const nsDuration = currentTimeInNanoSeconds - startTimeInNanoSeconds;
        // converting to seconds to make it same as raptor and raptorio
        const secondsDuration = Number(nsDuration) / NANOSECONDS_PER_SECOND;
        metricsPublisher.apiBenchmarkLatencySla
            .labels('nodejs')
            .observe(secondsDuration);
        //call flushExptTagsToTracking within openfeature-ebay to send all the experimentation tags to tracking
        //call flushDiagnosticsDataToCal to send the diagnostics data to CAL
        res.on('finish', function flushDataToTrackingAndCal() {
            var _a, _b;
            let traceId = '';
            try {
                // this is the end of the request, so any future requests will indicate smart list state is stable from the first request
                exports.openfeatureGlobalCache.set('flagsInitialized', true);
                /**
                 * req.otel.isRecording: determined by opentelemetry -- whether traces are recorded, a prerequisite to processing feature flag events
                 * errorTracingProcessingEnabled -- configured on application startup to determine whether to hook up FeatureFlagSpanProcessor to capture error events.
                 *  - This option can only be changed on application startup and is set in the middleware.json openfeature-ebay arguments ("arguments": [{"errorTracing": false}])
                 * errorTracingPublishingEnabled -- configured by config bean and can determine whether to process the trace errors and publish feature_flag_data to CAL
                 *  - This option can be configured on the fly using validate internals.
                 *
                 */
                if (((_a = req.otel) === null || _a === void 0 ? void 0 : _a.isRecording) && errorTracingProcessingEnabled && errorTracingPublishingEnabled) {
                    traceId = req.otel.traceId;
                    const lce = tracing_1.featureFlagSpanManager.getLoggingContextError(traceId);
                    const commandName = ((_b = req.route) === null || _b === void 0 ? void 0 : _b.name) || 'unset';
                    (0, FeatureFlagEventUtils_1.setErrorMetricsToTracingDataHolder)(context, traceId, lce, commandName);
                    diagnosticsHook.publishWithRespCode(tracing_1.TracingDataHolder.getCalDataListById(traceId), res.statusCode);
                }
                diagnosticsHook.flushDiagnosticsDataToCal();
                context.flushExptTagsToTracking(); /// <<<<<< WILL they be there, what happens if initializeFeatureFlags fails???
            }
            catch (error) {
                logger.error('Error in OpenFeature finish handler:', error);
            }
            finally {
                // ensure tracing data holder is cleaned up on res finish to prevent memory leak.
                tracing_1.TracingDataHolder.removeByTraceId(traceId);
                tracing_1.featureFlagSpanManager.removeTrace(traceId);
            }
        });
        next();
    };
    async function initializeFeatureFlags(context) {
        const startTimeInNanoSeconds = process.hrtime.bigint(); // returns time in nanoseconds
        const keys = exports.openfeatureGlobalCache.get('smartClientFlagsSet');
        let labelForEval = exports.openfeatureGlobalCache.get('labelForEvalSet');
        let flagsInitialized = exports.openfeatureGlobalCache.get('flagsInitialized');
        // check whether flags are initalized before. If flags are initialized (not startup call) and smart client flags and label sets are empty, skip the call to epsvc
        if (flagsInitialized && keys.size === 0 && labelForEval.size === 0) {
            logger.debug('Flag Keys and Labels are empty but this is not a startup call. Skipping call to epsvc.');
            const evaluationResultsMap = new Map();
            const emptyEvaluationResults = {
                evaluationResultsMap,
                epTagsEvent: null,
            };
            context.setEvaluationResults(emptyEvaluationResults.evaluationResultsMap, keys);
            context.setEpTagsEventMap((0, utils_1.translateTags)(emptyEvaluationResults.epTagsEvent));
            return Promise.resolve('skipped');
        }
        const contextParams = context.getContextParams();
        if (labelForEval) {
            contextParams.labelForEval = Array.from(labelForEval);
        }
        contextParams.shouldUseEPCache = true; // this is now the default, but we still need to pass along the shouldUseEPCache value
        const data = await context.getServiceClient()
            .invokeInternalSearchApiByFlagList(contextParams, keys);
        if (data && data.evaluationResultsMap) {
            context.setEvaluationResults(data.evaluationResultsMap, keys);
            context.setEpTagsEventMap((0, utils_1.translateTags)(data.epTagsEvent));
            logger.debug('Added %s evaluations into context.', data.evaluationResultsMap.size);
        }
        const currentTimeInNanoSeconds = process.hrtime.bigint(); // returns time in nanoseconds
        const nsDuration = currentTimeInNanoSeconds - startTimeInNanoSeconds;
        // converting to seconds to make it same as raptor and raptorio
        const secondsDuration = Number(nsDuration) / NANOSECONDS_PER_SECOND;
        metricsPublisher.apiQualificationLatencySla
            .labels('nodejs')
            .observe(secondsDuration);
        return Promise.resolve('done');
    }
}
exports.default = openfeature;
//# sourceMappingURL=middleware.js.map