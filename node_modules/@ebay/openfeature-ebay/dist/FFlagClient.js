"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToBoolean = exports.translateResult = exports.FFlagClient = void 0;
const tslib_1 = require("tslib");
const js_sdk_1 = require("@openfeature/js-sdk");
const cal_1 = tslib_1.__importDefault(require("@ebay/cal"));
const logging_inc_1 = require("@ebay/logging-inc");
/**
 * FFlagClient is only used to check the evaluation results map for the flag evaluation for the {@link OpenFeatureProvider}
 * The reevaluation logic and calls to epsvc are handled by the experimentationhook in the before lifecycle.
 */
class FFlagClient {
    constructor() {
        this.logger = (0, logging_inc_1.getLogger)('openfeature-ebay:fflagClient');
    }
    /**
     * Generic method to evaluate the incoming feature flag for each data type that is supported.
     * Default dropTag is set to false as this functionality is not yet supported in espvc.
     * Current implementation with openfeature only supports one feature flag per request, which
     * is why the flagEvals array is created with only a snigle feature flag.
     * @param flagKey
     * @param evalCriteria
     * @returns resolutionDetails evaluation details from epsvc response
     */
    async evaluateFlag(flagKey, evalContext, evaluationResultsMap) {
        const flagEvalDetail = await this.fetchFlagEvalDetail(flagKey, evaluationResultsMap);
        this.handlePoolMismatch(flagEvalDetail);
        return flagEvalDetail;
    }
    /**
     * Given a feature flag key, this method will return the flag evaluation details.
     * ExperimentationHook does the heavy lifting now of re-evaluating the flag in cases for not found or deferred.
     * @param flagKey
     * @param evalContext
     * @param _evaluationResults
     * @returns
     */
    async fetchFlagEvalDetail(flagKey, _evaluationResults) {
        if (!_evaluationResults || _evaluationResults.size == 0) {
            this.logger.debug(`Evaluation results was empty.`);
        }
        const flagEvalFromStore = await this.fetchFlagEvaluationFromStore(flagKey, _evaluationResults);
        // ExperimentationHook should stub flags that were not found, so this shouldn't happen.
        if (!flagEvalFromStore) {
            this.logger.warn(`Didn't find evaluation from store for ${flagKey}`);
            return null;
        }
        return flagEvalFromStore;
    }
    /**
     * This method returns the flag evaluation details from the evaluationResultsMap (store) for the flag key that was passed in.
     * @param flagKey
     * @param evaluationResultsMap
     * @returns flagEvaluDetail
     */
    async fetchFlagEvaluationFromStore(flagKey, evaluationResultsMap) {
        const flagEvalDetail = evaluationResultsMap.get(flagKey);
        return flagEvalDetail;
    }
    /**
     * Flushes a CAL event if the pool is mismatched and is not a pure feature flag. Related JIRA tickets:
     * https://jirap.corp.ebay.com/browse/TS-1724 - Raptor io inline implementation
     * https://jirap.corp.ebay.com/browse/TS-4705 - This change in openfeature-ebay
     * The same implementation can be found on raptor io:
     * raptor-experimentation-impl/src/main/java/com/ebay/experimentation/impl/openfeature/UniversalProviderUtil.java
     * @param flagEval
     */
    handlePoolMismatch(flagEval) {
        var _a;
        if (flagEval) {
            const isPoolMatched = (_a = flagEval.isPoolMatched) !== null && _a !== void 0 ? _a : true;
            const isPureFeatureFlag = flagEval.isPureFeatureFlag;
            if (this.logger.isLogLevelEnabled('debug')) {
                const debugEvent = cal_1.default.createEvent('DEBUG', 'VARIABLE');
                debugEvent.addData(`isFeatureFlag= ${isPureFeatureFlag};isPoolMatched=${isPoolMatched}`);
                debugEvent.complete(cal_1.default.Status.SUCCESS);
            }
            if (!isPureFeatureFlag && !isPoolMatched) {
                // This warning log with status=1 (FATAL) will bypass the opentracing 1% sampling, allowing Touchstone
                // to capture domain pool mismatch events even with minimal Experiment traffic during validation.
                const poolMismatchEvent = cal_1.default.createEvent('Warn', 'POOL_MISMATCHED');
                poolMismatchEvent.addData('This App pool does not match the pool list registered from Touchstone');
                poolMismatchEvent.complete(cal_1.default.Status.FATAL);
            }
        }
    }
}
exports.FFlagClient = FFlagClient;
function translateResult(flagEval) {
    const { details } = flagEval;
    return {
        value: flagEval.featureFlagValue,
        variant: (details && details.variantId.toString()) || '',
        reason: (details && details.reason) || '',
        errorCode: (details && details.errorCode) || js_sdk_1.ErrorCode.GENERAL,
        flagMetadata: {
            isPureFeatureFlag: flagEval === null || flagEval === void 0 ? void 0 : flagEval.isPureFeatureFlag,
            isClientSide: (flagEval === null || flagEval === void 0 ? void 0 : flagEval.isClientSide) || false,
            variantName: details && details.variantName,
            variantDataType: details && details.variantDataType,
            deferredForRuleLevel: details && details.deferredForRuleLevel,
            deferredForEpAaffLevel: details && details.deferredForEpAaffLevel
        },
    };
}
exports.translateResult = translateResult;
function convertToBoolean(stringBool) {
    if (typeof stringBool === 'boolean') {
        return stringBool;
    }
    if (stringBool == null ||
        typeof stringBool !== 'string' ||
        stringBool === '') {
        return null;
    }
    if (stringBool.toLowerCase() === 'true') {
        return true;
    }
    if (stringBool.toLowerCase() === 'false') {
        return false;
    }
    return null;
}
exports.convertToBoolean = convertToBoolean;
//# sourceMappingURL=FFlagClient.js.map