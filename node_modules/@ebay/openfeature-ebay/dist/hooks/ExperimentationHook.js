"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEvaluationSatisfied = exports.mergeContextParams = exports.contextHasChanged = exports.ExperimentationHook = void 0;
const utils_1 = require("../tracking/utils");
const EVALUATION_RESULTS = 'evaluationResults';
const SHOULD_RETRY_EVALUATION = 'shouldRetryEvaluation';
class ExperimentationHook {
    constructor(context) {
        this.context = context;
        this.smartClientFlagsSet = context.openfeatureGlobalCache.get('smartClientFlagsSet');
        this.logger = require('@ebay/logging-inc').logger('openfeature-ebay:experimentationHook');
    }
    async before(hookContext) {
        let evalContext = hookContext.context;
        const flagKey = hookContext.flagKey;
        const initializeFFResult = await this.context.initializeFFPromise;
        if (initializeFFResult !== 'done') {
            this.logger.debug('FFlags not initialized yet.');
        }
        const { hasStoredData, _evaluationResults } = this.context;
        // add the current flag to flag set
        this.smartClientFlagsSet.add(flagKey);
        // should have stored data from middleware smart client call
        if (hasStoredData) {
            // retrieves the original call context and the current cached evaluation results
            const defaultContext = this.context.getContextParams();
            const shouldRetryEvaluation = contextHasChanged(evalContext, defaultContext);
            // check if the flag is currently in evaluation results    
            const flagIsPresent = _evaluationResults.has(flagKey);
            // Case 1: Flag was not present in EvaluationResultsMap cache, it should retry the qualification
            if (!flagIsPresent) {
                this.logger.debug(`Didn't find evaluation from store for ${flagKey} and calling middleware service again`);
                const data = await this.context.getServiceClient().invokeInternalSearchApiByFlagKey(evalContext, flagKey);
                // Case 1.1: Flag was not found from service so it should add a stub to the EvaluationResultsMap cache
                if (!data || !data.evaluationResultsMap || data.evaluationResultsMap.size === 0) {
                    this.logger.debug(`No evaluation results found from service for flag: ${flagKey}`);
                    const flagKeySet = new Set();
                    flagKeySet.add(hookContext.flagKey);
                    this.context.setEvaluationResults(_evaluationResults, flagKeySet);
                    // Case 1.2: Flag was found and should be updated to the EvaluationResultsMap cache
                }
                else {
                    const { evaluationResultsMap } = data;
                    const flagEvalDetail = evaluationResultsMap.get(flagKey);
                    _evaluationResults.set(flagKey, flagEvalDetail);
                    this.context.setEpTagsEventMap((0, utils_1.translateTags)(data.epTagsEvent));
                }
            }
            else {
                // Case 2: Flag was present in cache
                const { details } = _evaluationResults.get(flagKey);
                const hasDeferred = (details.deferredForRuleLevel && details.reason != 'RULE_MATCH') || details.deferredForEpAaffLevel;
                // Case 2.1: Check if the cached evaluation is already satisfied/complete
                const isSatisfiedEvaluation = isEvaluationSatisfied(_evaluationResults.get(flagKey));
                // Case 2.2: The context was updated AND evaluation is not satisfied, so it should retry the qualification
                if (shouldRetryEvaluation && !isSatisfiedEvaluation) {
                    // Merge the new evalContext with the existing defaultContext
                    const mergedEvalContext = mergeContextParams(evalContext, defaultContext);
                    // Case 2.2.1: The flag contains a deferred indicator so it should retry the qualification
                    if (hasDeferred) {
                        this.logger.debug(`${flagKey} Was deferred evaluation and the eval context was updated. Invoking retry`);
                        const data = await this.context.getServiceClient().invokeInternalSearchApiByFlagKey(mergedEvalContext, flagKey);
                        if (!data) {
                            this.logger.error(`No evaluation results found from service for flag: ${flagKey}`);
                        }
                        else {
                            const { evaluationResultsMap } = data;
                            const flagEvalDetail = evaluationResultsMap.get(flagKey);
                            _evaluationResults.set(flagKey, flagEvalDetail);
                        }
                        // Case 2.2.2: The flag is for AnyID use case which does not count as deferred evaluation so it should retry qualification 
                    }
                    else {
                        this.logger.debug(`${flagKey} did not contain a value but the eval context was updated. This is likely for Any ID flow. Invoking retry`);
                        const data = await this.context.getServiceClient().invokeInternalSearchApiByFlagKey(mergedEvalContext, flagKey);
                        if (!data) {
                            this.logger.error(`No evaluation results found from service for flag: ${flagKey}`);
                        }
                        else {
                            const { evaluationResultsMap } = data;
                            const flagEvalDetail = evaluationResultsMap.get(flagKey);
                            _evaluationResults.set(flagKey, flagEvalDetail);
                        }
                    }
                }
                else if (shouldRetryEvaluation && isSatisfiedEvaluation) {
                    // Case 2.3: Context changed but evaluation is satisfied - use cached result
                    this.logger.debug(`${flagKey} has satisfied evaluation despite context change. Using cached result.`);
                }
            }
            const evaluationResults = _evaluationResults;
            evalContext[EVALUATION_RESULTS] = evaluationResults;
            evalContext[SHOULD_RETRY_EVALUATION] = contextHasChanged(evalContext, defaultContext);
        }
    }
    after(hookContext, evaluationDetails) {
        const { flagMetadata: { isPureFeatureFlag }, } = evaluationDetails;
        if (hookContext.context.dropTag !== false &&
            !isPureFeatureFlag &&
            Object.values(this.context).length > 0 &&
            evaluationDetails) {
            this.context.trackServedTreatment(evaluationDetails);
        }
    }
}
exports.ExperimentationHook = ExperimentationHook;
/**
 * This helper function checks whether the original context map has changed between the middleware init epsvc search
 * and any subsequent Evaluation API calls. If evalctx was changed, it may be the app user has included custom attributes.
 * In case the context is unchanged, an evalctx value will indicate that the flag evaluation should not be retried.
 *
 * @param currentContext the context used in this Evaluation API call
 * @param defaultContext the context that was created in middleware request init
 * @returns true if context was changed false if context was unchanged or there is no context params present
 */
function contextHasChanged(currentContext, defaultContext) {
    if (!currentContext.contextParams) {
        return false;
    }
    const contextisUnchanged = Object.keys(currentContext.contextParams)
        .filter((key) => key !== 'DATE')
        .every((key) => currentContext.contextParams[key] ===
        defaultContext.contextParams[key]);
    const hasAnyId = currentContext.hasOwnProperty('ANY_ID_TYPE');
    return !contextisUnchanged || hasAnyId;
}
exports.contextHasChanged = contextHasChanged;
/**
 * This function helps to merge the updated context params into the existing context params from the default context.
 * DefaultContext - the context used at the middleware layer to call epsvc initially
 * CurrentContext - the context supplied by the user when invoking the openfeature sdk (evalContext)
 * @param currentContext
 * @param defaultContext
 * @returns
 */
function mergeContextParams(currentContext, defaultContext) {
    return {
        ...currentContext,
        contextParams: {
            ...defaultContext.contextParams,
            ...currentContext.contextParams
        }
    };
}
exports.mergeContextParams = mergeContextParams;
/**
 * Determines if a cached evaluation is already satisfied/complete and doesn't need re-evaluation
 * despite context changes. This helps avoid unnecessary service calls when the result is already final.
 *
 * @param flagEvalDetail The cached flag evaluation details
 * @returns true if evaluation is satisfied and shouldn't be retried, false otherwise
 */
function isEvaluationSatisfied(flagEvalDetail) {
    if (!flagEvalDetail || !flagEvalDetail.details) {
        return false;
    }
    const { details, featureFlagValue } = flagEvalDetail;
    // Consider evaluation satisfied if:
    // 1. Has a definitive value (not null/undefined)
    // 2. Reason indicates successful evaluation (RULE_MATCH, GUID, etc.)
    // 3. No error code present
    // 4. Not marked as deferred
    const hasDefinitiveValue = featureFlagValue !== null && featureFlagValue !== undefined;
    const hasSuccessfulReason = details.reason === 'RULE_MATCH' ||
        details.reason === 'GUID' ||
        details.reason === 'UID' ||
        details.reason === 'ANYID' ||
        details.reason === 'Opt-in' ||
        details.reason === 'UID_LIST';
    const hasNoError = !details.errorCode || details.errorCode === '';
    const isNotDeferred = !details.deferredForRuleLevel && !details.deferredForEpAaffLevel;
    return hasDefinitiveValue && hasSuccessfulReason && hasNoError && isNotDeferred;
}
exports.isEvaluationSatisfied = isEvaluationSatisfied;
//# sourceMappingURL=ExperimentationHook.js.map