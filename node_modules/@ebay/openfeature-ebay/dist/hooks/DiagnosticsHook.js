"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ApiLog_1 = require("../types/ApiLog");
const DiagnosticsData_1 = require("../types/DiagnosticsData");
const Api_1 = require("../Api");
const CalResponseCode_1 = require("../types/CalResponseCode");
const logger = require('@ebay/logging-inc').logger('openfeature-ebay:diagnosticsHook');
const cal = require('@ebay/cal');
cal.setDefaultWriteStream('cal'); // if you want to print to console, use cal.setDefaultWriteStream('console')
/**
 * DiagnosticsHook is an implementation of the Hook interface that collects diagnostic data
 * during feature flag evaluations and publishes it to CAL (Common Application Logging).
 *
 * This hook is used for preparing the diagnostic data. It set the apiLogList in context with required values
 * from response based on flag evaluation and then publish to the CAL.
 * It uses @ebay/cal library and cal.createEvent method to create the log event.
 *
 * @param context - The context object containing API log list and other diagnostic information.
 */
class DiagnosticsHook {
    constructor(context) {
        this.context = context;
    }
    /**
     * Adds diagnostic data to the API log list if the feature flag key is not already present.
     *
     * @param hookContext - The context of the hook containing information about the feature flag evaluation.
     * @param evaluationDetails - The details of the flag evaluation, including metadata such as variant and reason.
     */
    addDataToApiLogList(hookContext, evaluationDetails) {
        // add data to apiLogList
        const apiLog = new ApiLog_1.ApiLog();
        apiLog.apiName = 'openfeature-ebay';
        apiLog.input = {
            GENERATE_TAG: hookContext.context.dropTag,
            featureFlagKey: hookContext.flagKey,
        };
        apiLog.output = {
            variantId: (evaluationDetails === null || evaluationDetails === void 0 ? void 0 : evaluationDetails.variant) ? evaluationDetails === null || evaluationDetails === void 0 ? void 0 : evaluationDetails.variant : null,
            evaluationStatus: (evaluationDetails === null || evaluationDetails === void 0 ? void 0 : evaluationDetails.reason) ? evaluationDetails === null || evaluationDetails === void 0 ? void 0 : evaluationDetails.reason : "",
        };
        // add the apiLog to context's apiLogList
        this.context.apiLogList.push(apiLog);
    }
    /**
     * Flushes the diagnostics data to CAL (Common Application Logging).
     *
     * This method is called from middleware.ts when diagnostics data with ApiLogList is ready
     * and response is returned.
     */
    flushDiagnosticsDataToCal() {
        try {
            var diagnosticsData = new DiagnosticsData_1.DiagnosticsData();
            diagnosticsData.apiLogList = this.context.apiLogList;
            // for diagnostics data, we are using EP_DIAGNOSTICS as event type and DIAGNOSTICS_DATA as event name
            this.publishDataToCal('EP_DIAGNOSTICS', 'DIAGNOSTICS_DATA', diagnosticsData);
        }
        catch (error) {
            logger.error(`error occurred in flushDiagnosticsDataToCal`, error);
        }
    }
    /**
     * Publishes diagnostic data to CAL by creating an event,
     * attaching the serialized diagnostics data, and completing the event.
     * event type and name can be changed based on requirements
     *
     * @param type - The type of the CAL event.
     * @param name - The name of the CAL event.
     * @param diagnosticsData - The diagnostics data to be published, which will be serialized to JSON.
     */
    publishDataToCal(eventType, eventName, diagnosticsData) {
        var event = cal.createEvent(eventType, eventName);
        event.addData(JSON.stringify(diagnosticsData));
        event.complete();
    }
    /**
     * Publishes feature_flag_data to CAL with captured error and exception span data from open-telemetry
     */
    publishWithRespCode(featureFlagRawEvents, respCode) {
        const eventType = "Feature_Flag_Data";
        const eventName = eventType;
        featureFlagRawEvents.forEach((featureFlagRawEvent) => {
            const calEvent = featureFlagRawEvent.calEvent;
            if (!calEvent) {
                return;
            }
            // Set response code for the main event
            calEvent.respCode = CalResponseCode_1.CalResponseCodeUtils.getResponseCodeByCode(respCode);
            // Ensure calErrorName is null for the main event
            calEvent.calErrorName = null;
            try {
                const calData = JSON.stringify(calEvent);
                const event = cal.createEvent(eventType, eventName);
                // See example of feature_flag_data for overall summary
                // {"commandName":"unset","calErrorName":null,"featureFlagKey":"AAFF.StringDataTest","featureFlagErrorCount":12,"variantId":"126549", "respCode":"2XX"}
                event.addData(calData);
                event.complete();
            }
            catch (error) {
                logger.error('Error serializing feature flag data:', error);
            }
            // Handle error count map and publish additional events
            const errorCountMap = featureFlagRawEvent.calErrorCountMap;
            if (errorCountMap && Object.keys(errorCountMap).length > 0) {
                for (const [errorName, count] of Object.entries(errorCountMap)) {
                    try {
                        // Create a copy of the calEvent for error-specific events
                        const errorCalEvent = {
                            ...calEvent,
                            calErrorName: errorName,
                            featureFlagErrorCount: count
                        };
                        const errorCalData = JSON.stringify(errorCalEvent);
                        const errorEvent = cal.createEvent(eventType, eventName);
                        errorEvent.addData(errorCalData);
                        errorEvent.complete();
                    }
                    catch (error) {
                        logger.error('Error serializing feature flag data:', error);
                    }
                }
            }
        });
    }
    /**
     * Called before the flag evaluation begins, adds the triggered feature flag key to flag list.
     * In case of any evaluation failures the only point which can capture the feature flag key is before evaluation.
     * @param hookContext
     */
    before(hookContext) {
        //Add the feature flag key that was used to feature flag holder for processing feature flag data
        this.context.addFeatureFlagKey(hookContext.flagKey);
    }
    /**
     * Called after a flag evaluation has completed.
     * Adds diagnostic data to the API log list for publishing.
     *
     * @param hookContext - The context of the hook invocation, containing flag and evaluation metadata.
     * @param evaluationDetails - The details of the flag evaluation, including the evaluated value.
     */
    after(hookContext, evaluationDetails) {
        //Add data to api log list which will be published to cal
        this.addDataToApiLogList(hookContext, evaluationDetails);
    }
    /**
     * Creates and returns a `DiagnosticsData` object populated with qualification input and platform data.
     *
     * @param context - The context object containing user and device information.
     * @returns A `DiagnosticsData` instance with populated qualification input and platform data.
     */
    createQualificationInput(context) {
        var diagnosticsData = new DiagnosticsData_1.DiagnosticsData();
        var debugCodesArr = [];
        if (context === null || context === void 0 ? void 0 : context.getIsBot()) {
            debugCodesArr.push(DiagnosticsData_1.DebugCodes.BOT_REQUEST);
        }
        else if ((context === null || context === void 0 ? void 0 : context.getSiteId()) == null || (context === null || context === void 0 ? void 0 : context.getSiteId()) == undefined) {
            debugCodesArr.push(DiagnosticsData_1.DebugCodes.NULL_SITE);
        }
        else if ((0, Api_1.getChannelId)(context === null || context === void 0 ? void 0 : context.getDeviceInfo()) == null || (0, Api_1.getChannelId)(context === null || context === void 0 ? void 0 : context.getDeviceInfo()) == 99) {
            debugCodesArr.push(DiagnosticsData_1.DebugCodes.NULL_CHANNEL);
        }
        const qualificationInput = {
            guid: context === null || context === void 0 ? void 0 : context.getGuid(),
            uid: context === null || context === void 0 ? void 0 : context.getUserId(),
            siteId: context.getSiteId(),
            channelId: (0, Api_1.getChannelId)(context.getDeviceInfo()),
            userAgent: context.getUserAgent(),
            bot: context.getIsBot(),
            debugCodes: (debugCodesArr === null || debugCodesArr === void 0 ? void 0 : debugCodesArr.length) > 0 ? debugCodesArr : null,
        };
        diagnosticsData.qualificationInput = qualificationInput;
        diagnosticsData.platformData = { "platformType": "epOpenFeatureMiddlware" };
        return diagnosticsData;
    }
}
exports.default = DiagnosticsHook;
//# sourceMappingURL=DiagnosticsHook.js.map