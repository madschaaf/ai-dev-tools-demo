"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToEvaluationResultsMap = void 0;
const tslib_1 = require("tslib");
const service_client_ebay_1 = tslib_1.__importDefault(require("@ebay/service-client-ebay"));
const translateContext_1 = tslib_1.__importDefault(require("./openfeature-context/translateContext"));
const Api_1 = require("./Api");
/**
 * This class is used for handling all services that may be used in the middleware.
 * Currently it is calling epsvc and it does not require any authentication (hence empty req)
 */
class Services {
    constructor() {
        this.client = service_client_ebay_1.default.context({}).getClient('featureflag');
    }
    async invokeInternalSearchApiByFlagKey(evalContext, flagKey) {
        const request = (0, translateContext_1.default)(evalContext, flagKey);
        const response = await this.call(request);
        return convertToEvaluationResultsMap(response);
    }
    async invokeInternalSearchApiByFlagList(evalContext, flagsList) {
        const request = (0, translateContext_1.default)(evalContext, null, Array.from(flagsList));
        const response = await this.call(request);
        return convertToEvaluationResultsMap(response);
    }
    async invokeInternalSearchApiByLabel(evalContext, labelForEval) {
        evalContext.labelForEval = Array.from(labelForEval);
        const request = (0, translateContext_1.default)(evalContext);
        const response = await this.call(request);
        return convertToEvaluationResultsMap(response);
    }
    async call(data) {
        return new Promise((resolve, reject) => {
            var _a;
            // ChannelEnum.OTHER is a default/invalid channel id=99 and will never qualify for any flags
            // filter out bots by using bot-handler-ebay. If the traffic is bot it will be including req.ebay.bot object which is passed to evalMetadata
            if (data.evalCriteria.channelId == Api_1.CHANNEL_ENUM.OTHER || ((_a = data.evalCriteria.evalMetadata) === null || _a === void 0 ? void 0 : _a.IS_BOT)) {
                resolve(getEmptyEvaluationResults());
                return;
            }
            this.client
                .post({
                body: JSON.stringify(data),
                qs: {
                    detail: 'true',
                },
            })
                .end((error, response) => {
                if (error) {
                    reject(new Error(error));
                    return;
                }
                resolve(response.body);
            });
        });
    }
}
exports.default = Services;
function convertToEvaluationResultsMap(evaluationResults) {
    const evaluationResultsMap = new Map();
    evaluationResults.evaluationResults.forEach((result) => {
        evaluationResultsMap.set(result.featureFlagKey, result);
    });
    return {
        evaluationResultsMap,
        epTagsEvent: evaluationResults.epTagsEvent,
    };
}
exports.convertToEvaluationResultsMap = convertToEvaluationResultsMap;
function getEmptyEvaluationResults() {
    return {
        evaluationResults: [],
        epTagsEvent: null,
    };
}
//# sourceMappingURL=Services.js.map