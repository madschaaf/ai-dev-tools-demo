"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeatureFlagSpanProcessor = void 0;
const api_1 = require("@opentelemetry/api");
const FeatureFlagErrorInfo_1 = require("../types/FeatureFlagErrorInfo");
class FeatureFlagSpanProcessor {
    constructor() {
        this.traceIdMap = new Map();
    }
    /** Do nothing. For satisfying SpanProcessor interface only */
    onStart(span, parentContext) {
        return;
    }
    onEnd(span) {
        try {
            this.report(span);
        }
        catch (error) {
            console.error('Error in FeatureFlagSpanProcessor:', error);
        }
    }
    /** Do nothing. For satisfying SpanProcessor interface only */
    shutdown() {
        return Promise.resolve();
    }
    /** Do nothing. For satisfying SpanProcessor interface only */
    forceFlush() {
        return Promise.resolve();
    }
    report(span) {
        if (!span || !span.attributes) {
            return;
        }
        const name = this.getErrorName(span);
        const status = this.getStatus(span);
        const httpStatusCode = this.getHttpStatusCode(span);
        // For error detection we will check:
        // 1. Is the trace status === 2 (ERROR)
        // 2. Is the http status code attribute >= 400
        if (span.spanContext().traceId) {
            if (status === 2 || httpStatusCode >= 400) {
                this.getFeatureFlagErrorInfo(span.spanContext().traceId).addErrorEvent(name);
            }
        }
    }
    getFeatureFlagErrorInfo(traceId) {
        let existErrInfo = this.traceIdMap.get(traceId);
        // Check if existing map contains trace id key already
        if (existErrInfo) {
            return existErrInfo;
        }
        existErrInfo = new FeatureFlagErrorInfo_1.FeatureFlagErrorInfo();
        // Put new TraceEntry obj by trace id to map
        this.traceIdMap.set(traceId, existErrInfo);
        const newErrInfo = this.traceIdMap.get(traceId);
        if (newErrInfo) {
            return newErrInfo;
        }
        return existErrInfo;
    }
    /**
     * Return the error message name from span
     */
    getErrorName(span) {
        var _a;
        const attributes = span.attributes || {};
        const exceptionMessage = attributes['exception.message'];
        if (typeof exceptionMessage === 'string') {
            return exceptionMessage;
        }
        // Check span status message
        if ((_a = span.status) === null || _a === void 0 ? void 0 : _a.message) {
            return span.status.message;
        }
        return 'null';
    }
    /**
     * Returns the span status which is defined by SpanStatusCode
     * 0 = UNSET
     * 1 = OK
     * 2 = ERROR
     * @param span
     * @returns
     */
    getStatus(span) {
        const statusCode = span.status.code;
        if (statusCode) {
            return statusCode;
        }
        ;
        return api_1.SpanStatusCode.UNSET;
    }
    getHttpStatusCode(span) {
        const attributes = span.attributes || {};
        const httpStatusCode = attributes['http.status_code'];
        // Type check and validate the HTTP status code
        if (typeof httpStatusCode === 'number' && !isNaN(httpStatusCode)) {
            return httpStatusCode;
        }
        return 200;
    }
    removeTrace(traceId) {
        this.traceIdMap.delete(traceId);
    }
    removeTraceMap() {
        this.traceIdMap.clear();
    }
    getTraceIdMap() {
        return new Map(this.traceIdMap);
    }
}
exports.FeatureFlagSpanProcessor = FeatureFlagSpanProcessor;
//# sourceMappingURL=FeatureFlagSpanProcessor.js.map