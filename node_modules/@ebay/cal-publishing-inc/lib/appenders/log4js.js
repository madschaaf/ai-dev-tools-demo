'use strict';

var log4js = require('log4js');
var utils = require('../utils');
var shortstop = require('shortstop');
var fs = require('fs');
var nodePath = require('path');
var NodeUtils = require('util');

var resolver = shortstop.create();
resolver.use('pid', function(path, cb) {
    cb(null, path.replace(/\{pid\}/g, process.env.pm_id === undefined ? process.pid : process.env.pm_id));
});

function format(evt, colorEnabled) {
    var outArgs = [];

    outArgs.push(new Date(evt.timestamp));
    outArgs.push('['+evt.messageClass+']');
    outArgs.push(evt.type+':');
    outArgs.push(evt.name);
    if (evt.data.msg || evt.data.error) {
        outArgs.push(evt.data.msg && '"'+evt.data.msg+'"' || evt.data.error && evt.data.error.stack);
    }
    if (typeof evt.data === 'object') {
        for (var k in evt.data) {
            if (k === 'error' || k === 'msg') {
                continue;
            }
            var value = evt.data[k];
            outArgs.push('&' + k + '=' +
                (typeof value === 'string' ? value : NodeUtils.inspect(value, null, 2)));
        }
    }
    else {
        outArgs.push(evt.data);
    }
    if (evt.duration) {
        outArgs.push(utils.humanize(evt.duration));
    }
    outArgs.push(evt.status);

    return outArgs;
}

function patchLogger(logger) {
    if (!logger.__oldEmit) {
        logger.__oldEmit = logger.emit;
        logger.emit = function pacthedLog() {
            if (arguments.length > 1 && arguments[0] === 'log') {
                var evt = arguments[1];
                evt.startTime = evt.data[0];
                evt.data = evt.data.slice(1);
            }
            logger.__oldEmit.apply(logger, arguments);
        };
    }
}

function consume(evt) {
    var logger = log4js.getLogger(evt.logger);
    patchLogger(logger);
    var method = logger[evt.loglevel];

    method && method.apply(logger, format(evt));
}

module.exports.configure = function configure(config) {
    resolver.resolve(config, function(err, data) {
        // for legacy configs, convert them to new one
        if (Array.isArray(data.appenders)) {
            data.appenders = data.appenders.reduce((acc, appender, index) => {
                const name = (index === 0) ? 'logfile' : `logfile${index}`;
                acc[name] = appender;
                return acc;
            }, {});
            data.categories = data.categories || {
                default: {
                    appenders: [
                        'logfile'
                    ], 
                    level: 'error'
                }
            };
        }
        Object.entries(data.appenders || {}).forEach(function(entry) {
            const [, appender] = entry;
            if (appender.filename) {
                var parent = nodePath.resolve(process.cwd(), nodePath.dirname(appender.filename));
                if (!fs.existsSync(parent)) {
                    fs.mkdirSync(parent);
                }
            }
        });
        log4js.configure(data);
    });
    console.trace('BOOM');
    return consume;
};
