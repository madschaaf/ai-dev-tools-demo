const { getValue } = require('@ebay/utils/object');
const Provider = require('@ebay/service-client-ebay');
const loggerInc = require('@ebay/logging-inc');
const isSOAPRequest = serviceRequest => serviceRequest.options && serviceRequest.options.operation;
const { STATUS_CODES } = require('http');

/**
 * Creates arguments for POST and PUT service client calls
 * @param {ServiceRequest} serviceRequest
 */
function createArguments(serviceRequest) {
    const args = {};
    if (serviceRequest.body) {
        if (isSOAPRequest(serviceRequest)) {
            args.body = serviceRequest.body;
        } else if (typeof serviceRequest.body === 'string') {
            args.body = serviceRequest.body;
        } else {
            args.body = JSON.stringify(serviceRequest.body);
        }
    }
    if (serviceRequest.query) {
        args.qs = serviceRequest.query;
    }
    return args;
}

/**
 *
 * @param {object} provider
 * @param {ServiceRequest} serviceRequest
 */
function getAugmentProvider(provider, serviceRequest) {
    return provider.get(getValue(serviceRequest, 'query', {}));
}

/**
 *
 * @param {object} provider
 * @param {ServiceRequest} serviceRequest
 */
function postAugmentProvider(provider, serviceRequest) {
    return provider.post(createArguments(serviceRequest));
}

/**
 *
 * @param {object} provider
 * @param {ServiceRequest} serviceRequest
 */
function putAugmentProvider(provider, serviceRequest) {
    return provider.put(createArguments(serviceRequest));
}

/**
 * Creates arguments for PATCH service client calls
 * @param {ServiceRequest} serviceRequest
 */
function patchAugmentProvider(provider, serviceRequest) {
    return provider.patch(createArguments(serviceRequest));
}

/**
 *
 * @param {object} provider
 * @param {ServiceRequest} serviceRequest
 */
function deleteAugmentProvider(provider, serviceRequest) {
    const args = createArguments(serviceRequest);
    const deleteProvider = provider.delete(args);
    // This is a hack for adding a body to a delete request.
    deleteProvider.request.body = args.body;
    return deleteProvider;
}

/**
 * Creates a fetch like client for services for eBay
 *
 * @param {string} client name of the service client specified in the config
 * @param {eBayRequestContext} context for making the service request to downstream requests
 * @param {ServiceRequest} serviceRequest used to make the request
 * @param {ServiceRequestOptionalCallback} [callback] optional callback
 * @returns {Promise<any>} returns a promise with the response JSON object
 */
function serviceClient(client, context, serviceRequest, callback) {
    const logger = loggerInc.logger(`services/${client}`);
    logger.info(`Starting request for ${client}`);
    // Converts Symbols and Maps to objects. Objects don't have a `get` method.
    if (serviceRequest.headers && Object.getPrototypeOf(serviceRequest.headers).hasOwnProperty('get')) {
        serviceRequest.headers = [...serviceRequest.headers].reduce(
            (acc, item) => { acc[item[0]] = item[1]; return acc; }
            , {});
    }
    return new Promise((resolve, reject) => {
        let serviceProvider = Provider.context(context).getClient(client);

        switch (serviceRequest.method.toUpperCase()) {
            case 'GET':
                serviceProvider = getAugmentProvider(serviceProvider, serviceRequest);
                break;
            case 'POST':
                serviceProvider = postAugmentProvider(serviceProvider, serviceRequest);
                break;
            case 'PUT':
                serviceProvider = putAugmentProvider(serviceProvider, serviceRequest);
                break;
            case 'PATCH':
                serviceProvider = patchAugmentProvider(serviceProvider, serviceRequest);
                break;
            case 'DELETE':
                serviceProvider = deleteAugmentProvider(serviceProvider, serviceRequest);
                break;
            default:
                throw new Error(`HTTP method '${serviceRequest.method}' not supported`);
        }

        if (serviceRequest.path) {
            serviceProvider = serviceProvider.path(serviceRequest.path, serviceRequest.params || {});
        }

        if (serviceRequest.options) {
            serviceProvider = serviceProvider.options(serviceRequest.options);
        }

        if (context?.headers?.authorization) {
            serviceProvider = serviceProvider.set('Authorization', context.headers.authorization);
        }

        const headers = serviceRequest?.headers || {};

        Object.keys(headers).forEach(key => {
            const value = headers[key];
            serviceProvider = serviceProvider.set(key, value);
        });

        serviceProvider.end((error, response) => {
            logger.info(`Service request finished for ${client}`);

            if (callback) {
                return callback(resolve, reject, error, response);
            }

            if (error) return reject(error);

            const result = response.body;
            resolve(result);
        });
    });
}

/**
 * Get the value of header
 *
 * @param {string} header can be case insensitive `content-type` or `Content-Type`.
 * @param {object} headers object representing headers
 * @returns {string}
 */
function getValueForHeader(header, headers) {
    const keyMap = Object.keys(headers).map(key => ({ key, standardizedKey: key.toLowerCase(), value: headers[key] }));
    const map = keyMap.find(field => field.standardizedKey === header.toLowerCase());
    return headers[map?.key];
}

/**
 * Fetch interface for service client
 *
 * @param {string} serviceName service name from config.json
 * @param {eBayRequestContext} context for making the service request to downstream requests
 * @param {ServiceRequest} options used to make the request
 * @returns {Promise<Fetch>}
 */
function fetch(serviceName, context, options) {
    return serviceClient(serviceName, context, options, (resolve, reject, error, response) => {
        const res = response || error.res;
        if (res) {
            return resolve({
                ok: res.statusCode >= 200 && res.statusCode <= 299,
                status: res.statusCode,
                statusText: STATUS_CODES[res.statusCode],
                headers: {
                    get: (header) => getValueForHeader(header, res.headers)
                },
                json: async () => res.body
            });
        }
        return reject(error);
    });
}

module.exports = {
    fetch,
    serviceClient
};
