const Assert = require('assert');
const modConfig = require('@ebay/module-config-inc');
const nock = require('nock');
const { serviceClient } = require('../lib/serviceClient');

let servicesCache;
/**
 * Gets config for services
  * @returns {Promise<object>}
 */
async function getServices() {
    return new Promise((resolve, reject) => {
        if (servicesCache) {
            resolve(servicesCache);
        } else {
            modConfig(module, (err, config) => {
                if (err) return reject(err);
                const services = config.get('services');
                servicesCache = { ...services };
                resolve(services);
            });
        }
    });
}

/**
 * Gets url and basepath for use with nock for a given service
 * @param {string}              service name of service
 * @returns {Promise<object>}
 */
async function nockConfigFor(service) {
    const services = await getServices();
    const { protocol, hostname, basepath } = services[service];
    const url = `${protocol}//${hostname}`;
    return { url, basepath };
}

describe('serviceClient', () => {
    let catSvc;
    beforeEach(async () => {
        catSvc = await nockConfigFor('ebay-fetch-test-categoryService');
        nock(catSvc.url)
            .get(`${catSvc.basepath}/someerror`)
            .replyWithError('Provider Error');
        nock(catSvc.url).persist()
            .get(`${catSvc.basepath}/somepath`)
            .reply(200, {});
        nock(catSvc.url)
            .put(`${catSvc.basepath}/somepath`)
            .reply(200, {});
        nock(catSvc.url).persist()
            .post(`${catSvc.basepath}/somepath`)
            .reply(200, {});
        nock(catSvc.url).persist()
            .post(`${catSvc.basepath}/somepath?`)
            .reply(200, {});
        nock(catSvc.url).persist()
            .patch(`${catSvc.basepath}/somepath`)
            .reply(200, {});
        nock(catSvc.url)
            .delete(`${catSvc.basepath}/somepath`)
            .reply(200, {});
    });

    afterEach(() => {
        nock.cleanAll();
    });

    it('should error when provider rejects with an error', done => {
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'GET',
            path: '/someerror'
        }).then(() => done('did not throw an error!')).catch(err => {
            Assert.equal(err.message, 'Provider Error');
            done();
        });
    });

    it('should error when method not implemented', done => {
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'UNKNOWN'
        }).then(() => done('did not throw an error!')).catch(err => {
            Assert.equal(err.message, 'HTTP method \'UNKNOWN\' not supported');
            done();
        });
    });

    it('should not error when called with GET method with callback', (done) => {
        serviceClient('ebay-fetch-test-categoryService', {
            headers: { authorization: 'NONE' }
        }, {
            method: 'GET',
            path: '/somepath',
            options: {},
            headers: { test: 'test' }
        }, () => {
            done();
        }).catch(done);
    });

    it('should not error when called with GET method', (done) => {
        serviceClient('ebay-fetch-test-categoryService', {
            headers: { authorization: 'NONE' }
        }, {
            method: 'GET',
            path: '/somepath',
            options: {},
            headers: { test: 'test' }
        }).then(() => {
            done();
        }).catch(done);
    });

    it('should not error when called with DELETE method', (done) => {
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'DELETE',
            path: '/somepath'
        }).then(() => {
            done();
        });
    });

    it('should not error when called with POSTing in SOAP', (done) => {
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'POST',
            body: 'string',
            path: '/somepath',
            options: { operation: 'op' }
        }).then(() => { done(); }).catch(done);
    });

    it('should not error when called with POST method', (done) => {
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'POST',
            path: '/somepath',
            body: {},
            query: {}
        }).then(() => { done(); }).catch(done);
    });

    it('should not error when called with POST method, using a string body', (done) => {
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'POST',
            path: '/somepath',
            body: 'string'
        }).then(() => { done(); }).catch(done);
    });

    it('should not error when called with POST method, using a Map header', (done) => {
        const headers = new Map();
        headers.set('authorization', 'Bearer 123==');
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'POST',
            path: '/somepath',
            body: 'string',
            headers
        }).then(() => { done(); }).catch(done);
    });

    it('should not error when called with PUT method', (done) => {
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'PUT',
            path: '/somepath',
            body: {}
        }).then(() => { done(); }).catch(done);
    });

    it('should not error when called with PATCH method', (done) => {
        serviceClient('ebay-fetch-test-categoryService', {}, {
            method: 'PATCH',
            path: '/somepath',
            body: {}
        }).then(() => { done(); }).catch(done);
    });
});