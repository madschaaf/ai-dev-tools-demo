const assert = require('chai').assert;
const modConfig = require('@ebay/module-config-inc');
const nock = require('nock');
const { fetch: ebayFetch } = require('../lib/serviceClient');
const nodeFetch = require('node-fetch');
let servicesCache;

/**
 * Gets config for services
  * @returns {Promise<object>}
 */
async function getServices() {
    return new Promise((resolve, reject) => {
        if (servicesCache) {
            resolve(servicesCache);
        } else {
            modConfig(module, (err, config) => {
                if (err) return reject(err);
                const services = config.get('services');
                servicesCache = { ...services };
                resolve(services);
            });
        }
    });
}

/**
 * Gets url and basepath for use with nock for a given service
 * @param {string}              service name of service
 * @returns {Promise<object>}
 */
async function nockConfigFor(service) {
    const services = await getServices();
    const { protocol, hostname, basepath } = services[service];
    const url = `${protocol}//${hostname}`;
    return { url, basepath };
}

describe('fetch', () => {
    let catSvc;
    beforeEach(async () => {
        catSvc = await nockConfigFor('ebay-fetch-test-categoryService');
    });

    afterEach(() => {
        nock.cleanAll();
    });

    it('should have the basic characteristics of a fetch request', async () => {
        nock(catSvc.url)
            .post(`${catSvc.basepath}/somepath`)
            .times(2)
            .reply(200, {});

        const nodeResponse = await nodeFetch(`${catSvc.url + catSvc.basepath}/somepath`, {
            method: 'POST',
            body: {}
        });

        const res = await ebayFetch('ebay-fetch-test-categoryService', {}, {
            method: 'POST',
            path: '/somepath',
            body: {}
        });
        assert.equal(res.ok, nodeResponse.ok);
        assert.equal(res.ok, true);
        assert.equal(res.status, nodeResponse.status);
        assert.equal(res.statusText, nodeResponse.statusText);
        const nodeFetchContentType = nodeResponse.headers.get('Content-Type');
        const ebayFetchContentType = res.headers.get('Content-Type');
        assert.equal(ebayFetchContentType, nodeFetchContentType);
        const nodeJSON = await nodeResponse.json();
        const ebayJSON = await res.json();
        assert.deepEqual(ebayJSON, nodeJSON);
    });

    it('should not error when trying to get a response header value not included in the response', async () => {
        nock(catSvc.url)
            .post(`${catSvc.basepath}/somepath`)
            .reply(200, {
                'Content-Type': 'application/json'
            });

        const res = await ebayFetch('ebay-fetch-test-categoryService', {}, {
            method: 'POST',
            path: '/somepath',
            body: {}
        });

        const contentType = res.headers.get('Content-Type');
        assert.equal(contentType, 'application/json');

        const cacheControl = res.headers.get('cache-control');
        assert.isUndefined(cacheControl);
    });

    it('should 404 the same way', async () => {
        nock(catSvc.url)
            .post(`${catSvc.basepath}/somepath`)
            .times(2)
            .reply(404, { message: 'Not Found' });

        const nodeResponse = await nodeFetch(`${catSvc.url + catSvc.basepath}/somepath`, {
            method: 'POST',
            body: {}
        });

        const res = await ebayFetch('ebay-fetch-test-categoryService', {}, {
            method: 'POST',
            path: '/somepath',
            body: {}
        });
        assert.equal(res.ok, nodeResponse.ok);
        assert.equal(res.ok, false);
        assert.equal(res.status, nodeResponse.status);
        assert.equal(res.statusText, nodeResponse.statusText);
        const nodeFetchContentType = nodeResponse.headers.get('Content-Type');
        const ebayFetchContentType = res.headers.get('Content-Type');
        assert.equal(ebayFetchContentType, nodeFetchContentType);
        const nodeJSON = await nodeResponse.json();
        const ebayJSON = await res.json();
        assert.deepEqual(ebayJSON, nodeJSON);
    });

    it('should 500 the same way', async () => {
        nock(catSvc.url)
            .post(`${catSvc.basepath}/somepath`)
            .times(2)
            .reply(500, { message: 'Internal Server error' });

        const nodeResponse = await nodeFetch(`${catSvc.url + catSvc.basepath}/somepath`, {
            method: 'POST',
            body: {}
        });

        const res = await ebayFetch('ebay-fetch-test-categoryService', {}, {
            method: 'POST',
            path: '/somepath',
            body: {}
        });
        assert.equal(res.ok, nodeResponse.ok);
        assert.equal(res.ok, false);
        assert.equal(res.status, nodeResponse.status);
        assert.equal(res.statusText, nodeResponse.statusText);
        const nodeFetchContentType = nodeResponse.headers.get('Content-Type');
        const ebayFetchContentType = res.headers.get('Content-Type');
        assert.equal(ebayFetchContentType, nodeFetchContentType);
        const nodeJSON = await nodeResponse.json();
        const ebayJSON = await res.json();
        assert.deepEqual(ebayJSON, nodeJSON);
    });

    it('should throw errors in a similar way', async () => {
        nock(catSvc.url)
            .post(`${catSvc.basepath}/someerror`)
            .times(2)
            .replyWithError('Provider Error');

        try {
            await nodeFetch(`${catSvc.url + catSvc.basepath}/someerror`, {
                method: 'POST',
                body: {}
            });
            assert.fail();
        } catch (e) {
            assert.include(e.message, 'Provider Error');
        }
        try {
            await ebayFetch('ebay-fetch-test-categoryService', {}, {
                method: 'POST',
                path: '/someerror',
                body: {}
            });
            assert.fail();
        } catch (e) {
            assert.include(e.message, 'Provider Error');
        }
    });
});