/**
 *
 *  Commons for Node.js request
 *
 *  It decorate the express req object with
 *  - application name
 *  - pageStartTime - page load start time
 *  - root URL txn
 */
'use strict';

var url = require('url'),
    cal = require('@ebay/cal'),
    util = require('util'),
    utils = require('./utils'),
    moment = require('moment'),
    onHeaders = require('on-headers'),
    deployEnv = require('@ebay/environment-ebay'),
    stringify = require('json-stringify-safe'),
    logger = require('@ebay/logging-inc').logger('@ebay/commons-inc'),
    security = require('@ebay/security-ebay'),
    moduleConfig = require('@ebay/module-config-inc'),
    configBean = require('@ebay/config-bean-ebay');

var HostIPChecker = require('@ebay/hostip-checker-ebay');
var UtilsEbay = require('@ebay/utils-ebay');
var tryrequire = require('try-require');
const COMMONS_INC_BEAN_ID = 'nodejs.config.commons-inc.common';
const env = require('@ebay/environment-ebay');
const {
    platformMetrics
} = require('@ebay/prometheus-ebay');

const counter = platformMetrics.createCounter(
    'cache_control_ttl_maxage_counter',
    'Cache control ttl maxage counter',
    ['cache_control_ttl_max_age_count']
);

require('@ebay/cal-publishing-inc');
var Hoek = require('hoek');

var DATE_FORMAT = 'MMM D, YYYY HH:mm:ss Z',
    appName,
    poolName,
    debugInfo;

function clientRedirect(url, req) {
    var noncePH = req && req.csp && req.csp.nonce ? ' nonce="'+req.csp.nonce+'"' : '';
    return util.format('<script'+noncePH+'>window.location.href="%s";</script>', url);
}

let initConfig;
let configRemoveEndUserCtx;
let forceEnableEndUserCtx;

function init(options = {}) {
    if (initConfig) {
        return;
    }
    initConfig = true;


    moduleConfig(module, function (err, config) {
        const bean = configBean.getBeanById(COMMONS_INC_BEAN_ID);
        if (err || !bean) {
            return;
        }
        configRemoveEndUserCtx = config.get('commons-inc:removeEndUserCtx');
        forceEnableEndUserCtx = config.get('commons-inc:forceEnableEndUserCtx');

        // Add a listener to update the value in memory when the config changes
        config.on('change', function (newConfig) {
            configRemoveEndUserCtx = newConfig && newConfig.get('commons-inc:removeEndUserCtx') || bean.get('commons-inc:removeEndUserCtx');
            forceEnableEndUserCtx = newConfig && newConfig.get('commons-inc:forceEnableEndUserCtx') || bean.get('commons-inc:forceEnableEndUserCtx');
        });
    });
}

init();

module.exports = function Commons(options) {
    options = options || {};

    var pkgJson = utils.getPkgJSON();

    appName = pkgJson && pkgJson.name;
    poolName = options.poolName || appName;

    debugInfo = utils.buidDebugInfo();

    var version;
    var brogan = tryrequire('@ebay/brogan-ebay/package.json');
    var commonsebay = tryrequire('@ebay/commons-ebay/package.json');

    if (brogan && brogan.version) {
        version = brogan.version.split('.');
        if (version[0] < 4 || (version[0] === '4' && version[1] === '0' && version[2] < 5)) {
            throw new Error('commons-inc version 4.0.4 or higher requires brogan-ebay 4.0.5 or higher');
        }
    }

    if (commonsebay && commonsebay.version) {
        version = commonsebay.version.split('.');
        if (version[0] < 4 || (version[0] === '4' && version[1] === '0' && version[2] < 5)) {
            throw new Error('commons-inc version 4.0.4 or higher requires commons-ebay 4.0.5 or higher');
        }
    }

    return function commons(req, res, next) {

        var debug = null,
            route = req.route,
            pageName = route && route.config && (route.config.pageName || route.config.pagename),
            path = pageName || 'unknown',
            date = new Date(),
            now = date.getTime(),
            formattedDate = moment(date).format(DATE_FORMAT),
            isRootTxnFinished = false,
            _render = res.render,
            _redirect = res.redirect,
            _json = res.json,
            _jsonp = res.jsonp,
            _send = res.send,
            _end = res.end,
            rootTxn = {},
            templateName,
            renderStartTime;

        var isQualyscan = req.isQualyscan = HostIPChecker.isQualysRequest(req) ||
                HostIPChecker.isQualyscanIP(UtilsEbay.getRemoteAddr(req));

        res.locals = res.locals || {};
        res.locals.context = res.locals.context || {};

        var pageInfo = res.locals.context.pageInfo = {
            date: formattedDate,
            script: 'node'
        };

        // for backward compatibility
        req.log = function log(level, data) {
            var lLevel = level.toLowerCase();
            var fn = logger[lLevel] && logger[lLevel].bind(logger);
            fn && fn(data);
        };

        path = isQualyscan ? 'qualyscan' : path;
        cal.createTransaction('URL', path, function(err, tx) {

            tx.flush();

            req.pageStartTime = now;
            req.appName = appName;

            // dedup it
            var endRootTxn = Hoek.once(function endRootTxn(err) {
                let calData = {
                    'corr_id_': utils.tryGetCorrId(req) || '0',
                    'node_id': utils.tryGetNodeId(req) || '0',
                    'log_id_': req.pageStartTime ? req.pageStartTime.toString(16) : '',
                    'application_name': req.appName || '',
                    'url': req.originalUrl || req.url || req.path
                };

                const az = process.env.CMS_AVAILABILITYZONE;
                if (az) {
                    tx.addData('az', az);
                }
                const cluster = process.env.TESS_CLUSTER_ID;
                if (cluster) {
                    tx.addData('cluster', cluster);
                }

                //Add ri to CAL for service usecase
                let ri = utils.tryGetRequestId(req);
                if(ri) {
                    calData.ri = ri;
                }

                tx.addData(calData);

                if (err) {
                    var errEvt = cal.createEvent('Error',
                        path + '_' + (err.code || 'Error'));
                    // force error to the main transaction level
                    if (errEvt.parent) {
                        // record context where the error happened
                        errEvt.addData('context', errEvt.parent.name);
                    }
                    errEvt.parent = tx;
                    errEvt.addData(err.stack)
                        .complete(err.code === 'ECONNRESET' ? 2 : 1);
                }
                if (isRootTxnFinished) {
                    return;
                }
                isRootTxnFinished = true;

                if (isQualyscan) {
                    tx.status = 0;
                }
                else {
                    //Log Event for response_code>=300
                    if(res.statusCode >=300) {
                        var resStatusEvent = cal.createEvent('URL', 'response_code');
                        if(res.statusCode<400) {
                            resStatusEvent.addData('redirect_url', res.getHeader('Location') || '');
                        }
                        resStatusEvent.status = res.statusCode;
                        resStatusEvent.complete();
                    }

                    if (res.statusCode >= 500 || res._error || err) {
                        err = err || res._error;
                        if (err) {
                            tx.addData({
                                'error': err.stack || err.message
                            });
                        }
                        tx.status = 1;
                    }

                    //Set Main URL TX status to the status code for 4xx & 5xx
                    if(res.statusCode >= 400) {
                        tx.status = res.statusCode;
                    }
                }
                tx.addData('statusCode', res.statusCode);
                // TODO: should be moved to commone-ebay, need to expose main TX context (req.txCtx) so that other can attach data
                tx.addData({
                    'GUID': utils.tryGetGuid(req) || 'none',
                    'rlogid': utils.tryGetRlogId(req) || 'none'
                });
                tx.complete();
            });

            res.once('finish', endRootTxn);
            res.once('close', function onAbort() {
                if (isQualyscan) {
                    // suppress even connection resets
                    return endRootTxn();
                }
                res.statusCode = 499;
                var err = new Error('Connection was closed by peer/browser, no response sent');
                err.code = 'ECONNRESET';
                endRootTxn(err);
            });
            res.on('error', function onError(err) {
                if (env.isDev() || env.isTest()) {
                    console.error(`[ERROR] ${err && err.stack || 'Unknown, no data emitted'}`);
                }
                res.statusCode = 500;
                endRootTxn(err);
            });

            onHeaders(res, function() {
                // Check if cookies are not disabled
                const setCookieHeader = res.getHeader('Set-Cookie');
                // check cache control header
                const cacheControl = res.getHeader('Cache-Control');
                if (setCookieHeader && cacheControl && /ttl/.test(cacheControl) && /max-age=(?!0\b)\d+/.test(cacheControl)) {
                    // Log the warn in CAL
                    cal.createEvent('Warn', 'Cache-Control', -1, 'Cache-Control contains ttl and max-age.').complete();
                    counter.inc();
                }
                res.header('rlogid', utils.tryGetRlogId(req));
            });

            if (options.disablePerformanceMeters !== true) {
                attachPerformanceMeters(req);
            }

            next();
        });

        function attachPerformanceMeters(req) {

            let sendWasUsed;

            res.end = async function () {
                var _rlogid = utils.tryGetRlogId(req);
                var _rcmdid = utils.tryGetRcmdId(req);
                var _siteid = utils.tryGetSiteId(req);
                var _environment = utils.tryGetEnvironment(req);
                var _appname = utils.tryGetAppName(req);
                var _pageid = utils.tryGetPageId(req);
                var contentType = res.getHeader('Content-Type');
                if (!sendWasUsed && contentType && contentType.indexOf('text/html') !== -1) {
                    if (res.statusCode === 200) {
                        res.write(util.format('<!-- RcmdId %s,RlogId %s --><!-- SiteId: %s, Environment: %s, AppName: %s, PageId: %s -->', _rcmdid, _rlogid, _siteid, _environment, _appname, _pageid));
                        let removeEndUserCtx;
                        // check if removeEndUserCtx is enabled or not
                        removeEndUserCtx = await shouldRemoveEndUserContext(req);

                        const cosHeadersFunction = utils.generateCosHeadersFunction(req, removeEndUserCtx);
                        if (cosHeadersFunction) {
                            res.write(`<script type="text/javascript">(${cosHeadersFunction})(window)</script>`);
                        }

                        if (deployEnv.isDev() ||
                            (deployEnv.isNotProd() || deployEnv.isPreProd()) &&
                            req.headers && (req.headers['X-EBAY-PAGE-INFO'.toLowerCase()] ||
                                req.headers['X-EBAY-PAGE-INFO']) === 'true') {
                                pageInfo.debug = debugInfo;
                                pageInfo.locality = req.locality;
                                // TODO: should be moved to commone-ebay
                                pageInfo.siteInfo = req.ebay && req.ebay.siteInfo;
                                //Right now, not enabled for Prod
                                res.write(util.format('\n<!-- %s -->', stringify(pageInfo, null, 2)));
                        }
                    }
                    // TODO: should only be sent when headers sent: else if (res.headersSent && res.statusCode >= 500) {
                    // once enabled we need to make sure everybody use error handler with redirect or we should inject default one
                    // via brogan-ebay
                    else if (!res.customPageError && res.statusCode >= 500) {
                        //Redirect to PNF in nonDev env in case of error
                        if (deployEnv.isNotDev() && deployEnv.isNotTest()) {

                            var noncePH = req && req.csp && req.csp.nonce ? ' nonce="'+req.csp.nonce+'"' : '';
                            var eBayFPFScript = "<script"+noncePH+">window.location.href = 'http://pages.ebay.com/messages/page_not_responding.html'</script>";
                            res.write(eBayFPFScript);
                        }
                    }
                }
                _end.apply(res, arguments);
            };

            // Express response has the bad habit of adding a body to a
            // redirect response when the accepts headers say that html
            // is OK. This messes up our load balancer as it expects
            // redirects to end with crlf crlf and it does not when the
            // body is added. Make accepts look empty so the response.redirect
            // will not add a body
            res.redirect = function() {
                req.accepts = function() {
                    return '';
                };
                var args = [].slice.call(arguments);
                var redirectUrl = args.pop() ;
                if (!redirectUrl || !security.isValidRedirect(redirectUrl)) {
                    if(!redirectUrl) {
                        logger.error("Redirection URL cannot be empty");
                    } else {
                        process.emit('metrics-security-violation', {type: 'redirect'});
                        logger.error("Redirection rule violation. Invalid eBay domain detected:", redirectUrl);
                    }
                    redirectUrl = 'http://pages.ebay.com/messages/page_not_responding.html';
                }
                if (res.headersSent) {
                    res.end(clientRedirect(redirectUrl, req));
                    return;
                }
                args.push(redirectUrl);
                _redirect.apply(res, args);
            };

            res.send = function() {
                sendWasUsed = true;
                if (renderStartTime) {
                    cal.createTransaction('RENDER', templateName, function(err, tx) {
                        tx.duration = Date.now() - renderStartTime;
                        tx.correlationId = req.correlationId;
                        tx.addData({
                            statusCode: res.statusCode
                        });
                        tx.complete();
                    });
                }
                _send.apply(res, arguments);
            };

            // Override response methods
            res.render = function(template, data, callback) {
                renderStartTime = Date.now();
                templateName = template;

                // Perform data model or session dumping if requested and if the request is internal
                if (req.isInternalRequest) {
                    var mode = req.query && req.query._mode;
                    if (mode === 'json') {
                        res.json(data);
                        return;
                    }
                    if (mode === 'session') {
                        res.json(req.session);
                        return;
                    }
                }

                _render.apply(res, arguments);
            };

            res.json = function(data) {
                rootTxn = data && data.rootTxn || {};
                _json.apply(res, arguments);
            };

            res.jsonp = function(data) {
                rootTxn = data && data.rootTxn || {};
                _jsonp.apply(res, arguments);
            };
        }
    };
};

async function shouldRemoveEndUserContext(req) {
    // 1. Always check forceEnable first if provided
    if (forceEnableEndUserCtx === 'true' || forceEnableEndUserCtx === true) {
        return false;
    } else if (forceEnableEndUserCtx === 'false' || forceEnableEndUserCtx === false) {
        return true;
    }

    // 2. Check the feature flag using OpenFeature
    if (req.ebay && req.ebay.openfeature) {
        const openFeatureClient = req.ebay.openfeature.client;
        const remove_openfeature_enduserctx_value = await openFeatureClient.getBooleanValue('REMOVE_ENDUSERCTX_HEADER', false);
        if (remove_openfeature_enduserctx_value && remove_openfeature_enduserctx_value === true) {
            return true;
        }
    }


    // 3. Check the configRemoveEndUserCtx value
    if (configRemoveEndUserCtx === 'true' || configRemoveEndUserCtx === true) {
        return true;
    }

    return false;
}

module.exports.init = init;
module.exports.initConfig = initConfig;
module.exports.configRemoveEndUserCtx = configRemoveEndUserCtx;
