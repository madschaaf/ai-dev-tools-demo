'use strict';

const assert = require('assert');
const index = require('../index');
const { ExpirableCache } = index;

function cloneJson(data) {
    return JSON.parse(JSON.stringify(data));
}

describe(__filename, () => {
    it('should not allow empty or missing key', async () => {
        const cache = new ExpirableCache(() => Promise.resolve({
            expiry: '2060-01-13T23:59:00.000Z',
            value: 'baseValue'
        }));
        assert.strictEqual('Cache key name should not be empty or missing',
            (await cache.get().catch(err => err)).message);
    });

    it('should not allow missing expiry', async () => {
        const cache = new ExpirableCache(() => Promise.resolve({
            value: 'baseValue'
        }));
        assert.strictEqual('Cache entry should have expiry property, which is the time of token expiration',
            (await cache.get('key').catch(err => err)).message);
    });

    it('should get key', async () => {
        const expectedValue = {
            expiry: '2060-01-13T23:59:00.000Z',
            value: 'baseValue'
        };
        const cache = new ExpirableCache(() => Promise.resolve(expectedValue));
        const val = await cache.get('key');
        assert.deepStrictEqual(expectedValue, val, `Actual ${JSON.stringify(val)}`);
    });

    it('should cache the key', async () => {
        const now = Date.now;
        Date.now = () => new Date('2021-01-13T23:59:00.000Z').getTime();
        try {
            const expectedValue = {
                expiry: '2060-01-13T23:59:00.000Z',
                value: '123'
            };
            const values = [cloneJson(expectedValue)];
            const cache = new ExpirableCache(() => Promise.resolve(values.shift()));

            const key = await cache.get('key1');
            const expireHardAt = new Date(expectedValue.expiry).getTime();
            const startTime = Date.now();
            assert.deepStrictEqual({
                ...expectedValue,
                expireHardAt,
                expireAt: startTime + parseInt((expireHardAt - startTime) / 4)
            }, key);
            const key2 = await cache.get('key1');
            assert.deepStrictEqual(key, key2);
        }
        finally {
            Date.now = now;
        }
    });

    it('should fetch values for different keys', async () => {
        const expectedValue1 = {
            expiry: '2060-01-13T23:59:00.000Z',
            value: '123'
        };
        const expectedValue2 = {
            expiry: '2060-01-13T23:59:00.000Z',
            value: '123'
        };

        const now = Date.now;
        Date.now = () => new Date('2021-01-13T23:59:00.000Z').getTime();
        try {
            const values = [expectedValue1, expectedValue2].map(it => cloneJson(it));
            const cache = new ExpirableCache(() => Promise.resolve(values.shift()));

            const key = await cache.get('key1');
            const startTime = Date.now();
            assert.deepStrictEqual({
                ...expectedValue1,
                expireHardAt: new Date('2060-01-13T23:59:00.000Z').getTime(),
                expireAt: startTime + parseInt((new Date('2060-01-13T23:59:00.000Z').getTime() - startTime) / 4)
            }, key);
            const key2 = await cache.get('key1');
            assert.deepStrictEqual({
                ...expectedValue2,
                expireHardAt: new Date('2060-01-13T23:59:00.000Z').getTime(),
                expireAt: startTime + parseInt((new Date('2060-01-13T23:59:00.000Z').getTime() - startTime) / 4)
            }, key2);
        }
        finally {
            Date.now = now;
        }
    });

    it('should not produce multiple fetch calls in parallel when key is not cached yet', async () => {
        const expectedValue1 = {
            expiry: '2060-01-13T23:59:00.000Z',
            value: '123'
        };
        const values = [expectedValue1].map(it => cloneJson(it));
        const cache = new ExpirableCache(() => Promise.resolve(values.shift()));

        const [key, key1] = await Promise.all([
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key')
        ]);

        assert.strictEqual('123', key.value);
        assert.strictEqual('123', key1.value);
    });

    it('should detect soft expiration, return existing key and fetch a new one, then hard expire', async () => {
        const startTime = Date.now();
        const values = [
            new Promise((_, reject) => setTimeout(() => reject(new Error('BOOM')), 200)),
            {
                expiry: new Date(startTime + 1000).toISOString(),
                value: '123'
            },
            {
                expiry: new Date(Date.now() + 1000).toISOString(),
                value: '124'
            },
            new Promise((_, reject) => setTimeout(() => reject(new Error('BOOM')), 100)),
            {
                expiry: new Date(Date.now() + 1000).toISOString(),
                value: '125'
            }
        ].map(it => (it instanceof Promise) ? it : cloneJson(it));

        const cache = new ExpirableCache(() => Promise.resolve(values.shift()));

        (await Promise.all([
            cache.get('key').catch(err => err),
            cache.get('key').catch(err => err),
            cache.get('key').catch(err => err),
            cache.get('key').catch(err => err)
        ])).forEach(err => assert.strictEqual('BOOM', err.message));

        // new value and promises
        (await Promise.all([
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key')
        ])).forEach(val => assert.strictEqual('123', val.value));

        // still cache, but now all rerieved as values as promise has been resolved
        (await Promise.all([
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key')
        ])).forEach(val => assert.strictEqual('123', val.value));

        await new Promise(resolve => setTimeout(resolve, 760)); // wait till soft expiration

        // soft expire and fetch new value
        (await Promise.all([
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key')
        ])).forEach(val => assert.strictEqual('123', val.value));

        await new Promise(resolve => setImmediate(resolve)); // allow to fetch a new key
        (await Promise.all([
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key')
        ])).forEach(val => assert.strictEqual('124', val.value));

        await new Promise(resolve => setTimeout(resolve, 300)); // wait for hard expire
        (await Promise.all([
            cache.get('key').catch(err => err),
            cache.get('key').catch(err => err),
            cache.get('key').catch(err => err),
            cache.get('key').catch(err => err)
        ])).forEach(err => assert.strictEqual('BOOM', err.message));

        await new Promise(resolve => setTimeout(resolve, 60)); // wait for hard expire
        (await Promise.all([
            cache.get('key'),
            cache.get('key'),
            cache.get('key'),
            cache.get('key')
        ])).forEach(val => assert.strictEqual('125', val.value));
    });

    it('should detect soft expiration, return existing key, fail to fetch and then get existing key', async () => {
        const expectedValue1 = {
            expiry: new Date(Date.now() + 150).toISOString(),
            value: '123'
        };
        const expectedValue2 = {
            expiry: '2060-01-13T23:59:00.000Z',
            value: '124'
        };
        const values = [expectedValue1, new Error('BOOM'), expectedValue2].map(it => {
            if (it instanceof Error) {
                return Promise.reject(it);
            }
            return cloneJson(it);
        });
        const cache = new ExpirableCache(() => Promise.resolve(values.shift()));

        assert.strictEqual('123', (await cache.get('key')).value);
        assert.strictEqual('123', (await cache.get('key')).value);
        await new Promise(resolve => setTimeout(resolve, 100));

        assert.strictEqual('123', (await cache.get('key')).value);

        await new Promise(resolve => setTimeout(resolve, 100));
        assert.strictEqual('124', (await cache.get('key')).value);
    });

    it('should faili to fecth key from the start and try to fetch it with the next request', async () => {
        const expectedValue2 = {
            expiry: '2060-01-13T23:59:00.000Z',
            value: '124'
        };
        const values = [new Error('BOOM'), expectedValue2].map(it => {
            if (it instanceof Error) {
                return Promise.reject(it);
            }
            return cloneJson(it);
        });
        const cache = new ExpirableCache(() => Promise.resolve(values.shift()));

        const key = await cache.get('key').catch(err => err);
        assert.ok(/BOOM/.test(key.message), `Actual error: ${key}`);

        const key2 = await cache.get('key');
        assert.strictEqual('124', key2.value);
    });
});

