'use strict';

/**
 * Module dependencies.
 */


const {
        deprecate,
        promisify
    } = require('util'),
    Assert = require('assert');

var DataHolder = require('raptor-async/DataHolder'),
    debug = require('debug')('appmeta-ebay:AppMetaLoader');

var RuntimeError = require('@ebay/service-instruments-ebay/lib/errors').RuntimeError,
    logger = require('@ebay/logging-inc').getLogger('appmeta-ebay:AppMetaLoader');

var AppMeta = require('./AppMeta');

const ServiceProvider = require('./service');
const Service = Object.keys(ServiceProvider).reduce((acc, name) => {
    acc[name] = promisify(ServiceProvider[name]);
    return acc;
}, {});

var metaDataMap = {};

var memoryCache = {
    remove: function remove(key) {
        //noop
        delete metaDataMap[key];
    },
    get: function get(key) {
        return metaDataMap[key];
    },
    put: function put(key, value) {
        metaDataMap[key] = value;
    }
};

module.exports = exports = {
    load: load,
    reset: reset,
    getAppMeta: getAppMeta,
    memoryCache: memoryCache,
    getServiceMeta: deprecate(getServiceMeta, 'getServiceMeta is deprecated, please use @ebay/oauth-ebay getServiceDetails'),
    createDiskCache: createDiskCache // Export for testing...
};

reset();

function createDiskCache() {
    var nodeEnv = (process.env.NODE_ENV || 'development').toLowerCase();
    var location = `.cache/appmeta-ebay-web-${nodeEnv}`;

    debug('create disk cache: ', location);

    const serialize = AppMeta.serialize;
    const deserialize = AppMeta.deserialize;

    return require('raptor-cache').createCache({
        store: 'disk',
        dir: location,
        flushDelay: parseInt(process.env.DISK_FLASH_DELAY) || 1000, // Commit cached values to disk after 1s of no write activity
        serialize,
        deserialize
    });
}

function reset() {
    debug('Reset Cache');

    metaDataMap = {};
    exports.diskCacheWeb = createDiskCache();
}

function getAppMeta(appName, skipAppSecret, callback) {
    if (!callback && typeof skipAppSecret === 'function') {
        callback = skipAppSecret;
        skipAppSecret = false;
    }

    try {
        return load(appName, skipAppSecret, callback);
    } catch (err) {
        callback(err, null);
    }
}

function load(appName, skipAppSecret, callback) {
    if (!callback && typeof skipAppSecret === 'function') {
        callback = skipAppSecret;
        skipAppSecret = false;
    }

    Assert.ok(appName, 'appName is required');
    Assert.ok(typeof appName === 'string', 'appName should be a string');
    Assert.ok(callback, 'callback is required');
    Assert.ok(typeof callback === 'function', 'callback should be a function');

    var metaDataHolder = metaDataMap[appName];

    if (!metaDataHolder) {
        metaDataHolder = metaDataMap[appName] = new DataHolder();
        exports.diskCacheWeb.get(appName).then(appMetaData => {
            if (appMetaData) {
                metaDataHolder.resolve(appMetaData);
                return;
            }

            findMetadata();
        }).catch(err => {
            logger.error('Metadata disk cache error, will use service to get app metadata', err);
            findMetadata();
        });
    }

    function findMetadata() {
        Service.findMetadata(appName, function (err, result) {
            if (err) {
                delete metaDataMap[appName];
                logger.error(err);
                metaDataHolder.reject(new RuntimeError('Fail to find app metadata for ' + appName, err));
                return;
            }

            var rawMeta = (result && result['application.metadata.raptor.ebay.com']);
            if (!rawMeta) {
                delete metaDataMap[appName];
                const error = new RuntimeError(`Got empty metadata for ${appName}, data: ${JSON.stringify(result)}`);
                logger.error(error);
                metaDataHolder.reject(error);
                return;
            }
            const appMetaData = new AppMeta(rawMeta);
            debug('raw application metadata for ', appName, ':', rawMeta);

            /* Put the metadata into disk cache */
            exports.diskCacheWeb.put(appName, appMetaData);
            metaDataHolder.resolve(appMetaData);
        });
    }

    metaDataHolder.done(function (err, appMetaData) {
        if (err) {
            callback(err, appMetaData);
            return;
        }

        if (skipAppSecret || appMetaData._secret) {
            callback(null, appMetaData);
            return;
        }

        Service.getAppSecret(appName, function(err, secret) {
            if (!err && secret) {
                appMetaData.setAppSecret(new Buffer(secret, 'base64').toString());
            } else if (err && err.errorMessage && Array.isArray(err.errorMessage.error) && err.errorMessage.error[0].message.startsWith('Channel not found in eSAMS')) {
                appMetaData.setAppSecret(AppMeta.NO_CHANNEL_FOUND);
                logger.error(err.errorMessage.error[0].message);
            } else if (err && err.errorMessage && Array.isArray(err.errorMessage.error) && err.errorMessage.error[0].message.startsWith('Channel User (appname) not granted access to Channel in eSAMS')) {
                appMetaData.setAppSecret(AppMeta.NO_CHANNEL_ACCESS);
                logger.error(err.errorMessage.error[0].message);
            } else {
                logger.warn('Unable to fetch app secret from ESAMS', err);
            }

            callback(null, appMetaData);
        });
    });
}

function getServiceMeta(appName, options, callback) {
    throw new Error('getServiceMeta is no longer supported, please use @ebay/oauth-ebay to get service details');
}
