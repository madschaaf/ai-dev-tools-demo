'use strict';
var debug = require('debug')('@ebay/hostip-checker-ebay'),
	logger = require('@ebay/logging-inc').logger('@ebay/hostipchecker/index'),
	evironment = require('@ebay/environment-ebay'),
	authService = require('./services'),
	ipUtil = require('ip'),
	net = require('net'),
	cs = require('./constants'),
	dns = require('dns'),
	fs = require('fs'),
	path = require('path'),
	async = require('async'),
	hostipchecker,
	parser = require('./configurator');

var Qualyscan = require('./qualyscan');

const tryRequire = require('try-require');
const cacheFolder = path.resolve(process.cwd(), '.cache');

var coldCacheFilename = path.join(cacheFolder, 'hostip-checker-ebay/eBayNetworks.json'),	
	ipAuthCache = parser.parse(tryRequire(coldCacheFilename) || require('../config/eBayNetworks.json')),
	cachedTimestamp = Date.now(),
	cacheTimeout = 24 * 60 * 60 * 1000;

/**
 * Exports
 */
exports = module.exports = {
	isQualyscanIP: Qualyscan.isQualyscanIP,
	checkIp: checkIp,
	checkIpSync: checkIpSync,
	checkHost: checkHost,
	isInternalIp,
	reset: reset,
	setCacheTimeout: function (newTimeout) {
		cacheTimeout = newTimeout;
	}
};

/**
 *
 * @constructor
 */
function IPChecker (networks){
	this._networks = networks;
}

let parsedHexCached = {};
function parseHexOrCached(value) {
	let ret = parsedHexCached[value];
	if (!ret) {
		ret = parsedHexCached[value] = parseInt(value, 16);
	}
	return ret;
}

IPChecker.prototype = {
	/**
	 * Get the meta of the ip (isInternal, hasUpdate etc).
	 * @param ip
	 * @param cb
	 * @public
	 */
	ipMeta: function (ip, cb, internalIpCheck) {

		// handling IPv4-mapped IPv6 addresses - http://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses
		if (/^::ffff:(\d{1,3}\.){3,3}\d{1,3}$/.test(ip)) {
			ip = ip.replace(/^::ffff:/, '');
		}
		const ipToLong = ipUtil.toLong(ip);

		debug("ipMeta: isInternal?, hasUpdate? :", ip);
		const self = this,
			isIPv6 = net.isIPv6(ip),
			family = isIPv6 ? cs.IPV6_KEY: cs.IPV4_KEY,
			networks = self._networks && self._networks[family];
		let error;

		const hasAccessRole = function hasRole(roleName) {
			if(!networks){
				return false;
			}
			try {

				return Object.keys(networks).some(function (networkName) {
					var network = networks[networkName],
						subnet = network[cs.SUBNET_KEY],
						masks = network[cs.MASK_KEY],
						access = network[cs.ACCESS_KEY],
						mask;
					debug('ip :', ip);
					debug("subnet :", subnet);
					debug("masks :", masks);
					debug("access :", access);
					// moved it here to avoid maprsing subnets
					// if roleName is not set, then loop through all roles
					if (roleName !== 'any' && access !== roleName) {
						return false;
					}
					//Skip, if subnet or mask skip is found empty.
					if (!subnet || !masks || masks.length === 0) {
						return false;
					}
					subnet = isIPv6 ? subnet : parseHexOrCached(subnet.toUpperCase()); //Hex decimal to Number

					//Compare the ip against subnet and each mask
					return masks.some(function (maskName) {
						if (!maskName) {
							return false;
						}
						/**
						 * Perform a bitwise operation on ip and masks.
						 * If the result matches the Subnet, then its an internal IP.
						 */
						mask = isIPv6 ? maskName : parseHexOrCached(maskName); //Hex decimal to Number
						debug("mask :", mask);
						if (_ipComparator(ip, subnet, mask)) {
							return true;
						}
						return false;
					});
				});
			} catch (err) {
				debug("ERROR :", err);
				error = err;
			}
		};

		if (internalIpCheck) {
			return hasAccessRole('any');
		}

		var canUpdate = hasAccessRole('update');
		var resp = {
			isInternal: canUpdate ? true : hasAccessRole('view'),
			hasUpdate: canUpdate
		};

		if (cb) {
			return cb(error, resp);
		} else {
			return resp;
		}

		/**
		 * Compare IP with the subnet using the mask/prefix value.
		 * @return boolean
		 */
		function _ipComparator (ip, subnet, mask) {
			debug("_ipComparator:", ip, "  subnet -", subnet, " mask -", mask);
			//IPv6
			if (isIPv6) {
				return _isIpEqual(_masker(ip, mask), _masker(subnet, mask));
			}
			//IPv4
			return (subnet === (ipToLong & mask));
		}
	}
};

/**
 * The mask for IPv6 is determined from the prefix.
 * Prefix refers to the number of bits considred for calculating the network address mask in the IP.
 * @param ip - String
 * @param prefix - number
 * @return maskedAddr - Buffer - Masked Address.
 */
function _masker(ip, prefix) {
	debug("_masker : ip  -", ip,"  prefix -", prefix);
	var prefixBlock = prefix / cs.BYTE_LENGTH,
		remainBits = prefix % cs.BYTE_LENGTH,
		ipBuffer = ipUtil.toBuffer(ip),
		maskedAddr;

	if(remainBits > 0) {
		prefixBlock = prefixBlock + 1;
	}
	// Use the number prefix block to mask the IP Buffer
	maskedAddr = ipBuffer.slice(0, prefixBlock);
	debug("prefixBlock -", prefixBlock);
	debug("remainBits -", remainBits);

	if(remainBits > 0) {
		var mask = ( 0xFFFF << (cs.BYTE_LENGTH - remainBits)) & 0x00FF;
		maskedAddr[prefixBlock - 1] = maskedAddr[prefixBlock - 1] & mask;
	}
	return maskedAddr;
}

/**
 * Equal check for same IP protocols. Input can be a buffer or string format
 * @param ip1 Buffer/String
 * @param ip2 Buffer/String
 * @private
 */
function _isIpEqual(ip1, ip2) {
	ip1 = (Buffer.isBuffer(ip1)) ? ip1 : ipUtil.toBuffer(ip1);
	ip2 = (Buffer.isBuffer(ip2)) ? ip2 : ipUtil.toBuffer(ip2);

	// Same protocol
	if (ip1.length === ip2.length) {
		for (var i = 0; i < ip1.length; i++) {
			if (ip1[i] !== ip2[i]) {
				return false;
			}
		}
		return true;
	}
	return false;
}

function isInternalIp(ip) {
	if (net.isIP(ip) === 0) {
		return false;
	}
    const resp = hostipchecker.ipMeta(ip, null, true);
    refreshCache();
    return resp;
}

//Sync Version
function checkIpSync(ip) {

	var resp = {
		isInternal	: false,
		hasUpdate	: false
	};
	if (net.isIP(ip) === 0) {
		//Return false for Invalid IP.
		return resp;
	}
    resp = hostipchecker.ipMeta(ip);
    refreshCache();
    return resp;
}

//Asyn version
function checkIp(ip, cb) {
	var resp = {
		isInternal	: false,
		hasUpdate	: false
	};

	if (net.isIP(ip) === 0) {
		return cb(new Error("Invalid IP " + ip), resp);
	}

	hostipchecker.ipMeta(ip, cb);
    refreshCache();
}


function checkHost(host, cb) {

	var resp = {
		isInternal	: false,
		hasUpdate	: false
	};
	async.waterfall([
		function(callback){
			dns.resolve6(host, function (err, addresses) {
				if (err || !addresses || addresses.length === 0) {
					//Might be IPv4
					callback(null, addresses);
				} else {
					//IPv6. passing error only to skip the IPv4 check.
					callback(new Error("Found Ipv6"), addresses);
				}
			});
		},
		function(addresses, callback){
			dns.resolve4(host, function (err, addresses) {
				callback(err, addresses);
			});
		}
	], function (err, addresses) {

		if (!addresses || addresses.length === 0) {
			//Return the Default Response in case we could not find an address for the Host.
			cb && cb(null, resp);
		} else {
			//Check only one of the addresses: If one address is private/public the host is private/public.
			var address = addresses[0];
			checkIp (address, function(err, resp){
				cb && cb(err, resp);
			});
		}
	});
}

function refreshCache(callback) {
    if(Date.now() > (cachedTimestamp + cacheTimeout)) {
        logger.info('Cache Expired, fetching latest IP list');
        var tempCachedTimestamp = cachedTimestamp;
        cachedTimestamp = Date.now();
        authService.loadAuthIP(function(error, response){
            if(error) {
                //if service errors out retry after 5 mins, advance timestamp to 5 mins
                cachedTimestamp = tempCachedTimestamp + (5*60*1000);
            } else {
                createColdCache(JSON.stringify(response), coldCacheFilename);
                //Parse the JSON Object loaded from Cold Cache or from service
                ipAuthCache = parser.parse(response);
                reset();
            }
        });
  }
}

function createColdCache(content, fileName) {
  var tempFileName = fileName + Math.floor(Math.random()*10000);
  fs.mkdir(path.dirname(fileName), {recursive: true}, () => {
	fs.writeFile(tempFileName, content, function(writeError){
        if(!writeError) {
          fs.rename(tempFileName, fileName, function(renameError){
            if(renameError) {
              logger.error('Error Renaming Temp Cold cache file', renameError);
            }
          });
        } else {
          logger.error('Error Writing Temp Cold cache file', writeError);
        }
      });
  });
}

function reset() {
  var env = process.env.NODE_ENV || 'production';
  if (evironment.isProd()) {
      env = 'production';
  }

  var authCacheEntry = ipAuthCache[env] || ipAuthCache.production;
  hostipchecker = new IPChecker(authCacheEntry[cs.NETWORKS_KEY]);
  parsedHexCached = {};
  return true;
}

reset();
