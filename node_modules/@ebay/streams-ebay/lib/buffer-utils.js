'use strict';

/**

UTF-8 encoding only

1. If c & 0xC0 < 0x80, then it's a single-byte character.

2. If c & 0xC0 == 0xC0, then it's the start of a multi-byte character.
You can figure out its length by looking at the other bits.

3. If c & 0xC0 == 0x80, then it's part of a multi-byte character.
Backtrack until you find a byte that satisfies criterion 2 (but don't
backtrack more than three bytes.)
*/

/**

int getUTF8SequenceLength (unsigned char firstPoint) {
    firstPoint >>= 4;
    firstPoint &= 7;
    if (firstPoint == 4) return 2;
    return firstPoint - 3;
}
This returns the total length of the sequence, including the first byte. I'm using an unsigned char value as the firstPoint parameter here for clarity, but note this function will work exactly the same way if the parameter is a signed char.

To explain:

UTF-8 uses bits 5, 6, and 7 in the first byte of a sequence to indicate the remaining length. If all three are set, the sequence is 3 additional bytes. If only the first of these from the left (the 7th bit) is set, the sequence is 1 additional byte. If the first two from the left are set, the sequence is 2 additional bytes. Hence, we want to examine these three bits (the value here is just an example):

 11110111
  ^^^
The value is shifted down by 4 then AND'd with 7. This leaves only the 1st, 2nd, and 3rd bits from the right as the only possible ones set. The value of these bits are 1, 2, and 4 respectively.

00000111
     ^^^ 
If the value is now 4, we know only the first bit from the left (of the three we are considering) is set and can return 2.

After this, the value is either 7, meaning all three bits are set, so the sequence is 4 bytes in total, or 6, meaning the first two from the left are set so the sequence is 3 bytes in total.

 */

module.exports = {
    /**
     * Return the valid length of the buffer minus incomplete sequence
     * @param {*} buf 
     * @returns 
     */
    getValidUtf8Length(buf) {
        const len = buf.length;
        let limit = Math.min(buf.length, 3);
        let count = 1;
        while (count <= limit) {
            const c = buf[buf.length - count];
            if ((c & 0xC0) < 0x80) {
                // single character or start of multi-byte
                break; // good char or invalid sequence that we ignore (should not be the case)
            }
            // catch start of the multi-byte sequence
            // then compare the length with count
            if ((c & 0xC0) === 0xC0) {
                const meta = c && 0x70;
                const expectedLen = meta === 0x40 && 2 || 3;
                if (expectedLen === count) {
                    return len;
                }
                return len - count;
            }
            count++;
        }
        return len;
    }
};
