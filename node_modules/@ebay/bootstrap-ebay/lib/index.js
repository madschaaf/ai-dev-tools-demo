'use strict';

// ========================================================================//
// ====== this code should be the first to execute before any require =====//
// this function should not be replaced with 3rd party, as we do not want to load anything before this.
const Path = require('path');
function bootstrap(options) {
    // loading bootstrap info from config files
    const pkg = require('../package.json');
    const localBootstrap = pkg.bootstrap || {};
    // load consumer bootstrap file, example: brogan-ebay or service-ebay
    const consumerBootstrap = options && options.consumerBaseDir &&
        require(Path.resolve(options.consumerBaseDir, 'package.json')).bootstrap || {};
    Object.assign(localBootstrap, consumerBootstrap);

    // load application bootstrap file if any
    const appBootstrap = require(Path.resolve(process.cwd(), 'package.json')).bootstrap || {};
    const modules = Object.assign(localBootstrap, appBootstrap);
    const cachedModules = {};
    const mapToModules = {};
    const cachedResolves = {};

    const m = require('module');
    m._load = (original => function (name, _, ...rest) {
        if (!cachedModules[name] && modules[name] === true) {
            cachedModules[name] = original.call(m, name, module, ...rest);
        }
        if (mapToModules[name]) {
            return mapToModules[name];
        }

        return cachedModules[name] || original.apply(m, arguments);
    })(m._load);

    m._resolveFilename = (function overrideResolveFactory(original) {
        return function (name, parent, ...rest) {
            if (!cachedResolves[name] && modules[name] === true) {
                cachedResolves[name] = original.call(m, name, module, ...rest);
            }

            return cachedResolves[name] || original.apply(m, arguments);
        };
    }(m._resolveFilename));

    const bootstrapped = [];
    Object.keys(modules).forEach(name => {
        const val = modules[name];
        if (typeof val === 'string') {
            // overriding the module
            mapToModules[name] = require(val);
            modules[name] = true;
            bootstrapped.push(`${name} -> ${val}`);
            require(name);
        }
        if (modules[name] === true) {
            bootstrapped.push(name);
            require(name);
        }
    });
    if (options.validate === true) {
        validateResolution(bootstrapped);
    }
    // eslint-disable-next-line no-console
    console.info(`bootstrapping modules:\n\t${bootstrapped.join('\n\t')}`);
    return bootstrapped;
}

let initDone = false;
function init(options = {}) {
    if (initDone) {
        throw new Error('@ebay/bootstrap-ebay init can be done only once');
    }
    initDone = true;
    let bootstrapModules;
    try {
        bootstrapModules = bootstrap(options);
    }
    catch (e) {
        console.error('Bootstrap process failed with error, Please Perform latest SWU to fix the error: ', e);
    }
    // === the code above should be the first to execute before any require ===//
    // ========================================================================//

    // this should be the first to load
    require('request-local');
    require('./body-parser-patch');

    setHeaderLimits();

    // prevent any exposure of internals via JSON
    require('domain').Domain.prototype.toJSON = () => undefined;

    const dnsOptions = options.dnscache || {};
    const dnscache = require('dnscache');
    dnscache({
        enable: dnsOptions.enable !== undefined ? dnsOptions.enable : true,
        ttl: dnsOptions.ttl || 300,
        cachesize: dnsOptions.cachesize || 1000
    });

    return {
        bootstrapModules
    };
}

let logger;
let headerLimitsSet = false;
function setHeaderLimits() {
    if (headerLimitsSet) {
        return;
    }
    headerLimitsSet = true;
    logger = require('@ebay/logging-inc').logger('bootstrap-ebay');

    const { BootstrapConfig } = require('./config');
    // trigger config load
    BootstrapConfig.getConfig();
    const { OutgoingMessage } = require('http');

    const validate = (header) => {
        // read config here in case we need to get updated config values
        const maxHeaderSize = BootstrapConfig.getMaxHeaderSize();
        const errorHeaderSize = BootstrapConfig.getErrorHeaderSize();
        const warnHeaderSize = BootstrapConfig.getWarnHeaderSize();
        const headerLength = header && header.length || 0;

        // Parse headers once if we need to log anything
        const shouldLog = headerLength >= warnHeaderSize ||
            (logger._loglevels.debug && headerLength > 0);

        const headerSizeBreakdown = {};
        if (shouldLog) {
            header && header.split('\r\n').forEach(h => {
                const index = h.indexOf(':');
                if (index > 0) {
                    const key = h.substring(0, index);
                    headerSizeBreakdown[key] = (headerSizeBreakdown[key] || 0) + h.length + 2; // +2 for \r\n
                }
            });
        }

        if (headerLength >= maxHeaderSize) {
            logger.error(`The total size of headers exceeds the limit of ${
                maxHeaderSize} bytes, the actual size is ${
                headerLength} bytes. Headers size breakdown: ${JSON.stringify(headerSizeBreakdown)}`,
            new Error(`Header size overflow`));
        }
        else if (headerLength >= errorHeaderSize) {
            const errorMessage = `The total size of headers is about to overflow the limit of ${
                maxHeaderSize} bytes, the actual size is ${
                headerLength} bytes, to temporary eliminate the error, ` +
                `please increase error-size limit in VI bootstrap config bean. Headers size breakdown: ${
                    JSON.stringify(headerSizeBreakdown)}`;

            logger.error(errorMessage, new Error(`Header size may overflow`));
        }
        else if (headerLength >= warnHeaderSize) {
            logger.warn(`The total headers size of ${
                headerLength} bytes is too big and may overflow the limit of ${
                maxHeaderSize} bytes in future. Headers size breakdown: ${JSON.stringify(headerSizeBreakdown)}`,
            new Error(`Header size is too big`));
        }
        else if (logger._loglevels.debug && headerLength > 0) {
            logger.debug(`Header size check passed: ${headerLength} bytes (limit: ${
                maxHeaderSize}). Headers size breakdown: ${JSON.stringify(headerSizeBreakdown)}`);
        }
    };

    const _send = OutgoingMessage.prototype._send;
    /**
     * Intercept headers to validate platform limits for outgoing requests/messages
     */
    OutgoingMessage.prototype._send = function _sendOverride(...args) {
        !this._headerSent && validate(this._header);
        return _send.call(this, ...args);
    };
}

function validateResolution(bootstrapped) {
    const fs = require('fs');
    try {
        // Read the package.json file
        const packagePath = Path.resolve(process.cwd(), 'package.json');
        const packageJson = fs.readFileSync(packagePath, 'utf8');
        const packageData = JSON.parse(packageJson);

        // Check if "resolution" section exists
        if (packageData && packageData.resolutions) {
            const resolutions = packageData.resolutions;
            // Check if each bootstrapped module is present in resolutions in the correct format
            const missingModules = bootstrapped.filter(module => !resolutions[`**/${module}`]);
            if (missingModules.length > 0) {
                console.error('Validation failed. The following modules are missing from resolutions:');
                missingModules.forEach(module => {
                    console.error(`- ${module}`);
                });
                console.error('Please perform SWU to fix the error.');
                process.exit(1); // Exit with a non-zero status code to indicate failure
            }
            else {
                // eslint-disable-next-line no-console
                console.info('All modules are present in resolutions.');
            }
        }
        else {
            console.error('"Resolutions" module section not found in package.json. Please perform SWU.');
            process.exit(1); // Exit with a non-zero status code to indicate failure
        }
    }
    catch (error) {
        console.error('An error occurred:', error.message);
        process.exit(1); // Exit with a non-zero status code to indicate failure
    }
}

module.exports = {
    init,
    setHeaderLimits,
    getLogger() {
        return logger;
    },
    bootstrap,
    validateResolution
};
