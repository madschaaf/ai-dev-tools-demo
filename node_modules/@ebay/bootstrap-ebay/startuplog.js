/* eslint-disable no-console */
const _log = console.log, _error = console.error, _warn = console.warn, _info = console.info, _trace = console.trace;
const fs = require('fs');
const path = require('path');

function patchUp() {
    // Skip for Dev & Test
    if (!process.env.DEPLOY_ENV || /^dev/.test(process.env.DEPLOY_ENV) || /test/.test(process.env.DEPLOY_ENV)) {
        return;
    }

    const logsDir = path.join(process.cwd(), 'logs');
    if (!fs.existsSync(logsDir)) {
        fs.mkdirSync(logsDir);
    }
    const pm2id = process.env.pm_id ? `-${process.env.pm_id}` : '';
    const startupLogPath = path.join(logsDir, `startup${pm2id}.log`);
    const logWriter = fs.createWriteStream(startupLogPath);

    process.once('vistart', () => {
        console.log('Stopping Startup logs.');
        console.log = _log;
        console.error = _error;
        console.warn = _warn;
        console.info = _info;
        console.trace = _trace;
        logWriter.end();
    });

    function interceptAndLog(original) {
        return function () {
            logWriter.write([...arguments, '\n'].join(' ').toString());
            original.apply(console, arguments);
        };
    }

    console.log = (function (original) {
        return interceptAndLog(original);
    }(console.log));

    console.error = (function (original) {
        return interceptAndLog(original);
    }(console.error));

    console.warn = (function (original) {
        return interceptAndLog(original);
    }(console.warn));

    console.info = (function (original) {
        return interceptAndLog(original);
    }(console.info));

    console.trace = (function (original) {
        return interceptAndLog(original);
    }(console.trace));

    console.log('Starting Startup logs.');
}

module.exports = patchUp;
