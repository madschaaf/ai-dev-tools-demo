'use strict';

// Helper functions to gather metrics data
//========================================

var fs = require('fs'),
    os = require('os'),
    path = require('path'),
    utils = require('./utils'),
    Hoek = require('hoek'),
    errors = require('@ebay/errors-ebay'),
    ooms = require('@ebay/errors-ebay').getOomLog(),
    MAX_HEAP = require('@ebay/errors-ebay').getMaxHeap(),
    maxFileDescriptors;

const Cpu = require('../lib/cpu');

// Collect memory statistics
module.exports.updateMemory = function updateMemory(stats) {
    var mem = process.memoryUsage();
    stats.rss = Math.round(mem.rss / 1e3); //Kbytes
    stats.heap_used = Math.round(mem.heapUsed / 1e3); //Kbytes
    stats.heap_max = Math.round(mem.heapTotal / 1e3); //Kbytes
};


// Get cpu usage, finalize GC overhead based on total CPU vs % GC used
module.exports.finalUpdateStats = function finalUpdateStats(stats, durationSeconds, callback) {

    const result = process.env.REPORT_SYSTEM_CPU ? Cpu.system() : Cpu.usage();

    var cpusec = 0,
        cpuMsec = 0,
        gcOverhead = 0;

    // In durationSeconds clock time, we have used result.cpu % in active CPU work.
    // Compute how many seconds that percentage amounts to.
    cpusec = durationSeconds * (result.usagePercentile / 100);
    cpuMsec = cpusec * 1000;

    // stat.gcInterval holds total msec spent in GC work. Compute GC % of CPU used
    if (stats.gcInterval !== 0 && cpuMsec !== 0) {
        gcOverhead = stats.gcInterval / cpuMsec;
    }
    stats.gcInterval = gcOverhead;
    stats.cpu = result.usagePercentile;

    callback(null, stats);
};

module.exports.updateFileDescriptorCount = function updateFileDescriptorCount(stats) {
    var procPath = '/proc/' + process.pid + '/fd',
        openFdCount;

    try {
        openFdCount = fs.readdirSync(procPath).length;
    } catch (e) {
        openFdCount = 0; // Cannot determine it. Maybe no procfs as on OSX
    }
    stats.availableFileDescriptors = maxFileDescriptors - openFdCount;
};


// Run once at start to get max file descriptors for the process.
module.exports.determineMaxFileDescriptors = function determineMaxFileDescriptors(callback) {
    if (os.platform() === 'win32') {
        callback(null, 0);
    }
    var exec = require('child_process').exec;

    exec('ulimit -n',
        function (error, stdout) {
            var fdMax = parseInt(stdout, 10);
            if (error !== null) {
                console.error(genLogMsg('Cannot determine max file descriptors ' + error));
                callback(error, 0);
            } else {
                maxFileDescriptors = fdMax;
                callback(null, fdMax);
                return;
            }
        });
};

// Check if too little memory left to keep handling requests. If so,
// close server to gracefully finish outstanding ones.
// Note that this is also checked on the non-request path so req may not be available.
module.exports.checkHeapFull = function checkHeapFull(req, intervalId) {
    var mem = process.memoryUsage();

    if (mem.heapUsed > MAX_HEAP) {
        console.error(genLogMsg('Exiting node process as memory usage > 1.2GB ' + mem.heapUsed));
        clearInterval(intervalId);
        // TODO Can this be done by emit of a shutdown event?
        if (req) {
            var server = req.socket.server;
            server.close();
        }
        // For security reasons, only dump if a special option is on for the
        // run. Arbitrary data in app memory could expose all sorts of
        // PII data otherwise.

        // Commenting this code since no one is currently using this feature
        // of taking heap dump when OOM happens
        // if (process.env.NODE_HEAPDUMP_OPTIONS === 'dump') {
        //     var heapdump = require('heapdump');
        //     var heapdumpPath = process.cwd() + '/logs/' + Date.now() + '.heapsnapshot';
        //     heapdump.writeSnapshot(heapdumpPath);
        // }

        reportOutOfMemoryError(function onEmailSent() {
            shutdown();
        });

    }
};

function shutdown(force) {
    if (!force && process.send) {
        process.emit('SIGTERM');
        setTimeout(function () {
            shutdown(true);
        }, 40000).unref();
    } else {
        process.exit(1);
    }
}

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getYear() % 100, d.getMonth() + 1, d.getDate() ].join('-') + ':' + time;
}

function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

function genLogMsg (msg) {
    return timestamp() + ' ' + msg;
}

module.exports.genLogMsg = genLogMsg;

// At startup, used to get last known Out of Memory (OOM) error count.
// Returns current count of such errors.
function initOutOfMemoryError() {
    return ooms.getOom();
}

// Used to report an Out Of Memory (OOM) error
function reportOutOfMemoryError(callback) {
    var Restart = errors.getRestartLog();
    var cb = Hoek.once(callback);
    //Start Timer for auto shutdown
    setTimeout(function(){
        cb();
    }, 5000).unref();

    ooms.incOom();

    //Send Email for Out Of Memory
    var emailBody = utils.buildEmailBody();
    Restart.setReason(emailBody)
           .sendEmail({subject: 'Out of Memory on '})
           .execute(function(err, info){
                cb();
           });

}

module.exports.initOutOfMemoryError = initOutOfMemoryError;
