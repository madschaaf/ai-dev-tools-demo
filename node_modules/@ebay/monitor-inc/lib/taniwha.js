'use strict';
const { PerformanceObserver, constants } = require('perf_hooks');

var tooBusy = require('toobusy-js'),    
    async = require('async'),
    util = require('util'),
    utils = require('./utils'),
    express = require('express'),
    deepcopy = require('deepcopy'),
    deployEnv = require('@ebay/environment-ebay'),
    tryRequire = require('try-require'),
    Cluster = require('cluster'),
    cal = require('@ebay/cal'),
    appContext = require('@ebay/app-context-ebay'),
    EventEmitter = require('events').EventEmitter,
    getId = require('@ebay/instance-detect-ebay').getInstanceId,

    // Supporting functions
    setupOptions = require('./setupOptions').setupOptions,
    restarts = require('./restarts'),
    reportFunctions = require('./reportFunctions'),
    updateMemory = reportFunctions.updateMemory,
    finalUpdateStats = reportFunctions.finalUpdateStats,
    checkHeapFull = reportFunctions.checkHeapFull,
    genLogMsg = reportFunctions.genLogMsg,
    initOutOfMemoryError = reportFunctions.initOutOfMemoryError,
    updateFileDescriptorCount = reportFunctions.updateFileDescriptorCount,
    metric = require('./metrics'),
    tooBusyHandler,
    maxOpenRequests = 0;

var isRunning = false,
    stats = {},
    prevStats, // stats from previous 60 second cycle so stats can be reset
    intervalId,
    theEmitter,
    theOptions,
    gotFirstRequest,
    duration, // time from last stats flush to now
    shutdownRequested = false,
    obs,
    requestsInProcess = 0,
    // when we crash or shutdown for certain reasons we log to restarts_i.log a json object with the count and reason.
    // on recovery, we load this file and send an email based on the reason and the count, then clear out the file.
    // this preserves the last reason so that we can push it to CAL on the first metric heartbeat
    restartReason = null;


// Starts monitoring processes (interval to report metrics)
function start(options, emitter) {

    theEmitter = emitter;
    theOptions = options;

    if ('darwin' !== process.platform) {
        obs = new PerformanceObserver(list => {
        const entry = list.getEntries()[0];     
        if(entry.entryType === 'gc') {
            if(entry.detail.kind === constants.NODE_PERFORMANCE_GC_MINOR) {
                stats.gc_count_incremental++;
            } else {
                stats.gc_count++;
            }
            
            stats.gcInterval += entry.duration;
            const memory = process.memoryUsage();
            stats.heapSizePostGC = Math.round(memory.heapUsed / 1e3);
        }

      });
      // Subscribe to notifications of GCs
      obs.observe({ entryTypes: ['gc'] });
    }

    stats.gc_count = 0;
    stats.gc_count_incremental = 0;
    stats.gcInterval = 0;
    stats.errorCount = 0;

    stats.heapSizePostGC = 0; // make sure the property exists

    process.on('cal-event-args', function(calEvent){
        if(calEvent.type === 'Error' ||
            calEvent.type === 'Fatal') {
            metric.errorCount++;
        }
    });

    process.on('metrics-security-violation', function(event){
        if(event.type) {
            metric[event.type]++;
        }
    });

    var metricsTimer = function () {
        if (shutdownRequested) {
            clearInterval(intervalId);
            return;
        }
        // CAL client has problems when starting up. If we push a message before the config is loaded, it will be dropped and lost
        // we use the poolname being set as an indicator that the config has been loaded and our message should make it through
        if (restartReason !== null && cal.defaults.poolname !== undefined) {
            cal.createEvent('Fatal', 'Watchdog_Restart', cal.Status.FATAL, utils.buildCalData(stats.restarts, restartReason)).complete();
            restartReason = null;
        }
        checkHeapFull(null, intervalId);
        // Reset stats to collect for the next interval. Preserve the
        // stats accumulated in the prior interval and send.
        prevStats = preserveStats(deepcopy(stats));
        resetStats();
    };

    // Establish setInterval to collect stats every n seconds
    intervalId = setInterval(metricsTimer, options.interval);
    intervalId.unref(); // Make sure our interval does not keep node from exiting

    //Send Metrics on startup
    //metricsTimer();

    process.on('SIGTERM', function () {
        gracefulShutdown('TERM');
    });
    process.on('SIGINT', function () {
        gracefulShutdown('INT');
    });
    process.on('SIGQUIT', function () {
        gracefulShutdown('QUIT');
    });

    return;
}

var shutdownRequestCount = 0;
function gracefulShutdown(why) {
    // to prevent crashing from other errors when we already existing
    shutdownRequested = true;
    obs && obs.disconnect();
    clearInterval(intervalId);
    // if it is not cluster-pm2 mode, i.e. dev environment, then control exit
    // or when kraken is not yet engaged which happens after first request
    if (deployEnv.isDev() || !gotFirstRequest || Cluster.isMaster && shutdownRequestCount++ > 1) {
        process.exit(1); // Make sure we stop running after KILL/TERM
    }
}

// Preserve all the statistics when the interval fires so new counts can start.
function preserveStats(stats) {
    var nowTime = Date.now();
    var durationSeconds = (nowTime - duration) / 1000; // time since last metrics dump
    stats.eventLoop = tooBusy.lag();
    updateMemory(stats);
    updateFileDescriptorCount(stats);
    stats.maxConcurrentRequests = metric.maxConcurrentRequests;
    stats.urlTime = sanitize(metric.urltime.toJSON().median);
    // EPS is not error per second as it is reported to sherlock (eps) and CAL (errorCount)
    // every minutes, the metrics engines calculate average by themselves
    stats.eps = sanitize(metric.errorCount / durationSeconds);
    stats.errorCount = sanitize(metric.errorCount);
    stats.http2XX = sanitize(metric.http2XX);
    stats.http3XX = sanitize(metric.http3XX);
    stats.http4XX = sanitize(metric.http4XX);
    stats.http5XX = sanitize(metric.http5XX);
    stats.renderTime = sanitize(metric.renderTime.toJSON().median);
    stats.maxCookieSize = sanitize(metric.cookielen.toJSON().max);
    stats.requestBodySize = sanitize(metric.requestBody.toJSON().median);
    stats.sessionSize = sanitize(metric.sessionSize);
    stats.tps = sanitize(metric.requestsReceived / durationSeconds);
    stats.oomError = metric.oomError || 0;
    stats.restarts = metric.restarts || 0;
    //Security Metrics
    stats.csrf = metric.csrf || 0;
    stats.redirect = metric.redirect || 0;
    stats.csp = metric.csp || 0;
    stats.xss = metric.xss || 0;

    duration = nowTime; // reset duration clock
    stats.uptime = Math.round(process.uptime());
    // Get CPU Usage async and finish up with emitStatistics callback
    finalUpdateStats(stats, durationSeconds, emitStatistics);
    return stats;

    // Callback function to handle final emission of statistics
    function emitStatistics(error, stats) {
      if (error) {
        console.log(genLogMsg("ERROR finalizing statistics: " + error));
        return;
      }

      // Send stats to anyone interested in them but don't send metrics if no endpoint
      // propagate event via process to break circular dependency https://jirap.corp.ebay.com/browse/NODE-3322
      process.emit('monitorStats', stats);
      if (theEmitter !== process && theEmitter.listeners('monitorStats').length > 0) {
        // emit legacy way to the listeners that still need to be migrated
        theEmitter.emit('monitorStats', stats);
    }
  }
}

// Reset the statistics that are per reporting interval
function resetStats() {
    stats.gc_count = 0;
    stats.gc_count_incremental = 0;
    stats.gcInterval = 0,
    metric.maxConcurrentRequests = 0;
    metric.urltime.reset();
    metric.errorCount = 0;
    metric.http2XX = 0;
    metric.http3XX = 0;
    metric.http4XX = 0;
    metric.http5XX = 0;
    metric.renderTime.reset();
    metric.cookielen.reset();
    metric.requestBody.reset();
    metric.sessionSize = 0;
    metric.requestsReceived = 0;
    metric.csrf = 0;
    metric.redirect = 0;
    metric.csp = 0;
    metric.xss = 0;
}

function sanitize(num) {
    return +num || 0;
}

// Define Monitor to provide event emitting.
// monitorStats is the primary event emitted and has the collected metrics
// for the current interval
class Monitor extends EventEmitter {
    constructor() {
        super();
        this.init = setup.bind(this);
        this.testTooBusyHandler = testTooBusyHandler.bind(this);    
    }

    on(...args) {
        onDeprecated();
        return super.on(...args);
    }

    once(...args) {
        onceDeprecated();
        return super.on(...args);
    }

    reset() {
        isRunning = false;
        clearInterval(intervalId);
        intervalId = undefined;
    }
}

// Only needed for tests to trigger tooBusy event and test loading handler
function testTooBusyHandler(maxOpen, rip, handler, mockTooBusy) {
    maxOpenRequests = maxOpen;
    requestsInProcess = rip;
    tooBusyHandler = handler || tooBusyHandler;
    tooBusy = mockTooBusy || tooBusy;
}

const onDeprecated = util.deprecate(() => {}, `Monitor.on('monitorStats) is deprecated use process.on('monitorStats') or upgrade to the new version of the module that does this`);
const onceDeprecated = util.deprecate(() => {}, `Monitor.once('monitorStats) is deprecated use process.once('monitorStats') or upgrade to the new version of the module that does this`);

// Configuration would normally be set by config but options is offered
// for testing
function setup(options) {
    /*jshint validthis:true */
    var self = this;
    var app = express();
    options = options || {};

    if (options.reportSystemCPU) {
        process.env.REPORT_SYSTEM_CPU = true;
    }

    // Don't do anything in dev mode
    if (deployEnv.isDev()) {
        return noop;
    }

    // Don't start monitoring interval timer twice.
    if (!isRunning) {
        isRunning = true;
        // TODO: clean up really bad logic here
        // currently options are passed to one method when they are empty
        // but due to being a reference, the options get assigned data later by setOptions
        var setOptions = setupOptions.bind(self, options);
        tooBusyHandler = options.tooBusyHandler;
        maxOpenRequests = options.maxOpenRequests;
        metric.oomError = initOutOfMemoryError();
        options.metricsId = getId();
        var clChk = restarts.getRestarts.bind(self, options);
        //var resetRestarts = restarts.resetRestarts.bind(self, options);
        // Obtain a metricsId for reporting node instances if we are clustered
        async.series([
            setOptions,
            clChk
        ],
        // results callback
            function (err, results) {
                if (err) {
                    console.error(genLogMsg("Can't start monitor-inc middleware. " + err.message));
                    return; // Don't start monitoring if something bad happened.
                }

                if (results[0]) {
                    options = results[0];
                }
                if (results[1]) {
                    stats.noWorkers = results[1].noWorkers;
                    stats.restarts = results[1].restarts || 0;
                    restartReason = results[1].reason || null;
                }

                // Start the repeating interval for sending collected metrics
                duration = Date.now();
                intervalId = start(options, self);
            });

    }

    // Cost/req < 1 microsec for tooBusy check
    // Don't send tooBusy to ECV/admin requests or LB may mark us down.
    app.use(tooBusyMiddleware);
    // Middleware so we can report metrics associated with a request.
    app.use(function taniwha(req, res, next) {
        if (deployEnv.isDev()) {
            return next();
        }

        gotFirstRequest = true;

        var  _renderOrig;
        var isReqFinished = false;

        // Check if heap is too full and we need to exit
        checkHeapFull(req, intervalId);

        // Consider replacing this with making wherever we log CAL RENDER add
        // res.renderTime to the res object where we can pick it rather than
        // do the work twice.
        _renderOrig = res.render;
        res.render = function () {
            var start = Date.now();
            _renderOrig.apply(res, arguments);
            metric.renderTime.update(Date.now() - start);
        };

        // Establish request start time for URL timing. Increment # of requests in process.
        // Bump meter for requests/second.
        res.startingTime = Date.now();
        metric.requestsReceived += 1;
        requestsInProcess += 1;

        // Get size of cookie and body
        if (req.headers.cookie) {
            metric.cookielen.update(req.headers.cookie.length);
        }
        var bodysize = req.headers['content-length'];
        if (bodysize) {
            metric.requestBody.update(parseInt(bodysize, 10));
        }

        // When response is done, collect session size, decrement # of requests in process.
        // Stop URL timing and report time to run URL.
        res.once('finish', finishResponse);
        res.once('close', finishResponse);
        res.once('error', finishResponse);

        // Update max # of requests in process at one time
        metric.maxConcurrentRequests = Math.max(metric.maxConcurrentRequests, requestsInProcess);

        next();

        // Determine urltime, count response type and decrement requests in process
        function finishResponse () {
            if (isReqFinished) {
                return; // Run this only once per request
            }
            isReqFinished = true;

            if (req.session) {
                var sessSize = JSON.stringify(req.session).length;
                metric.sessionSize = Math.max(metric.sessionSize, sessSize);
            }
            metric.urltime.update(Date.now() - res.startingTime);
            if (res.statusCode >= 200 && res.statusCode <= 299) {
                metric.http2XX += 1;
            } else if (res.statusCode >= 300 && res.statusCode <= 399) {
                metric.http3XX += 1;
            } else if (res.statusCode >= 400 && res.statusCode <= 499) {
                metric.errorCount += 1;
                metric.http4XX += 1;
            } else if (res.statusCode >= 500 && res.statusCode <= 599) {
                metric.errorCount += 1;
                metric.http5XX += 1;
            }
            requestsInProcess -= 1;

            return;
        }
    });

    return app;

}


// If the user has a tooBusyHandler, call it. If not, just return and accept
// the tooBusy condition and live with it.
function tooBusyMiddleware(req, res, next) {
    var handler;
    var adminCmd = req.url && req.url.indexOf('/admin/v3console') === 0;
    if (adminCmd || !tooBusyHandler) {
        return next();
    }

    // If event loop taking too long send an HTTP 503 response
    // to exert backpressure.
    // On startup, tooBusy reports a large event loop time causing a
    // false rejected request. This is annoying when in dev mode so
    // fudge things to avoid denying first reauest by making sure
    // we are actually taking traffic, e.g more than two requests
    // running at once. If we have less than this, it seems unlikely
    // a tooBusy condition would exist  so this saves the call to
    // check at low traffic loads.
    if (requestsInProcess > 2 && tooBusy() ||
    // If too many requests in flight, send an HTTP 503
    // response to exert backpressure.
            maxOpenRequests && requestsInProcess > maxOpenRequests) {

        metric.errorCount += 1;
        tooBusyHandler = typeof tooBusyHandler === 'function' ?
            tooBusyHandler :
            tryRequire(tooBusyHandler);

        if (tooBusyHandler) {
            return tooBusyHandler(req, res, next);
        }
    }

    next();
}

// When we need to do nothing in middleware chain, dev environment
var noop = function noop(req, res, next) {
        return next();
};

//Default Handler for tooBusy
var defaultTooBusyHandler = function defaultTooBusyHandler(req, res, next) {
    cal.createEvent('Error', 'Error_TooBusy', 1, 'Server Too Busy to Handle Request, shedding load').complete();
    if(appContext.type === 'service') {
        res.send(503);
    } else {
        // Express response has the bad habit of adding a body to a
        // redirect response when the accepts headers say that html
        // is OK. This messes up our load balancer as it expects
        // redirects to end with crlf crlf and it does not when the
        // body is added. Make accepts look empty so the response.redirect
        // will not add a body
        req.accepts = function() {
            return '';
        };
        res.redirect("http://pages.ebay.com/messages/page_not_responding.html");
    }

};
if (deployEnv.isDev()) {
    process.on('SIGINT', function () {
        process.exit();
    });
}


module.exports = new Monitor();
