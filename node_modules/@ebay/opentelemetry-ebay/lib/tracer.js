'use strict';
const opentelemetry = require('@opentelemetry/api');
const { registerInstrumentations } = require('@opentelemetry/instrumentation');
const { NodeTracerProvider, ParentBasedSampler, TraceIdRatioBasedSampler } = require('@opentelemetry/sdk-trace-node');
const { BatchSpanProcessor, ConsoleSpanExporter, SimpleSpanProcessor } = require('@opentelemetry/sdk-trace-base');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');
const { CollectorTraceExporter } = require('@opentelemetry/exporter-collector-grpc');
const { Resource } = require('@opentelemetry/resources');

const cal = require('@ebay/cal');

const grpc = require('@grpc/grpc-js');
const modConfig = require('@ebay/module-config-inc');
const appContext = require('@ebay/app-context-ebay');
const path = require('path');
const pkg = require('try-require')(path.resolve(process.cwd(), 'package.json'));
const name = pkg.name || 'tracer';
const version = pkg.version || '1.0.0';
const { getTracingEndpoint } = require('./endpoint');
// to access manifest version
const tryRequire = require('try-require');
const manifest = tryRequire(path.join(process.cwd(), 'manifest.json'));
const componentStatus = require('@ebay/validate-internals-ebay');
const _ = require('underscore');

const stateMap = {
    [grpc.connectivityState.CONNECTING]: 'CONNECTING',
    [grpc.connectivityState.READY]: 'READY',
    [grpc.connectivityState.TRANSIENT_FAILURE]: 'TRANSIENT_FAILURE',
    [grpc.connectivityState.IDLE]: 'IDLE',
    [grpc.connectivityState.SHUTDOWN]: 'SHUTDOWN'
};

function createComponentStatus(status) {
    const statusInformation = {
        'Status': status
    };
    componentStatus.register('OTEL-collector-connection-status', () => ({
        name: 'OTEL-collector-connection-status',
        alias: 'OTEL-collector-connection-status',
        status: 'created',
        properties: _.map(statusInformation, (val, key) => ({
            'name': key,
            'value': val
        }))
    }));
}

function tryParse(data) {
    try {
        return JSON.parse(data);
    }
    catch (e) {
        // skip
    }
}
const none = () => {};
const logger = {
    debug: none,
    info: none,
    warn: none,
    error: msg => {
        if (typeof msg === 'string') {
            msg = tryParse(msg) || new Error(msg);
        }
        reportWarning(msg);
    },
    verbose: none
};

function reportError(err) {
    cal.createEvent('Error', 'OTEL', err.code || -1, err.stack).complete();
}

function reportWarning(warn) {
    cal.createEvent('Warn', 'OTEL', warn.code || -1, warn.stack).complete();
}

function createProviderManager() {
    let changePending;
    let provider;
    let nextConfig;
    // when instruments are configured, they patch the actual files before they are loaded
    // once the patched files are loaded, there is no way to re-patch them, thus to allow re-configuration
    // during init, we need to re-init existing instruments if they have already been configured once
    const configuredInstruments = {};

    const manager = {
        name,

        version,

        get provider() {
            return provider;
        },

        get changePending() {
            return changePending;
        },

        async configure(config) {
            if (changePending) {
                // if init in progress, then remember new config and return
                if (nextConfig !== config) {
                    nextConfig = config;
                }
                return changePending;
            }

            this.currentConfig = config;
            changePending = configure(config)
                .then(data => {
                    changePending = undefined; // mark as done
                    // check if new config came while init was in progress
                    if (nextConfig) {
                        const cfg = nextConfig;
                        // mark undefined to avoid re-init next time for the same config
                        nextConfig = undefined;
                        // re-init
                        return this.configure(cfg);
                    }
                    return data;
                })
                .catch(err => {
                    changePending = undefined; // mark as done
                    throw err;
                });
            return changePending;
        },

        async restart() {
            await this.isReady;
            return this.configure(this.currentConfig);
        },

        shutdown, // allow shutdown externally

        getTracer() {
            // provider serves as enable flag
            if (provider === undefined) {
                return;
            }
            return opentelemetry.trace.getTracer(name, version);
        },

        /**
         * Due to async nature this method may return false till the configuration is loaded.
         * If you need the config to load, you can use isReady async function to await for config to load.
         * @returns true if tracer is enabled.
         */
        isEnabled() {
            return provider !== undefined;
        }
    };

    // This can be used to wait for initial initialization.
    // It is useful for testing or when it is important to load it first.
    manager.isReady = new Promise(resolve => {
        // hook to config and change events
        // eslint-disable-next-line
        modConfig(__dirname, (_, cfg) => {
            // todo: thow error in configure call
            manager.configure(cfg.get('tracing'))
                .catch(reportError);
            cfg.on('change', () => {
                // todo: thow error in configure call
                manager.configure(cfg.get('tracing'))
                    .catch(reportError);
            });
            resolve(true);
        });
    });

    return manager;

    async function configure(config) {
        await shutdown();
        // assign to provider to mark provider as ready
        provider = await init(config);
        return provider;
    }

    async function shutdown() {
        if (provider) {
            await provider.shutdown()
                .catch(reportError);
            // without disable global reference will not be cleared
            opentelemetry.trace.disable();
            opentelemetry.diag.disable();
            provider = undefined;
        }
    }

    async function init(config) {
        if (!config.enabled) {
            return;
        }

        opentelemetry.diag.setLogger(logger);

        // continue init
        const debug = config.debug;
        const samplePercent = config.samplePercent;
        const collectorEnabled = config.collectorEnabled;
        const endpoints = config.endpoints;
        const ssl = config.ssl;

        const newProvider = new NodeTracerProvider({
            resource: new Resource({
                [SemanticResourceAttributes.SERVICE_NAME]: appContext.poolName,
                'com.ebay.framework': 'Node.js',
                'pool': appContext.poolName,
                'buildid': manifest && manifest.version.rpmName,
                'application': appContext.appName,
                'environment': process.env.NODE_ENV
            }),
            sampler: new ParentBasedSampler({
                root: new TraceIdRatioBasedSampler((samplePercent / 100))
            })
        });

        const instrumentations = Object.keys(config.instrumentations || []).reduce((acc, itName) => {
            const it = config.instrumentations[itName];
            if (it.enabled) {
                const loadedInstr = configuredInstruments[itName];
                if (loadedInstr) {
                    if (loadedInstr.setConfig) {
                        loadedInstr.setConfig(it.config);
                    }
                    else {
                        console.warn(`Instrument ${
                            itName} does not provide setConfig to update its config if it is applicable`);
                    }
                    acc.push(loadedInstr);
                }
                else {
                    const instr = require(it.module);
                    const Ctr = it.constructorName && instr[it.constructorName] || instr;
                    const inst = configuredInstruments[itName] = new Ctr(it.config);
                    acc.push(inst);
                }
            }
            return acc;
        }, []);

        registerInstrumentations({
            tracerProvider: newProvider,
            instrumentations
        });

        const tracingEndpoint = getTracingEndpoint(endpoints);
        if (!tracingEndpoint) {
            reportError(new Error('Trace Endpoint cannot be resolved, not exporting traces.'));
        }

        if (collectorEnabled && tracingEndpoint) {
            const exporterConfig = {
                url: tracingEndpoint
            };

            if (ssl || tracingEndpoint.endsWith(':443')) {
                const certs = require('@ebay/service-instruments-ebay/ebay-root-certs');
                const certString = certs[0];
                const certBuff = Buffer.from(certString, 'utf-8');
                exporterConfig.credentials = grpc.credentials.createSsl(certBuff);
            }
            const exporter = new CollectorTraceExporter(exporterConfig);
            newProvider.addSpanProcessor(
                new BatchSpanProcessor(exporter, {
                    maxQueueSize: config.queueSize,
                    scheduledDelayMillis: config.flushDelayInMillis
                })
            );
        }

        if (debug) {
            newProvider.addSpanProcessor(
                new SimpleSpanProcessor(new ConsoleSpanExporter())
            );
        }

        // Initialize the OpenTelemetry APIs to use the NodeTracerProvider bindings
        newProvider.register();

        if (typeof tracingEndpoint === 'string') {
            const client = new grpc.Client(tracingEndpoint, grpc.credentials.createInsecure());
            const channel = client.getChannel();
            const state = channel.getConnectivityState();
            createComponentStatus(stateMap[state]);
        }

        return newProvider;
    }
}

const providerManager = createProviderManager();

['SIGINT', 'SIGTERM'].forEach(signal => {
    process.on(signal, () => providerManager.shutdown());
});

module.exports = providerManager;
module.exports.logger = logger;
