'use strict';

const modConfig = require('@ebay/module-config-inc');
const provider = require('@ebay/service-client-ebay');
const path = require('path');
const fs = require('fs');
const _ = require('lodash');
const appContext = require('@ebay/app-context-ebay');
const validateServiceResolution = require('./validate');
const utils = require('./utils');
const SERVICE_DISCOVERY_JSON = path.join(process.cwd(), '.cache/.discovery.json');
const discoveryClientConfigBean = require('./discoveryClientConfigBean');
const clientCompStatusBean = require('./discoveryClientComponentStatusBean');
const getServiceTags = require('./service-tag');

let appFlagEnabled = false;

isAppEnabled().then((flag) => {
    appFlagEnabled = flag;
});

function isAppEnabled() {
    return new Promise((resolve, reject) => {
        modConfig(module, (err, config) => {
            if (err) {
                return resolve(false);
            }
            return resolve(config.get('service-discovery-ebay:enabled'));
        });
    });
}

async function fetchDiscoveryData(dataOnly = false) {
    appFlagEnabled = await isAppEnabled();

    // Check if appContext.vpc is PCI or RNPCI
    const isPCI = appContext.vpc && ['pci', 'rnpci'].includes(appContext.vpc.toLowerCase());

    // provide a way to skip app flag check for getting data only
    if (!dataOnly && (!appFlagEnabled || !discoveryClientConfigBean.enabled || !isPCI)) {
        // eslint-disable-next-line no-console
        console.log('Service discovery is disabled!');
        return {};
    }

    const client = provider.context({}).getClient('authSvcDiscovery');
    const allServiceTags = await getServiceTags() || {};
    const postBody = {
        'serviceId': '*',
        'systemLabels': getSystemLabels(),
        'applicationLabels': {
            '*': '*'
        },
        'systemLabelsIgnoreCase': true,
        allServiceTags
    };

    // eslint-disable-next-line no-console
    console.log(JSON.stringify(postBody));

    return new Promise((resolve, reject) => {
        client.post({
            body: JSON.stringify(postBody),
            'headers': {
                'content-type': 'application/json'
            }
        }).end((err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data.body);
            }
        });
    });
}
module.exports.fetchDiscoveryData = fetchDiscoveryData;

/**
 * Generate cache from file if present. The file will be created by build-script during startup
 * Hence, this method can't take data-to-write as argument
 **/
const loadCacheFromFile = module.exports.loadCacheFromFile = async() => new Promise((resolve, reject) => {
    fs.readFile(SERVICE_DISCOVERY_JSON, 'utf8', async(err, str) => {
        if (err) {
            reject(err);
            return;
        }
        try {
            const obj = JSON.parse(str);
            const systemLabels = getSystemLabels();
            Object.entries(systemLabels).forEach(([k, v]) => clientCompStatusBean.set(`systemLabel:${k}`, v));
            Object.entries(obj).forEach(([k, v]) => clientCompStatusBean.set(`${k}`, v));

            const allServiceTags = await getServiceTags() || {};
            for (const [urn, sTag] of Object.entries(allServiceTags)) {
                clientCompStatusBean.set(`serviceTag:${urn}`, sTag);
            }
            resolve();
        } catch (error) {
            reject(error);
        }
    });
});

discoveryClientConfigBean.forceRefreshCallback = module.exports.refreshCache = () => {
    return utils.createCacheDirIfNotExists()
        .then(fetchDiscoveryData)
        .then(registry => {
            const promise = validateServiceResolution(process.cwd(), registry);
            return promise
                .then(moveNLoad.bind(this, registry))
                .catch(moveNLoad.bind(this, registry)); // Eating resolution failure for now
        })
        .catch(e => {
            console.warn(e); // once discovery is mandatory by default, this should be error and should throw
        });

    async function moveNLoad(registry) {
        return utils.writeDataToFile(registry)
            .then(loadCacheFromFile);
    }
};

/** urn should be of type urn:REST:servicename */
module.exports.lookup = (urn, appLabels) => {
    if (!urn) {
        return null;
    } else if (discoveryClientConfigBean.exclusions.includes(urn)) {
        return null;
    } else if (!appFlagEnabled || !discoveryClientConfigBean.enabled) {
        return null;
    }

    const d = clientCompStatusBean.get(urn);
    if (d) {
        let temp;
        const f = d.find(c => {
            if (!c.applicationLabels) { /* istanbul ignore else */
                temp = c; // default one with no application labels
            }
            return _.isEqual(c.applicationLabels, appLabels);
        });
        return f || temp;
    }
    return null;
};

function getSystemLabels() {
    return {
        'platformEnv': appContext.classOfService || '*',
        'paasRealm': appContext.paasRealm || '*',
        'vpc': appContext.vpc || '*',
        'applicationName': appContext.appName || '*'
    };
}
