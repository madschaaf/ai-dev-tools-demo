'use strict';

//current module dependency files
var COSConstant = require('./COSConstants');
var oauthService = require('../services/index');
var oauthUtil = require('../oauthUtil');
var iaf = require('@ebay/iaf-ebay');
var Async = require('async');
const cosUtils = require('../commerce-os-utils');
const commerceOsUtils = (() => ({
    validateClientType: (...args) => new Promise((resolve, reject) => {
        cosUtils.validateClientType(...args, err => err ? reject(err) : resolve());
    }),
    validateClientScope: (...args) => new Promise((resolve, reject) => {
        cosUtils.validateClientScope(...args, err => err ? reject(err) : resolve());
    })
}))();
var hmvUtils = require('@ebay/header-multi-value-ebay');
var env = require('@ebay/environment-ebay');
var LRU = require("lru-cache");
var cache = new LRU({
    max: 1000
});
const appContext = require('@ebay/app-context-ebay');
const modConfig = require('@ebay/module-config-inc');
const loadConfig = require('util').promisify(modConfig);

//variables
var PUBLIC_SCOPE = COSConstant.PUBLIC_SCOPE;

const logger = require('@ebay/logging-inc').logger('ebay-oauth:middleware');

function getDefaultScopes() {
    var scopes = [];
    scopes.push(PUBLIC_SCOPE);
    return scopes;
}

function ebayOauth() {
    /*jshint validthis:true */
    this.OAUTH_FLAG = false;
    this.req = null;
}

ebayOauth.prototype.getDefaultAppName = function getDefaultAppName() {
    var self = this;
    var req = self.req;
    return req && req.ebay && req.ebay && req.ebay.appContext && req.ebay.appContext.appName;
};

module.exports = function oauth() {

    return function oAuth(req, res, next) {
        var oauth = new ebayOauth();
        oauth.OAUTH_FLAG = true;
        oauth.req = req;
        req.ebay = req.ebay || {};
        req.ebay.oauth = oauth;

        next();
    };
};

module.exports.OAuth = ebayOauth;
module.exports.logger = logger;

/**
 * Obtain a token on behalf of a signed-in user with the scopes requested.
 * This token will not be cached and is expected to be used by JavaScript clients.
 * To prevent unauthorized access to services, the scopes requested should be the
 * minimal set required for service access from the JavaScript client.
 * This token will have a shorter expiration time driven by policy
 * Public - in the function name indicates that this is a Token by Reference
 * And not the original Token by
 *
 * @param appname is ignored as framework will always use host app name from app-context-ebay
 * @param scopes the minimal list of scopes needed for accessing service
 * @return A new access token with granted scopes (by policy)   (AccessToken object)
 */
ebayOauth.prototype.getAppToken = async function getAppToken(appname, scopes, type, options, callback) {
    var args = Array.prototype.slice.call(arguments);
    callback = args.pop();
    appname = args.shift();
    scopes = args.shift() || getDefaultScopes();
    type = args.shift() || 'Hosted';
    options = args.shift() || {};

    const defaultAppName = this.getDefaultAppName();
    if (defaultAppName && appname && defaultAppName !== appname) {
        logger.error(new Error(`Attempt to use appname (${appname}) other than its own ${defaultAppName}, will default to ${defaultAppName}`));
        appname = defaultAppName;
    }

    // make some tests that are not part of commons-ebay -> app-context-ebay still pass as the test other edge cases
    appname = appname || defaultAppName;

    const tokenResult = await this.getApplicationToken({
        ...options,
        scopes,
        appName: appname,
        type
    }).catch(err => err);

    if (tokenResult instanceof Error) {
        return callback(tokenResult);
    }

    callback(null, tokenResult);
};

ebayOauth.prototype.getApplicationToken = async function getApplicationToken(options) {
    const appName = options?.appName || appContext.appName;
    const scopes = options?.scopes || [COSConstant.PUBLIC_SCOPE];
    const type = options.type || 'Hosted';

    const jwt = options?.jwt !== undefined ? options?.jwt : await (async () => {
        const oauthGlobalConfig = await loadConfig(__dirname);
        const jwtEnabled = oauthGlobalConfig.get('oauth-ebay:jwt');
        return jwtEnabled;
    })();

    var keyHash = oauthUtil.getKeyHash(appName, scopes, 'app', jwt);

    var cachedAppToken = cache.get(keyHash);

    if (cachedAppToken && !options.refresh) {
        return cachedAppToken;
    }

    await Promise.all([
        commerceOsUtils.validateClientType(type, appName),
        commerceOsUtils.validateClientScope(scopes, appName)
    ]);

    //expires_in attribute specifies the number of seconds for which this token is valid
    //Date.now : number of milliseconds elapsed since 1 January 1970 UTC
    const token = await oauthService.getApplicationToken({
        ...options,
        scopes,
        appName
    });

    if (token) {
        const tokenResult = {};
        tokenResult.value = token.access_token;
        tokenResult.expires_in = token.expires_in;
        tokenResult.expiration = Date.now() + token.expires_in * 1000;
        tokenResult.type = 'app';

        if (tokenResult.expires_in) {
            // allow 44 hours for cache clean up for tokens that as 48
            // while keeping flexible in case they give 1 minutes for expiration, we will use 44/48 fraction of it
            const cacheAge = Math.ceil(44 / 48 * tokenResult.expires_in);
            cache.set(keyHash, tokenResult, cacheAge * 1000);
        }
        return tokenResult;
    }

    throw new Error('service getAppToken got empty or null token');
};

/**
 * Obtain a token on behalf of a signed-in user with the scopes requested.
 * This token will not be cached and is expected to be used by JavaScript clients.
 * To prevent unauthorized access to services, the scopes requested should be the
 * minimal set required for service access from the JavaScript client.
 * This token will have a shorter expiration time driven by policy
 * Public - in the function name indicates that this is a Token by Reference
 * And not the original Token by
 *
 * @param appName the name of the application this token should be granted to
 * @param scopes the minimal list of scopes needed for accessing service
 * @return A new access token with granted scopes (by policy)   (AccessToken object)
 */
ebayOauth.prototype.getPublicUserToken = function getPublicUserToken(widgetAppName, scope, callback) {
    var args = Array.prototype.slice.call(arguments);
    callback = args.pop();
    // public user token can still be used as they do not require secret
    // but their use is discouraged due to security reasons
    widgetAppName = args.shift() || this.getDefaultAppName();
    scope = args.shift() || getDefaultScopes();
    this.getAuthUserToken(widgetAppName || this.getDefaultAppName(), scope, 'ajax', callback);
};

ebayOauth.prototype.getAuthUserToken = function getAuthUserToken(appName, scope, type, callback) {

    if (!this.OAUTH_FLAG) {
        return callback(new Error('Please use middlware require("ebay-oauth").middlware.oauth()'));
    }

    if (!this.isSignIn()) {
        return callback(new Error('User is not signed in'));
    }

    this.getUserTokenCommon(appName, scope, type, false, {}, callback);
};

ebayOauth.prototype.getUserTokenCommon =
    function getUserTokenCommon(appname, scopes, type, isRecognzedUser, options, callback) {
        var args = Array.prototype.slice.call(arguments);
        callback = args.pop();
        appname = args.shift();
        scopes = args.shift() || getDefaultScopes();
        type = args.shift();
        isRecognzedUser = args.shift();
        options = args.shift();

        var self = this;

        if (!this.OAUTH_FLAG) {
            return callback(new Error('Please use middlware require("ebay-oauth").middlware.oauth()'));
        }

        var keyHash = oauthUtil.getKeyHash(appname, scopes, type);

        self._userTokens = self._userTokens || {};
        var token = self._userTokens[keyHash];
        if (token) {
            return callback(null, token);
        }

        Async.series([
            next => cosUtils.validateClientType(type, appname, next),
            next => cosUtils.validateClientScope(scopes, appname, next)
        ], function (err) {
            if (err) {
                return callback(err);
            }

            const expiryInSec = isRecognzedUser ? COSConstant.publicTokenExpiry :
                type === 'Hosted' ? COSConstant.hostedAppTokenExpiry : COSConstant.ajaxTokenExpiry;

            iaf.getUserToken(self.req, {
                byReference: true,
                type: type,
                scope: scopes,
                userId: self.req.ebay.getJSPersistentUserId(),
                accountId: self.req.ebay.getPersistentAccountId(),
                targetService: isRecognzedUser && type === 'Hosted' || type === 'ajax' ? 'ScopedToken' : '',
                expiryInSec // in seconds
            }, function (err, token) {
                if (err) {
                    return callback(err);
                }

                var tokenResult;

                if (token) {
                    tokenResult = {};
                    tokenResult.value = token;
                    // tokenResult.expiration = 30;
                    tokenResult.expires_in = expiryInSec;
                    tokenResult.expiration = Date.now() + tokenResult.expires_in * 1000;
                    tokenResult.type = isRecognzedUser ? 'recognized' : 'user';

                    // cache it for the time of the request
                    self._userTokens[keyHash] = tokenResult;
                    callback(null, tokenResult);
                }
                else {
                    return callback(new Error('service iaf.getUserToken returned empty or null token'));
                }
            });

        });

    };

/**
 * Obtain a token on behalf of an anonymous user with the scopes requested.
 * This token will not be cached and is expected to be used by JavaScript clients.
 * To prevent unauthorized access to services, the scopes requested should be the
 * minimal set required for service access from the JavaScript client.
 * This token will have a shorter expiration time driven by policy
 *
 * @param widgetAppName the name of the application this token should be granted for
 * @param scopes the minimal list of scopes needed for accessing service
 * @return A new access token with granted scopes (by policy)   (AccessToken object)
 */
ebayOauth.prototype.getPublicAppToken = function getPublicAppToken(widgetAppName, scopes, callback) {
    var self = this;

    var args = Array.prototype.slice.call(arguments);
    callback = args.pop();
    widgetAppName = args.shift();
    scopes = args.shift() || getDefaultScopes();

    /**
     * TODO: the current implementation seems to generate public app token by value instead of by ref.
     * The use of this API is under a question as one cannot revoke it easily
     */
    self.getAppToken(widgetAppName || self.getDefaultAppName(), scopes, 'ajax', callback);
};

ebayOauth.prototype.getRecognizedUserToken = function getRecognizedUserToken(scopes, callback) {
    var self = this;
    if (typeof scopes === 'function') {
        callback = scopes;
        scopes = undefined;
    }
    scopes = scopes || PUBLIC_SCOPE;

    if (!this.isRecognizedUser()) {
        return callback(new Error('Recognized User cannot be found'));
    }
    var appName = this.getDefaultAppName();

    Async.series([
        commerceOsUtils.validateClientType.bind(null, 'Hosted', appName),
        commerceOsUtils.validateClientScope.bind(null, scopes, appName)
    ], function (err) {
        if (err) {
            return callback(err);
        }

        self.getUserToken(appName, scopes, {
            recognized: true
        }, callback);
    });
};

ebayOauth.prototype.getPublicRecognizedUserToken = function getPublicRecognizedUserToken(
    widgetAppName, scopes, callback) {

    if (!this.isRecognizedUser()) {
        return callback(new Error('Recognized User cannot be found'));
    }

    var args = [].slice.call(arguments);
    widgetAppName = args.shift();
    callback = args.pop();
    scopes = args.shift() || PUBLIC_SCOPE;

    this.getUserTokenCommon(widgetAppName || this.getDefaultAppName(),
        scopes, 'ajax', true, {}, callback);
};


ebayOauth.prototype.isRecognizedUser = function () {
    var req = this.req;
    return this.isSignIn() || req && req.ebay && req.ebay.getPersistentAccountId() && req.ebay.getJSPersistentUserId();
};

ebayOauth.prototype.isSignIn = function isSignIn() {
    var self = this;
    var req = self.req;
    return req && req.ebay && req.ebay.hasLevel1UserId();
};

ebayOauth.prototype.getEnvironment = function getEnvironment() {
    return env._env();
};

ebayOauth.prototype.getCorrelationSession = function getCorrelationSession() {
    var req = this.req;
    return req && req.ebay && req.ebay.cookies && req.ebay.cookies.getCookieValue('SOJOURNER_GUID');
};


ebayOauth.prototype.getUserToken = function getUserToken(appName, scopes, options, callback) {
    var self = this;

    var args = Array.prototype.slice.call(arguments);
    callback = args.pop();
    appName = args.shift() || self.getDefaultAppName();
    scopes = args.shift() || getDefaultScopes();
    options = args.shift() || {};

    // update EndUserContext
    var ctx = self.req.ebay;
    var accountId = ctx.getAccountId() || ctx.getPersistentAccountId();
    var userId = ctx.getLevel1UserId() || ctx.getJSPersistentUserId();
    if (!accountId || !userId) {
        return callback(new Error('The user id (' + userId +
            ') of account id (' + accountId + ') are not known'));
    }

    var euc = ctx.getEndUserContext();

    var origUserIdCtx = hmvUtils.create();
    origUserIdCtx.set('origUserName', userId);
    origUserIdCtx.set('origAcctId', accountId);
    origUserIdCtx.set('recognized', options && options.recognized || false);

    euc.ctx.set('origUserId', origUserIdCtx);

    self.getAppToken(appName, scopes, 'Hosted', options, callback);

};
