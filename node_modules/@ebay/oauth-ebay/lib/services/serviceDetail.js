'use strict';

var assert = require('assert');
var detailMemoryCache = require('memory-cache');
var provider = require('@ebay/service-client-ebay');

var logger = require('@ebay/logging-inc').logger('ebay-oauth:serviceDetail');
var ebayAppMeta = require('@ebay/appmeta-ebay');
const appContext = require('@ebay/app-context-ebay');
const env = require('@ebay/environment-ebay');
const appTokenService = require('./appTokenService');
const iaf = require('@ebay/iaf-ebay/lib/iaf');

function getAppServiceDetail(appName, options, callback) {
	var args = Array.prototype.slice.call(arguments);
	callback = args.pop();
	appName = args.shift();
	options = args.shift();

	assert.ok(appName, 'appName should not be empty!');

	options = options || {};
	var key = 'serviceDetail:' + appName;
	var cachedDetail = detailMemoryCache.get(key);
    if (cachedDetail && !options.refresh) {
		return callback(null, cachedDetail);
    }
	else {
		// TODO: security context should always be host app while appName can be some other app we get details for
		getInitialSecurityContext(appName, (err, securityContext) => {
			if(err){
				return callback(err);
			}

			getServiceDetail(securityContext.consumerId, securityContext.token, (err, data) => {
				if (data && data.type) {
					/* Override client secret from client detail service with app-meta which pull in client secret from ESAMS */ 
					data.clientSecret = securityContext.appSecret;
					detailMemoryCache.put(key, data);
				}
				else if (data) {
					logger.error('Service details are missing type attribute, response body:',
						data instanceof Buffer ? data.toString() :
							(typeof data === 'string' ? data : JSON.stringify(data)));
				}
				callback(err, data);
			});
		});
	}
}

function getInitialSecurityContext(appName, callback) {
	ebayAppMeta.get(appName, false, async (err, meta) => {
		if(err){
			return callback(err);
		}

		const appSecret = meta.getAppSecret();
		const consumerId = meta.getConsumerId() || appContext.consumerId;

		const token = await appTokenService.getApplicationToken({
			appName,
			scopes: 'https://api.ebay.com/oauth/scope/core@application'
		}).catch(err => err);
		
		if (token instanceof Error) {
			// there is a bug in IAF where it does not validate the scopes and that allowed to get public app and user tokens for non-host app
			// in unit tests, which is good feature to have, but in real world it will not work.
			// keeping it here only for unit tests and dev only
			if (token.body?.error === 'invalid_scope' && (env.isTest() || env.isDev())) {
				iaf.getAppToken({
					scope: 'https://api.ebay.com/oauth/scope/core@application',
					consumerId,
					appSecret
				}, (err, token) => {
					callback(err, token && {
						appSecret,
						consumerId,
						token
					});
				});
				return;
			}
			// or return error set to token var
			return callback(token);
		}

		callback(err, token && {
			appSecret,
			consumerId,
			token: token.access_token
		});
	});
}

function getServiceDetail(consumerId, token, callback) {
	assert.ok(consumerId, 'consumerId must be provided');
	assert.ok(token, 'initial app token must be provided');

	provider.context({}).getClient('oauthDetailSvc')
	.get()
	.path('/clientId/' + consumerId)
	.set('authorization', `Bearer ${token}`)
	.end(function (err, response) {
		if (err) {
			return callback(err);
		}

		const data = response && response.body;
		// compatibility fix after switching to /registry/v1
		data.allowedScopes = data.allowedScopes ||
			data.policies && data.policies.client_credential && data.policies.client_credential.allowedScopes;
		callback(err, data);
	});
}

module.exports = {
	getServiceDetail: getServiceDetail,
	getAppServiceDetail: getAppServiceDetail,
	getInitialSecurityContext
};
