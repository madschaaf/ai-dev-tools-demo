'use strict';
var Assert = require('assert');
var caller = require('caller');
var moduleConfig = require('@ebay/module-config-inc');
var Utils = require('../../lib/utils');
// ============= TOBE deleted after transition is over and everyone switched to bridge
var Trooba = require('trooba');
var logger = require('@ebay/logging-inc').logger('service-client-ebay/service-use');
var config = require('@ebay/service-instruments-ebay/config');
var Hmv = require('@ebay/header-multi-value-ebay');
// =======================================================================================

module.exports = function(input, out) {
    var asyncOut = out.beginAsync();
    var clientId = input.id;

    var callerModule = caller(2);
    var moduleRef = Utils.lookupModule(input.caller || callerModule) || module;

    var res = out.stream;
    var req = res && res.req;
    if (!req) {
        req = out.global && out.global.req;
    }

    Assert.ok(req, 'request is missing in marko context');

    // here we should use process.cwd which is the owner of the bridge configurations
    // it cannot be part of some module that is used by app
    moduleConfig(process.cwd(), (err, config) => {
        if (config.get('service-client-ebay:bridge') !== true) {
            return deprecatedServiceUse(input, out);
        }
        const transitionConfig = config.get(`services:${clientId}-bridge`);
        // if transitionConfig is present, then we need to matain legacy and new config
        //   where clientId for new config should have `-bridge` suffix
        // otherwise we are in new mode and expect only clientId config
        const transitionMode = !!transitionConfig;
        const request = transitionConfig || config.get(`services:${clientId}`);
        if (request) {
            // then we are in transition mode
        }
        var options = [
            'bridgePath',
            'method',
            'headers'
        ].reduce((acc, name) => {
            acc[name] = request[name];
            return acc;
        }, {});

        options.bridge = true;
        options.bridgeMode = transitionMode && 'transition' || 'on';

        var noncePH = req && req.csp && req.csp.nonce ?
            'nonce="'+req.csp.nonce+'"' : '';
        var writeScript = '<script type="text/javascript" '+noncePH+'>(function (serviceConfigs) {' +
            'serviceConfigs["' + clientId + '"] = ' + JSON.stringify(options) + ';' +
        '}(window.$serviceConfigs || (window.$serviceConfigs = {})));</script>';

        asyncOut.write(writeScript);
        asyncOut.end();    
    });

    /**
     * THIS TO BE DELETED ONCE apps are migrated to bridge route
     */
    function deprecatedServiceUse(input, out) {
        const pipeline = Trooba
        .use(function preConfigure(pipe) {
            logger.info('pre-configring pipeline for config extraction to browser side');
            pipe.context.instruments = [
                'tracking',
                'outbound-context'
            ];
    
            // if user provided a token, do not add oauth instrumentation
            if (!input.token) {
                pipe.context.instruments.push('oauth');
            }
        })
        .use(config);
    
        // if user provided a token, use that instead of oauth
        // we add this handler later so that 'headers' is defined and set already
        if (input.token) {
            pipeline.use(function overrideToken(pipe) {
                pipe.on('request', function onRequest(request, next) {
                    request.headers.authorization = `Bearer ${input.token}`;
                    next();
                });
            });
        }
        
        pipeline.use(function onComplete(pipe) {
            pipe.on('request', function onRequest(request) {
                var options = request;
                var allowHeaders = options['allow-headers'];
                logger.info('Allowed headers', allowHeaders);
                options.headers = Utils.objectKeysToLowerCase(options.headers);
                if (allowHeaders && options.headers) {
                    options.headers = allowHeaders.reduce(function reduce(memo, key) {
                        var lowercaseKey = key.toLowerCase();
                        if (options.headers[lowercaseKey] !== undefined) {
                            memo[lowercaseKey] = options.headers[lowercaseKey];
                        }
                        return memo;
                    }, {});
                }
    
                // sanitize end user context
                var euc = options.headers['x-ebay-c-enduserctx'];
                if (euc && (euc.indexOf('origUserId=') !== -1 || euc.indexOf('clientId=') !== -1 || euc.indexOf('guessedUserId=') !== -1)) {
                    var eucHeader = Hmv.parse(euc);
                    if(eucHeader.value.origUserId) {
                        delete eucHeader.value.origUserId;
                    }
                    if(eucHeader.value.clientId) {
                        delete eucHeader.value.clientId;
                    }
                    if(eucHeader.value.guessedUserId) {
                        delete eucHeader.value.guessedUserId;
                    }
                    if(eucHeader.value.guessedUserIdLegacy) {
                        delete eucHeader.value.guessedUserIdLegacy;
                    }
                    options.headers['x-ebay-c-enduserctx'] = eucHeader.toString();
                }
                var cTracking = options.headers['x-ebay-c-tracking'];
                if (cTracking && cTracking.indexOf('buid=') !== -1) {
                    var trackingHeader = Hmv.parse(cTracking);
                    if (trackingHeader.value.buid) {
                        delete trackingHeader.value.buid;
                    }
                    options.headers['x-ebay-c-tracking'] = trackingHeader.toString();
                }
    
                var noncePH = req && req.csp && req.csp.nonce ?
                    'nonce="'+req.csp.nonce+'"' : '';
                var writeScript = '<script type="text/javascript" '+noncePH+'>(function (serviceConfigs) {' +
                    'serviceConfigs["' + clientId + '"] = ' + JSON.stringify(options) + ';' +
                '}(window.$serviceConfigs || (window.$serviceConfigs = {})));</script>';
    
                asyncOut.write(writeScript);
    
                asyncOut.end();
            });
        })
        .build()
        .create({
            app: {
                request: req,
                response: req.res
            },
            caller: moduleRef,
            clientId: clientId
        })
        .request({
            tolerant: true,
            browser: true
        }, function noop(err) {
                    logger.error(err);
                    asyncOut.error(err);
            });
    }
};
