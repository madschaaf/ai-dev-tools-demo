const Assert = require('assert');
const { promise } = require('../utils');
const { resolveNestedPromises, resolveWithFallback } = promise;

describe('Promise utilities', () => {
    describe('resolveNestedPromises', () => {
        it('should resolve nested promise', done => {
            const input = {
                key: Promise.resolve('value')
            };
            const expected = {
                key: 'value'
            };

            resolveNestedPromises(input).then(result => {
                Assert.deepEqual(result, expected);
                done();
            });
        });

        it('should not modify json objects that don\'t have promises', done => {
            const input = {
                key: 'value'
            };

            resolveNestedPromises(input).then(result => {
                Assert.deepEqual(result, input);
                done();
            });
        });

        it('should throw an error if the nested promise gets rejected', done => {
            const input = {
                key: Promise.reject('value')
            };

            resolveNestedPromises(input).then(result => {
                Assert.fail();
                done();
            }).catch(error => {
                Assert.deepEqual(error, 'value');
                done();
            });
        });

        it('should handle multiple levels of nesting in the json object', done => {
            const input = {
                first: Promise.resolve('1st'),
                deep: {
                    second: Promise.resolve('2nd'),
                    deeper: {
                        third: Promise.resolve('3rd'),
                        deepest: {
                            fourth: new Promise(resolve => { setTimeout(() => resolve('4th'), 100); })
                        }

                    }
                }
            };

            const expected = {
                first: '1st',
                deep: {
                    second: '2nd',
                    deeper: {
                        third: '3rd',
                        deepest: {
                            fourth: '4th'
                        }
                    }
                }
            };

            resolveNestedPromises(input).then(result => {
                Assert.deepEqual(result, expected);
                done();
            });
        });
    });
    describe('resolveWithFallback', () => {
        it('it should resolve without fallback if theres no errors', done => {
            const promiseWithNoError = new Promise(resolve => resolve('no error 1'));
            const promiseWithNoError2 = new Promise(resolve => resolve('no error 2'));
            Promise.all([promiseWithNoError, resolveWithFallback(promiseWithNoError2, 'fallback')])
                .then(([one, two]) => {
                    Assert.equal(one, 'no error 1');
                    Assert.equal(two, 'no error 2');
                    done();
                }).catch(done);
        });

        it(`it should resolve with fallback when there's errors`, done => {
            const promiseWithNoError = new Promise(resolve => resolve('no error 1'));
            const promiseWithError = new Promise((_, reject) => reject(new Error()));
            Promise.all([promiseWithNoError, resolveWithFallback(promiseWithError, 'fallback')])
                .then(([one, two]) => {
                    Assert.equal(one, 'no error 1');
                    Assert.equal(two, 'fallback');
                    done();
                }).catch(done);
        });
    });
});
