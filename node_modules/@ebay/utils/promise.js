const getNestedPromises = obj => {
    const keys = Object.keys(obj);
    return keys.reduce((output, key) => {
        if (typeof obj[key].then === 'function') {
            output.push({ obj, key });
        } else if (typeof obj[key] === 'object') {
            output.push(...getNestedPromises(obj[key]));
        }
        return output;
    }, []);
};

/**
 * Resolves a JSON object which may have nested promises in them and replaces them with resolved values.
 *
 * @param {*} obj JSON object which may have nested promises.
 */
function resolveNestedPromises(obj) {
    const promiseHolders = getNestedPromises(obj);
    return Promise.all(promiseHolders.map(promiseHolder => promiseHolder.obj[promiseHolder.key])).then(values => {
        promiseHolders.forEach((holder, i) => {
            holder.obj[holder.key] = values[i];
        });
        return obj;
    });
}
/**
 * Catches any errors and returns a fallback value
 *
 * @param {Promise<any>} thenable Promise that can be caught
 * @param {any} fallbackValue the fallback value
 * @returns {Promise<any>} the fallback value wrapped in a promise
 */
function resolveWithFallback(thenable, fallbackValue) {
    return new Promise(
        (resolve) => thenable
            .then(value => resolve(value))
            .catch(() => resolve(fallbackValue))
    );
}

module.exports = {
    resolveNestedPromises,
    resolveWithFallback
};