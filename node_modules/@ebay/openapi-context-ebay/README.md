# openapi-context-ebay
===============

The module provides oja context structure to [ebay openapi](git@github.corp.ebay.com:nodejs/openapi-ebay.git) framework.

For more information, please look at blog post ["Structuring Bisiness Logic in Node.JS Applications -- Dependency Injection"](https://medium.com/@dimichmm/structuring-business-logic-in-node-js-application-dependency-injection-1497ccae994e)

## Install

```
$ npm install openapi-context-ebay -S
```

## Usage

### Configuration

```javascript
const createProvider = require('oja-context-provider')();
// create provider one time
const createContext = await createProvider([
    'path:src/actions',
    'path:src/other-actions'
]);
const confgure = require('openapi-ebay');
const app = await confgure({
    schema: Path.resolve('./schema.json'),
    docspath: '/api-docs',
    handlers: './handlers',
    handlerRuntimeFactory: require('openapi-context-ebay')({
        createContext
    })
});
```

### Handler API
The context based handler should have the following basic signature:

```js
async context => {
    // do anything here
    // access conetxt.domain.actions here if provided
    // return Promise or actual response or a triplet of data, content type and status code
    return <response> | <[data, content-type, statusCode]> | Function
}
```
_Note_: this is useful, for example, to decouple express/http signature from actual function for easy testing and mocking. All contextual function should be injected into context by runtime-context factory.

The context factory is called before calling any handler and this is a opportunity to inject any function required, usually this is done by platform framework.

### Structuring business logic into business actions/functions

Since openapi schema defines all incoming parameters as well as the full structure of response, it makes sense to completely abstract from express method signature.

If this is what you need you can provide your own handler runtime via handlerRuntimeFactory parameter or use default one `default-handler-runtime`.

Once it is hooked up, the handler method signature must look like the below example:

my-handler.js:
```js
module.exports = async context => {
    console.log('parameters:', context.parameters); // note, parameters object will aggregate parameters from body, query and path
    // make service or other actions calls if they are registered under respective domains
    const results = await context.services.find({
        keyword: context.parameters.keyword
    });

    // format the result and return
    return results.map(item => ({
        name: item.name,
        desc: item.desc
    }));
    // the handler runtime will take care of formating it back to json
}
```

If you are into memoization, you can split the handler into a two level structure:

my-handler.js:
```js
module.exports = async context => {
    // you can do some cachiing here
    const cache = {};
    // return actual handler function
    return parameters => {
        console.log('parameters:', parameters); // note, parameters object will aggregate parameters from body, query and path
        // make service or other actions calls if they are registered under respective domains
        const results = await context.services.find({
            keyword: parameters.keyword
        });

        // format the result and return
        return results.map(item => ({
            name: item.name,
            desc: item.desc
        }));
        // the handler runtime will take care of formating it back to json
    }
}
```

In case of error, you can just throw it; the framework will handle it and pass it to the error handler.

If one needs more functionality to handle different reponses, like streaming or provide different handler signature, one can provide a custom implementation of handler runtime fuctory.

##### Exposing other actions/functions via context

Note in the above example of the handler it uses `context.service.find` function from the context.

What this means is that you can inject other functions into context for easy access and that will make the actions/services decoupled from each other as they will not longer need to import other actions and one can just use it from the context object. This also makes unit testing much easier as you can just inject mock value for any function/action.

The example on how one can inject `service.find` action is provided below. Note `preMiddleware` handler.

In case of unit test what you can do is to create a context and pass it into the function that you want to test.

```js
const handler = require('./my-handler');
const createContext = require('oja/context');
const context = createContext({
    properties: {
        parameteres: {
            keyword: 'nike'
        }
    },
    functions: {
        find: [
            { result1 },
            { result2 },
            ...
        ]
    }
});

const result = await handler(context);
Assert.deepEqual([
    { result1 },
    { result2 },
    ...
], result);
```

You can also mock failure of the function like this:

```js
const handler = require('./my-handler');
const createContext = require('oja/context');
const context = createContext({
    properties: {
        parameteres: {
            keyword: 'nike'
        }
    },
    functions: {
        find: new Error('BOOM')
    }
});

try {
    await handler(context);
}
catch (err) {
    Assert.equal('BOOM', err.message);
}
```

##### <a name="runtime-configuration"> </a>Runtime configuration

```javascript
const confgure = require('openapi-ebay');
const app = await confgure({
    schema: Path.resolve('./schema.json'),
    docspath: '/api-docs',
    handlers: './handlers',
    securityProviders: './security' //Optional - security authorize handlers as per `securitySchemas`
    handlerRuntimeFactory: require('openapi-ebay/default-handler-runtime')({
        createContext: require('oja/context')
    })
});
```

One can also inject its own runtime to req.$context via custom middleware before it hits the controller handler.

```javascript
const confgure = require('openapi-ebay');
const createContext = require('oja/context');
const app = await confgure({
    schema: Path.resolve('./schema.json'),
    docspath: '/api-docs',
    handlers: './handlers',
    preMiddleware: [(req, res, next) => {
        req.$context = createContext({
            // injecting custom services
            services: {
                find: context => args => {
                    console.log(`search keyword: ${context.parameters.keyword}`);
                    const itmes = []; // search results
                    await Promise.all(items.map(async itm => {
                        itm.image = await context.actions.processImage(itm.image);
                    }))
                    return items;
                },
                delete: context => args => {
                    return 'ok';
                }
            },
            // other action under domain 'actions'
            actions: {
                processImage: async context => image => {
                    // process image
                    return processedImage;
                }
            }
        });
    }],
    securityProviders: './security' //Optional - security authorize handlers as per `securitySchemas`
    handlerRuntimeFactory: require('openapi-ebay/default-handler-runtime')({
        createContext: require('oja/context')
    })
});
```