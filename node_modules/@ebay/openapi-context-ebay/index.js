'use strict';

const Assert = require('assert');

const DEFAULT_CONTENT_FORMATTERS = {
    'application/json': output => data => {
        data && output.json(data);
    },

    'text/html': output => data => {
        data && output.write(data);
        output.end();
    }
};

/**
 * The function defines a wrapper for the handler to decouple from
 * underlying platform, such as express and allow to operate with basic javascript functions.
 * This will allow to separate actions into small testable functional blocks.
 *
 * This wrapper can be replaced with any other suitable wrapper.
 *
 * There are two key artifacts, context and actions.
 *
 * Context provides access to all actions in the application while actions are completely decoupled from each other.
 *
 * The function signature is "context => {}"
 */
module.exports = options => {
    // get context creation factory
    const { createContext, contentTypeFormatters = {} } = options;

    return (fn, isErrorHandler = false) => {
        Assert.ok(fn.length <= 1,
            `Handler function should be in the form of ` +
            `"context => (args) => <value> or context => <value>", actual: ${fn.toString()}`);

        if (isErrorHandler) {
            return async (err, req, res, next) => {
                req.$context = await getContext(req);
                req.$context.error = err;

                await safeCallHandler(req, res, next);
            };
        }

        return async (req, res, next) => {
            await safeCallHandler(req, res, next);
        };

        async function getContext(req) {
            return req.$context || await createContext({
                properties: {
                    parameters: req.parameters || {},
                    route: req.route,
                    request: req
                },
                functions: {} // no functions so far
            });
        }

        async function safeCallHandler(req, res, next) {
            try {
                await callHandler(req, res, next);
            }
            catch (err) {
                next(err);
            }
        }

        async function callHandler(req, res, next) {
            const context = await getContext(req);
            let ret = await fn(context);
            if (ret instanceof Function) {
                // in case handle in the form of context => parameters => return <value>
                // run it again
                ret = await ret(context.parameters);
            }
            // in case of managed error, pass it to the next handler
            if (ret instanceof Error) {
                return next(ret);
            }

            const [data, annotations] = Array.isArray(ret) ? ret : [ret];
            const { contentType, statusCode, headers } = (annotations || {});

            // response can be in two forms http response or json object thet corresponds to a response format
            res.status(statusCode || (data ? 200 : 204));

            const isJsonData = (data && typeof data === 'object');
            const targetContentType = (contentType ? contentType.split(' ').shift() :
                (isJsonData && 'application/json' || 'text/html')).toLowerCase();
            // set response content type
            res.set('content-type', targetContentType);
            if (headers) {
                Object.entries(headers).forEach(entry => res.set(entry[0], entry[1]));
            }
            // select response formatter
            const responseFormatter = contentTypeFormatters[targetContentType] ||
                DEFAULT_CONTENT_FORMATTERS[targetContentType];
            if (!responseFormatter) {
                throw new Error(`Failed to find response formatter for content-type ${targetContentType}`);
            }
            const process = responseFormatter(res, options);
            process(data);
        }
    };
};
