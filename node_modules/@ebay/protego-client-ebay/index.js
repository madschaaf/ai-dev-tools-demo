'use strict';

const { X509Certificate } = require('crypto');
const Provider = require('@ebay/service-client-ebay');
const { getConfig } = require('@ebay/spellcaster-ebay');

const BEGIN_CERT = '-----BEGIN CERTIFICATE-----';
const END_CERT = '-----END CERTIFICATE-----';

function fromPEMs(content) {
    const list = [];
    let head = 0;
    while (head < content.length) {
        const begin = content.indexOf(BEGIN_CERT, head);
        if (begin < 0) {
            break;
        }
        let end = content.indexOf(END_CERT, head);
        if (end < 0) {
            break;
        }
        end += END_CERT.length;
        const pem = content.substring(begin, end);
        list.push(fromPEM(pem));
        head = end;
    }
    return list;
}

function fromPEM(pem) {
    return new X509Certificate(pem);
}

class ProtegoClient {
    invokeService(path, query = {}) {
        return new Promise((resolve, reject) => {
            Provider.context({})
                .getClient('protego-client-ebay')
                .get(query)
                .path(path)
                .end((err, res) => {
                    if (err) {
                        return reject(err);
                    }

                    resolve(res);
                });
        });
    }

    async getCertificateByChannel(channelName, version) {
        const poolType = this.getPoolTypePrefix();
        const res = await this.invokeService(`/certs/labels/${poolType}:${channelName}/versions/${version}`);
        return {
            certificate: fromPEMs(res.body.toString()).shift(),
            version: res.headers.version && parseInt(res.headers.version) || -1
        };
    }

    async getCertificateBySerial(serial, issuer) {
        const poolType = this.getPoolTypePrefix();
        const res = await this.invokeService(
            `/certs/serial/${serial}/issuer/${encodeURIComponent(issuer)}`, {
                poolType
            });
        return {
            certificate: fromPEMs(res.body.toString()).shift(),
            version: res.headers.version && parseInt(res.headers.version) || -1
        };
    }

    async getCertificates(channelName, version) {
        const poolType = this.getPoolTypePrefix();
        const res = await this.invokeService(`/certs/labels/${poolType}:${channelName}/versions/${version}`, {
            chain: true
        });
        return fromPEMs(res.body.toString());
    }

    getPoolTypePrefix() {
        if (!process.env.NODE_ENV) {
            return 'staging';
        }
        switch (process.env.NODE_ENV) {
            case 'pre-production':
            case 'production':
                return 'production';
            case 'feature': // no feature yet
            case 'lnp':
                return 'qa';
            case 'development':
                return 'dev';
            case 'staging':
                return 'staging';
            default:
                return process.env.NODE_ENV;
        }
    }

    isEnabled() {
        const config = getConfig();
        return config.isProtegoFallbackEnabled() || config.isProtegoEnabled();
    }

    isProtegoFallbackEnabled() {
        const config = getConfig();
        return config.isProtegoFallbackEnabled();
    }
}

module.exports = {
    ProtegoClient
};
