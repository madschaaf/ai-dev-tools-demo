'use strict';

const Currencies = require('./currency').Currencies;

/**
 * Borrowed from com.ebay.af.common.types.Money
 *
 * The Money class provides a means of representing money values as fixed-point
 * long numbers. A Money object is an immutable object; the arithmetic
 * operations return new objects as results.
 *
 * <p>
 * The class stores a money value as a long (64-bit) value with a number of
 * decimal places of 6.
 * </p>
 *
 * <p>
 * For the purposes of this class, the principal unit of currency (e.g. dollars,
 * euros, pounds) is referred to as the major unit, the subdivision of the
 * principal unit (e.g. cents, pence) is the minor unit.
 * </p>
 *
 * <p>
 * The number of real decimal places for determine minor units is determined by
 * the {@link Currency} associated with the object.
 * </p>
 *
 * <p>
 * The class provides conversions to and from floating point (
 * <code>double</code>) values, and <b>users should note the difference between
 * integer and float operations</b> - integer values always refer to the minor
 * unit of money while double values always refer to the major unit, with
 * fractional values representing the minor unit.
 * </p>
 *
 * <p>
 * Money implements Serializable; it also implements Comparable.
 * </p>
 *
 * @author <a href="mailto:peter.wall@sun.com">Peter Wall</a>
 * @author <a href="mailto:eye@ebay.com">Eric Ye</a>
 */

const RADIX = 10;
const AMPLIFIER = 1000000; // to keep 6 decimal
let moneyExchange = null;

// precached instances of zero and one monies for all currencies
const ZERO_MONIES = {};
const ONE_MONEYS = {};

function init() {
    Currencies.values.forEach(c => {
        ZERO_MONIES[c.name] = new Money(0.0, c);
        ONE_MONEYS[c.name] = new Money(shiftToLong(1.0), c);
    });
}

module.exports = {
    isMoney,
    valueOf: (val, currency) => valueOf(val, currency),
    setMoneyExchange,
    roundToCurrency,
    roundToImpliedDecimals,
    sum
};

function isMoney(obj) {
    return obj instanceof Money;
}

process.on('inject-money-exchange', svc => {
    if (svc) {
        setMoneyExchange({
            getExchangeRate: (when, fromCurrency, toCurrency) =>
                svc.getExchangeRate(when, fromCurrency, toCurrency)
        });
        return;
    }
    setMoneyExchange(undefined);
});

/**
 * Returns a Money object whose value is equal to that of the specified
 * <code>val</code> and <code>currency</code>. This "factory method"
 * is provided in preference to a constructor because it allows for reuse of
 * frequently used Money objeney.cts.
 *
 * @param val
 *            value of the Money to return.
 * @param currency
 *            currency of the Money to return.
 * @param internal
 *            if true, the currency value is internal/shifted to integer
 * @return a Money object with the specified value and currency.
 */
function valueOf(val, currency, internal) {
    if (typeof currency === 'string') {
        currency = Currencies.valueOf(currency);
    }
    else if(!(currency instanceof Currencies)) {
        throw new Error(`currency is not of Currency type ${currency}`);
    }
    if (val === 0) {
        return zeroValue(currency);
    }

    // Using a Map over an array because order is unimportant and
    // the map can have holes. Array does not work well under these cases.
    // Also,
    // any change to Currency would require a change to the array which is
    // error prone
    if (val === 1) {
		const m = ONE_MONEYS[currency.name];
        if (m) {
            return m;
        }
    }

    if (!internal) {
        val = shiftToLong(val);
    }

    // fall through for all other values or if could not find a Money object
    return new Money(val, currency);
}

function roundToImpliedDecimals(amount, numDecimals) {
    if (numDecimals < 0) {
        return amount;
    }
    let factor = AMPLIFIER;
    for (let i = numDecimals; i > 0; --i) {
        factor /= RADIX;
        if (factor < RADIX) {
            return amount;
        }
    }
    if ((amount.internalValue % factor) === 0) {
        // no need to round, return the same one
        return amount;
    }
    return valueOf(round((amount.internalValue) / factor) * factor,
        amount.currency, true);
}

/**
 * This method will round the money amount based on currency e.g. USD, there
 * will be 2 digits after decimal points; JPY, no decimal point, although
 * internally the money will still be stored with 6 digits after the decimal
 * point, only some of them will be zeros now after rounding.
 *
 * Returns original one if no rounding is required.
 *
 * @param amount
 *            the original money, Money type
 * @return Money rounded money - returns the original one if doesn't need to
 *         be rounded.
 */
function roundToCurrency(amount) {
    let factor = AMPLIFIER;
    for (let i = amount.currency.value.getDecimals(); i > 0; --i) {
        factor /= RADIX;
    }
    if ((amount.internalValue % factor) === 0) {
        // no need to round, return the same one
        return amount;
    }

    return valueOf(round((amount.internalValue) / factor) * factor,
        amount.currency, true);
}


/**
 * Bind the MoneyExchange impl to the Money during server startup
 *
 * @param moneyExchange
 */
function setMoneyExchange(me) {
    moneyExchange = me;
}

/**
 * returns a 0-value money for the specificed currency. This is a much
 * efficient way to create zero valued Money objects.
 *
 * @param currency is a Currency type
 * @return Money
 */
function zeroValue(currency) {
    return ZERO_MONIES[currency.name];
}


/**
 * Internal method to convert <code>double</code> to <code>long</code> by
 * multiplying by AMPLIFIER.
 *
 * @return the <code>long</code> value
 */
function shiftToLong(amount) {
    amount *= AMPLIFIER;
    return round(amount);
}

/**
 * Round the double value to long based on its absolute value.
 *
 * @param value
 *            the original double value
 *
 * @return long - the rounded value
 */
function round(value) {
    return (value >= 0) ? Math.round(value)
            : (-Math.round(Math.abs(value)));
}

/**
 * The sum method adds up all the amounts in a collection
 *
 * @param Array
 *            Collection of Money objects
 * @param Currency
 *            Local currency
 * @return Money total of list of transaction amounts
 */
function sum(amounts, currency) {
    if (!amounts || amounts.length === 0) {
        return valueOf(0, currency);
    }
    return amounts.reduce((total, amount) => {
        return total.add(amount);
    }, valueOf(0, currency));
}

class Money {
    /**
	 * Construct a Money object with a given value and currency.
	 *
	 * @param value
	 *            the value in cents (or equivalent)
	 * @param currency
	 *            the currency
	 * @exception IllegalArgumentException
	 *                if currency is null
	 * @deprecated use <code>valueOf</code> instead
	 * @see Money#valueOf(long, Currency)
	 */
    constructor(amount, currency) {
		this.internalValue = amount;
		this.currency = currency;
    }

	/**
	 * Returns the absolute Money representation of this Money instance. If this
	 * Money isPositive() it returns this else it returns negate().
	 *
	 * @return absolute Money representation for this instance
	 */
	absolute() {
		if (this.isPositive()) {
			return this;
		}
		return this.negate();
	}

	/**
	 * Get the currency for this money object.
	 *
	 * @return the currency object
	 */
	getCurrency() {
		return this.currency;
	}

	/**
	 * Add another Money value and return the sum. The two money values must
	 * have the same currency.
	 *
	 * @param other
	 *            the other Money value or number amount
	 * @return the sum of the two values
	 * @exception IllegalArgumentException
	 *                if objects have different currency
	 */
	add(other) {
        if (other instanceof Money) {
            this.sameCurrency(other);
    		return valueOf(this.internalValue + other.internalValue, this.currency, true);
        }
        if (typeof other === 'number') {
            return valueOf(this.internalValue + shiftToLong(other), this.currency, true);
        }
        throw new Error(`Attempt to add uknown type ${other} to the money object`);
	}

	/**
	 * Subtract another Money value and return the difference. The two money
	 * values must have the same currency.
	 *
	 * @param other
	 *            the other Money value
	 * @return the difference between the two values
	 * @exception IllegalArgumentException
	 *                if objects have different currency
	 */
	subtract(other) {
        if (other instanceof Money) {
            this.sameCurrency(other);
    		return valueOf(this.internalValue - other.internalValue, this.currency, true);
        }
        if (typeof other === 'number') {
            return valueOf(this.internalValue - shiftToLong(other), this.currency, true);
        }
        throw new Error(`Attempt to subtract uknown type ${other} to the money object`);
	}

	/**
	 * Multiply by an integer factor or floating that needs to be converted to integer.
	 *
	 * @param factor
	 *            the number to multiply by
	 * @return the result
	 */
	multiply(factor) {
    	return valueOf(round(this.internalValue * factor), this.currency, true);
	}

	/**
	 * Divide by an integer divisor or floating number. The division is carried out using integer
	 * arithmetic therefore truncation, not rounding, is used.
     *   OR
     * Divide by another Money to give a floating point (double) result. The two
     * money values must have the same currency.
	 *
	 * @param divisor
	 *            the number to divide by
	 * @return the quotient
	 */
     divide(divisor) {
         return valueOf(round((this.internalValue) / divisor), this.currency, true);
	}

	/**
	 * Negate a Money value.
	 *
	 * @return the negated value
	 */
	negate() {
		return valueOf(-this.internalValue, this.currency, true);
	}

	/**
	 * Get <code>long</code> value in minor units.
	 *
	 * @return the value in minor units
	 */
	getValueInMinorUnits() {
		let factor = AMPLIFIER;
		for (let i = this.currency.value.getDecimals(); i > 0; --i) {
			factor /= RADIX;
		}
		return round((this.internalValue) / factor);
	}


	/**
	 * Get <code>long</code> value in major units.
	 *
	 * @return the value in minor units
	 */
	getWholeNumberInMajorUnits() {
		return this.internalValue / AMPLIFIER;
	}

	/**
	 * Get <code>double</code> value in major units.
	 *
	 * @return the value in major units (possibly fractional)
	 */
	doubleValue() {
		return (this.internalValue) / AMPLIFIER;
	}

	/**
	 * Get <code>long</code> internal value (shifted up with 6 digits).
	 *
	 * @return the internal value
	 */
	getInternalValue() {
		return this.internalValue;
	}

	/**
	 * Check if the money has zero value.
	 *
	 * @return true if it's zero
	 */
	isZero() {
		return this.internalValue === 0;
	}

	/**
	 * Check if the money is greater than zero.
	 *
	 * @return true if it is greater than zero
	 */
	isPositive() {
		return this.internalValue > 0;
	}

	/**
	 * Check if the money is less than zero.
	 *
	 * @return true if it is less than zero
	 */
	isNegative() {
		return this.internalValue < 0;
	}

	/**
	 * Return true if it is a whole number in major units.
	 *
	 * @return true if it is whole number
	 */
	isWholeNumberInMajorUnits() {
		return (this.internalValue % AMPLIFIER) === 0;
	}

	/**
	 * Convert to a String representation. Returns a value in
	 *
	 * @return the string representation for this object
	 */
	toString() {
		return this.getValueInMinorUnits().toString();
	}

	/**
	 * Return the currency symbol for this object.
	 *
	 * @return the currency symbol
	 */
	getCurrencySymbol() {
		return this.currency.value.symbol;
	}


	/**
	 * Internal method to check that another object has the same currency.
	 *
	 * @exception IllegalArgumentException
	 *                if the currency differs
	 */
	sameCurrency(other) {
		if (other.currency !== this.currency) {
			throw new Error(`Invalid currency ${this.currency.toString()} vs ${other.currency.toString()}`);
		}
	}

	/**
	 * Convert this money to the currency specified in the input param, using
	 * the exchange rate at time specified in the input param (code is moved
	 * from MoneyExchangeBOFImpl)
	 *
	 * @param toCurrency
	 *            Currency
	 * @param when
	 *            Date
	 * @return promise for Money object
	 * @throws CurrencyException
	 * @throws InitializationException
	 */
	convert(toCurrency, when) {
        if (!when) {
            when = new Date();
        }
        if (typeof toCurrency === 'string') {
            toCurrency = Currencies.valueOf(toCurrency);
        }

		const fromCurrency = this.getCurrency();
		if (fromCurrency === toCurrency) {
			return new Promise(resolve => {
                resolve(this);
            });
		}

        if (!moneyExchange) {
			throw new Error('The money exchange has not been initialized');
		}
		// best to use double here. We are about to do arithmetic.
		const amount = this.doubleValue();
        return moneyExchange.getExchangeRate(when,
			fromCurrency, toCurrency)
            .then(erate => {
                const result = erate * amount;
                return valueOf(result, toCurrency);
            });
	}
}

init();
