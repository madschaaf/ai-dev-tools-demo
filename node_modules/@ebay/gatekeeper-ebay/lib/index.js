'use strict';

require('./traps');

const Fs = require('fs');
const Path = require('path');

var Util = require('util');
var requestUtils = require('./req-utils');
var deployedEnv = require('@ebay/environment-ebay');
var Domain = require('domain');
var Hoek = require('hoek');
var Async = require('async');
var objutil = require('objutil');
var logger =  require('@ebay/logging-inc').logger('gatekeeper-ebay');
var errors = require('@ebay/errors-ebay');

// uncaught error counter
var errorCount = 0;
var MAX_MEMORY = 7e8; // 700Mb

function sendCrashEmail(err, options, callback) {
    options = options || {};
    var errorCtx = {
        req: (options.requestInfo || {}),
        err: err
    };
    var emailBody = requestUtils.formatText(errorCtx);
    var to = deployedEnv.isProd() ? options.toAddr : options.stageToAddr;

    var Restart = errors.getRestartLog();

    Restart.setReason(emailBody)
           .sendEmail({to: to})
           .execute(function(err, info) {
                callback();
           });
}

function crash(err) {

    console.log('gatekeeper: Exiting due to uncaught exception', err.message, err.stack);

    process.emit('SIGTERM');

}


module.exports = function gatekeeperFactory(options) {
    options = options || {};
    errorCount = 0;

    return function gatekeeper(req, res, next) {
        var domainCtx = Domain.create();

        domainCtx.add(req);
        domainCtx.add(res);
        domainCtx.once('error', createUncaughtHandler(options, req, res, next));
        var _write = res.write;
        res.write = function gkWrite() {
            _write.apply(res, arguments);
        };
        var _end = res.end;
        res.end = Hoek.once(function detectEnd() {
            _end.apply(res, arguments);
            _write = Hoek.ignore;
        });

        // node 10 was async and was able to capture any uncaught errors
        // with node 12 it eliminated event emitter async nature, but we better have it for res listener
        res.on = (origFn => {
            return function (type, listener) {
                return origFn.call(this, type, (...args) => {
                    try {
                        return listener(...args);
                    }
                    catch (err) {
                        res.emit('error', err);
                    }
                });
            };
        })(res.on);

        domainCtx.run(next);
    };
};

function dumpErrorToFile(info) {
    const logPath = Path.join(process.cwd(), 'logs');
    try {
        !Fs.existsSync(logPath) && Fs.mkdirSync(logPath);
        const date = new Date();
        const label = `${date.toISOString().split('T').shift()}.${date.toTimeString().split(' ').shift()}`;
        Fs.writeFileSync(Path.join(logPath, 
            `crash-dump-${process.env.pm_id || 0}-${label}.json`), 
            JSON.stringify(info));
    }
    catch (err) {
        console.error(`Failed to generate crash dump due to`, err.stack);
    }
}

function createUncaughtHandler(options, req, res) {
    var delayOptions = options['delay-restart'];
    var restartOptions = typeof delayOptions === 'boolean' ? delayOptions : delayOptions || {};

    var memoryLimit = restartOptions['memory-threshold'] ?
        Math.min(restartOptions['memory-threshold'], MAX_MEMORY) : MAX_MEMORY;

    return function uncaughtHandler(err) {
        err = err || new Error(`Detected uncaught promise rejection with no error object`);
        if (deployedEnv.isDev()) {
            console.error('Uncaught error:', err);
            if (!res.headersSent) {
                res.status(500);
            }
            return res.end(err.stack);
        }

        var reqOpts = {
            requestInfo: requestUtils.getInfo(req),
            url: req.url,
            restartRequested: true
        };
        reqOpts = objutil.merge(options, reqOpts);
        reqOpts.requestInfo.env = deployedEnv._env();
        var handler = defaultHandler;
        if (options && options.errorHandler) {
            handler = typeof options.errorHandler ===
                'function' ? options.errorHandler :
                tryRequire(options.errorHandler) || defaultHandler;
        }

        var _crash = crash;
        logger.error('Uncaught error:', err);

        dumpErrorToFile({
            ...reqOpts.requestInfo,
            error: err.stack
        });

        if (options['delay-restart'] &&
                memoryLimit > process.memoryUsage().heapUsed &&
                (!restartOptions['error-threshold'] || restartOptions['error-threshold'] > ++errorCount)) {

            // here we make crash empty to prevent restart
            _crash = Hoek.ignore;
            reqOpts.restartRequested = false;
        }

        setTimeout(_crash.bind(null, err), options.timeout ||
            5000);

        Async.series([
            function runHandler(next) {
                handler(err, req, res, next);
            },
            function notify(next) {
                // send email in all cases even with custom handler
                sendCrashEmail(err, reqOpts, function(error, result) {
                    next();
                });
            }            
        ], function complete() {
            _crash(err);
        });
    };
}

function tryRequire(name) {
    try {
        return require(name);
    }
    catch(err) {}
}

function defaultHandler(err, request, response, callback) {
    var redirectUrl = 'http://pages.' + requestUtils.getBaseHost(request.hostname) +
            '/messages/page_not_responding.html';
    if (!response.headersSent) {
        /** To prevent Express to send ResponseBody **/
        request.accepts = function() {
            return '';
        };
        response.redirect(redirectUrl);
    }
    else {
        response.end(clientRedirect(redirectUrl, request));
    }
    callback();    
}

function clientRedirect(url, req) {
    var noncePH = req && req.csp && req.csp.nonce ? ' nonce="'+req.csp.nonce+'"' : '';
    return Util.format('<script'+noncePH+'>window.location.href="%s";</script>', url);
}
