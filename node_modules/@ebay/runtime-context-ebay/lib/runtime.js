const caller = require('caller');
const { promisify } = require('util');
const moduleConfig = promisify(require('@ebay/module-config-inc'));
const createProvider = require('oja-context-provider');
const defaultsDeep = require('lodash.defaultsdeep');
const ServiceProvider = require('@ebay/service-client-ebay');
const Readable = require('stream').Readable;

const configPromise = moduleConfig(module);

class ReadableStream extends Readable {
    constructor() {
        super({ objectMode: true });
        this._buffer = [];
        this._open = true;
    }

    push(data) {
        if (!this._open || this._buffer.length) {
            this._buffer.push(data);
            return this._open;
        }

        this._open = super.push(data);
        return this._open;
    }

    _read() {
        this._open = true;
        while (this._buffer.length && this._open) {
            this._open = super.push(this._buffer.shift());
        }
    }
}

class ServiceClientRequest {
    constructor(request) {
        this.request = request;
    }

    set() {
        this.request.set(...arguments);
        return this;
    }

    options() {
        this.request.options(...arguments);
        return this;
    }

    path() {
        this.request.path(...arguments);
        return this;
    }

    // promisify end function to return [response, stream]
    // in case of stream response, one can opt in to use stream instead of response
    end(isStreamRequested) {
        if (isStreamRequested) {
            const stream = new ReadableStream();
            this.request.end((err, response) => {
                if (err) {
                    setImmediate(() => stream.emit('error', err));
                    return;
                }
                // push chunks if any or finish
                stream.push(response || null);
                return;
            });
            return stream;
        }

        return new Promise((resolve, reject) => {
            this.request.end((err, response) => {
                if (err) {
                    return reject(err);
                }
                resolve(response);
            });
        });
    }
}

/**
 * service client ebay wrapper to convert callback style into promise based calls
 */
class ServiceClientProvider {
    constructor(ctx) {
        this.ctx = ServiceProvider.context(ctx);
    }

    getClient(name) {
        this.client = this.ctx.getClient(name);
        return this;
    }

    _initiateRequest(methodName, args) {
        const request = this.client[methodName](...args);
        return new ServiceClientRequest(request);
    }

    request() {
        return this._initiateRequest('request', arguments);
    }

    get() {
        return this._initiateRequest('get', arguments);
    }

    post() {
        return this._initiateRequest('post', arguments);
    }

    put() {
        return this._initiateRequest('put', arguments);
    }

    patch() {
        return this._initiateRequest('patch', arguments);
    }

    delete() {
        return this._initiateRequest('delete', arguments);
    }
}

/**
 * Extends promise based wrapper to provide mocking capabilities for service calls
 */
class ServiceClientProviderMock extends ServiceClientProvider {
    constructor(value) {
        super({});
        this.value = value;
    }

    _initiateRequest() {
        const value = this.value;
        return new ServiceClientRequest({
            requestOptions: {},
            set(name, val) {
                this.requestOptions.headers = this.requestOptions.headers || {};
                this.requestOptions.headers[name] = val;
            },
            path(path) {
                this.requestOptions.path = path;
            },
            options(opts) {
                Object.assign(this.requestOptions, opts);
            },
            async end(cb) {
                if (Array.isArray(value)) {
                    for (let index = 0; index < value.length; index++) {
                        const val = value[index];
                        await sendVal(val);
                    }
                    return;
                }
                await sendVal(value);

                async function sendVal(val) {
                    if (val instanceof Error) {
                        setImmediate(() => cb(val));
                        return;
                    }
                    if (val instanceof Promise) {
                        val = await val;
                    }
                    setImmediate(() => cb(null, val));
                }
            }
        });
    }
}

function tryRequire(name) {
    try {
        return require(name);
    }
    catch (error) {
        // skip
    }
}

function resolveHandlers(handlers) {
    if (handlers && typeof handlers === 'object') {
        Object.keys(handlers).forEach(name => {
            if (typeof handlers[name] === 'string') {
                const handler = tryRequire(handlers[name]);
                if (!handler) {
                    throw new Error(`Failed to resolve handler ${name}, path: ${handlers[name]}`);
                }
                handlers[name] = handler;
            }
        });
    }
    return handlers;
}

function resolveContextActions(runtimeContext) {
    Object.keys(runtimeContext).forEach(domainName => {
        const domain = runtimeContext[domainName];
        resolveHandlers(domain);
    });

    return runtimeContext;
}

let provider;

function setProvider(impl) {
    provider = impl;
}

let runtimeExplicitActions;
async function getExplicitActions(options) {
    if (runtimeExplicitActions) {
        return runtimeExplicitActions;
    }

    const config = options.config || await configPromise;
    const runtimeConfig = Object.assign({}, config.get('runtime-context'));
    delete runtimeConfig.sources;
    const functions = runtimeConfig.functions;
    delete runtimeConfig.functions;
    // merge them
    runtimeExplicitActions = resolveContextActions(
        defaultsDeep(
            {},
            runtimeConfig,
            functions
        ));

    return runtimeExplicitActions;
}

async function createContext(options = {}) {
    const config = options.config || await configPromise;

    const request = options.properties && options.properties.request;
    const response = options.properties && options.properties.response;

    // hook to response end call if it is present
    let endSignal;
    if (response) {
        // return promise
        endSignal = new Promise(resolve => {
            const _end = response.end;
            response.end = function (...args) {
                try {
                    return _end.apply(response, args);
                }
                finally {
                    // we just need to know if the connection is closed
                    resolve();
                }
            };

            response.once && response.once('close', resolve);
        });
    }

    if (options.reloadRuntimeConfig) {
        runtimeExplicitActions = undefined;
        provider = undefined;
    }

    // merge any runtime context into baseContext
    const baseContextConfig = {
        properties: {
            incoming: {
                request
            },
            outgoing: {
                response
            },
            ebay: request && request.ebay,
            parameters: request && (request.parameters ||
                Object.assign({},
                    request.query,
                    request.params,
                    request.body)),
            route: request && request.route,
            i18n: {
                getBundle(name, from = caller(1)) {
                    return new Promise((resolve, reject) => {
                        request.ebay.i18n.getBundle(name, from, (err, bundle) => {
                            if (err) {
                                return reject(err);
                            }
                            resolve(bundle);
                        });
                    });
                }
            }
        },
        functions: resolveContextActions(
            defaultsDeep(
                {},
                options.functions,
                await getExplicitActions(options)
            ))
    };

    const createRuntimeContext = await getProvider();
    const runtimeContext = createRuntimeContext(baseContextConfig);
    runtimeContext.end = () => endSignal;
    const services = runtimeContext.services = {
        define(name, value) {
            this[name] = new ServiceClientProviderMock(value);
            return this;
        }
    };
    // allow mocking any service
    const serviceMocks = options.services || {};
    Object.keys(serviceMocks).forEach(name => {
        services[name] = new ServiceClientProviderMock(serviceMocks[name]);
    });
    // inject service resolution for service client defined in config/services section
    Object.keys(config.get('services') || {}).forEach(name => {
        if (services[name]) {
            return;
        }

        let impl;
        Object.defineProperty(services, name, {
            get() {
                return impl || new ServiceClientProvider({
                    app: {
                        request
                    },
                    caller: caller(1),
                    isContext: true
                }).getClient(name);
            },

            set(val) {
                impl = val;
            },

            enumerable: true
        });
    });

    return runtimeContext;

    async function getProvider(locations) {
        if (provider) {
            return provider;
        }
        // eslint-disable-next-line no-shadow
        const config = options.config || await configPromise;
        const sources = config.get('runtime-context:sources');
        provider = await createProvider(sources);
        return provider;
    }
}

module.exports.create = createContext;
module.exports.setProvider = setProvider;

class Response {
    constructor(properties) {
        Object.assign(this, properties);
    }
}

const expressHandler = (controllerName, options = {}) => async (request, response, next) => {
    options.reloadRuntimeConfig = true;
    try {
        // create context
        const context = await createContext(Object.assign({}, options, {
            properties: {
                request,
                response,
                parameters: Object.assign({}, request.query, request.params, {
                    requestBody: request.body
                })
            }
        }));

        const timer = setTimeout(() => {
            console.warn(
                `Possibly detected runaway promise, no response end has been called for controller action ${
                    controllerName}`);
            process.emit('runtime-context:runaway:promise', {
                controllerName
            });
        }, process.env.MAX_RESPONSE_TIMEOUT || 50000).unref();

        const controllersDomain = options.controllersDomain || 'controllers';
        // call controller
        if (!context[controllersDomain][controllerName]) {
            throw new Error(`Cannot find controller: ${controllerName}`);
        }

        const result = await context[controllersDomain][controllerName](context.parameters);
        if (result instanceof Response) {
            // action requested to provide explicit response
            if (result.headers) {
                Object.entries(result.headers).forEach((entry) => {
                    const [name, value] = entry;
                    response.set(name, value);
                });
            }
            response.status(result.statusCode || result.status || 200);
            if (result.body) {
                if (result.body instanceof Readable) {
                    result.body.pipe(response);
                }
                else {
                    response.write(result.body);
                    response.end();
                }
            }
            else {
                response.end();
            }
        }

        try {
            // wait for response to close
            // setup timer to detect runaway promises
            await context.end();
        }
        finally {
            clearTimeout(timer);
        }
    }
    catch (err) {
        if (next) {
            next(err);
            return;
        }
        throw err;
    }
};

module.exports.ReadableStream = ReadableStream;
module.exports.express = {
    Response,
    expressHandler
};
module.exports.expressHandler = expressHandler;
